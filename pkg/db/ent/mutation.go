// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/appdefaultgood"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/appgood"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/appstock"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/comment"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/deviceinfo"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/extrainfo"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/good"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/goodreward"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/goodrewardhistory"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/predicate"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/promotion"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/recommend"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/requiredgood"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/stock"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/vendorlocation"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppDefaultGood    = "AppDefaultGood"
	TypeAppGood           = "AppGood"
	TypeAppStock          = "AppStock"
	TypeComment           = "Comment"
	TypeDeviceInfo        = "DeviceInfo"
	TypeExtraInfo         = "ExtraInfo"
	TypeGood              = "Good"
	TypeGoodReward        = "GoodReward"
	TypeGoodRewardHistory = "GoodRewardHistory"
	TypePromotion         = "Promotion"
	TypeRecommend         = "Recommend"
	TypeRequiredGood      = "RequiredGood"
	TypeStock             = "Stock"
	TypeVendorLocation    = "VendorLocation"
)

// AppDefaultGoodMutation represents an operation that mutates the AppDefaultGood nodes in the graph.
type AppDefaultGoodMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	good_id       *uuid.UUID
	coin_type_id  *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppDefaultGood, error)
	predicates    []predicate.AppDefaultGood
}

var _ ent.Mutation = (*AppDefaultGoodMutation)(nil)

// appdefaultgoodOption allows management of the mutation configuration using functional options.
type appdefaultgoodOption func(*AppDefaultGoodMutation)

// newAppDefaultGoodMutation creates new mutation for the AppDefaultGood entity.
func newAppDefaultGoodMutation(c config, op Op, opts ...appdefaultgoodOption) *AppDefaultGoodMutation {
	m := &AppDefaultGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeAppDefaultGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppDefaultGoodID sets the ID field of the mutation.
func withAppDefaultGoodID(id uuid.UUID) appdefaultgoodOption {
	return func(m *AppDefaultGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *AppDefaultGood
		)
		m.oldValue = func(ctx context.Context) (*AppDefaultGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppDefaultGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppDefaultGood sets the old AppDefaultGood of the mutation.
func withAppDefaultGood(node *AppDefaultGood) appdefaultgoodOption {
	return func(m *AppDefaultGoodMutation) {
		m.oldValue = func(context.Context) (*AppDefaultGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppDefaultGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppDefaultGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppDefaultGood entities.
func (m *AppDefaultGoodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppDefaultGoodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppDefaultGoodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppDefaultGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppDefaultGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppDefaultGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppDefaultGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppDefaultGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppDefaultGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppDefaultGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppDefaultGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppDefaultGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppDefaultGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppDefaultGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppDefaultGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppDefaultGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppDefaultGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppDefaultGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppDefaultGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppDefaultGoodMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppDefaultGoodMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppDefaultGoodMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *AppDefaultGoodMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppDefaultGoodMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppDefaultGoodMutation) ResetGoodID() {
	m.good_id = nil
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *AppDefaultGoodMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *AppDefaultGoodMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *AppDefaultGoodMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
}

// Where appends a list predicates to the AppDefaultGoodMutation builder.
func (m *AppDefaultGoodMutation) Where(ps ...predicate.AppDefaultGood) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppDefaultGoodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppDefaultGood).
func (m *AppDefaultGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppDefaultGoodMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, appdefaultgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appdefaultgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appdefaultgood.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appdefaultgood.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appdefaultgood.FieldGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, appdefaultgood.FieldCoinTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppDefaultGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		return m.CreatedAt()
	case appdefaultgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case appdefaultgood.FieldDeletedAt:
		return m.DeletedAt()
	case appdefaultgood.FieldAppID:
		return m.AppID()
	case appdefaultgood.FieldGoodID:
		return m.GoodID()
	case appdefaultgood.FieldCoinTypeID:
		return m.CoinTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppDefaultGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appdefaultgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appdefaultgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appdefaultgood.FieldAppID:
		return m.OldAppID(ctx)
	case appdefaultgood.FieldGoodID:
		return m.OldGoodID(ctx)
	case appdefaultgood.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown AppDefaultGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppDefaultGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appdefaultgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appdefaultgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appdefaultgood.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appdefaultgood.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appdefaultgood.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppDefaultGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appdefaultgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appdefaultgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appdefaultgood.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppDefaultGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appdefaultgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appdefaultgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppDefaultGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appdefaultgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appdefaultgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppDefaultGoodMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppDefaultGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppDefaultGoodMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppDefaultGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppDefaultGoodMutation) ResetField(name string) error {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appdefaultgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appdefaultgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appdefaultgood.FieldAppID:
		m.ResetAppID()
		return nil
	case appdefaultgood.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appdefaultgood.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppDefaultGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppDefaultGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppDefaultGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppDefaultGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppDefaultGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppDefaultGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppDefaultGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppDefaultGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppDefaultGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppDefaultGood edge %s", name)
}

// AppGoodMutation represents an operation that mutates the AppGood nodes in the graph.
type AppGoodMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	created_at                  *uint32
	addcreated_at               *int32
	updated_at                  *uint32
	addupdated_at               *int32
	deleted_at                  *uint32
	adddeleted_at               *int32
	app_id                      *uuid.UUID
	good_id                     *uuid.UUID
	online                      *bool
	visible                     *bool
	good_name                   *string
	price                       *decimal.Decimal
	display_index               *int32
	adddisplay_index            *int32
	purchase_limit              *int32
	addpurchase_limit           *int32
	sale_start_at               *uint32
	addsale_start_at            *int32
	sale_end_at                 *uint32
	addsale_end_at              *int32
	service_start_at            *uint32
	addservice_start_at         *int32
	descriptions                *[]string
	good_banner                 *string
	display_names               *[]string
	enable_purchase             *bool
	enable_product_page         *bool
	cancel_mode                 *string
	user_purchase_limit         *decimal.Decimal
	display_colors              *[]string
	cancellable_before_start    *uint32
	addcancellable_before_start *int32
	product_page                *string
	enable_set_commission       *bool
	posters                     *[]string
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*AppGood, error)
	predicates                  []predicate.AppGood
}

var _ ent.Mutation = (*AppGoodMutation)(nil)

// appgoodOption allows management of the mutation configuration using functional options.
type appgoodOption func(*AppGoodMutation)

// newAppGoodMutation creates new mutation for the AppGood entity.
func newAppGoodMutation(c config, op Op, opts ...appgoodOption) *AppGoodMutation {
	m := &AppGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodID sets the ID field of the mutation.
func withAppGoodID(id uuid.UUID) appgoodOption {
	return func(m *AppGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGood
		)
		m.oldValue = func(ctx context.Context) (*AppGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGood sets the old AppGood of the mutation.
func withAppGood(node *AppGood) appgoodOption {
	return func(m *AppGoodMutation) {
		m.oldValue = func(context.Context) (*AppGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGood entities.
func (m *AppGoodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppGoodMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppGoodMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppGoodMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *AppGoodMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppGoodMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppGoodMutation) ResetGoodID() {
	m.good_id = nil
}

// SetOnline sets the "online" field.
func (m *AppGoodMutation) SetOnline(b bool) {
	m.online = &b
}

// Online returns the value of the "online" field in the mutation.
func (m *AppGoodMutation) Online() (r bool, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// ClearOnline clears the value of the "online" field.
func (m *AppGoodMutation) ClearOnline() {
	m.online = nil
	m.clearedFields[appgood.FieldOnline] = struct{}{}
}

// OnlineCleared returns if the "online" field was cleared in this mutation.
func (m *AppGoodMutation) OnlineCleared() bool {
	_, ok := m.clearedFields[appgood.FieldOnline]
	return ok
}

// ResetOnline resets all changes to the "online" field.
func (m *AppGoodMutation) ResetOnline() {
	m.online = nil
	delete(m.clearedFields, appgood.FieldOnline)
}

// SetVisible sets the "visible" field.
func (m *AppGoodMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *AppGoodMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ClearVisible clears the value of the "visible" field.
func (m *AppGoodMutation) ClearVisible() {
	m.visible = nil
	m.clearedFields[appgood.FieldVisible] = struct{}{}
}

// VisibleCleared returns if the "visible" field was cleared in this mutation.
func (m *AppGoodMutation) VisibleCleared() bool {
	_, ok := m.clearedFields[appgood.FieldVisible]
	return ok
}

// ResetVisible resets all changes to the "visible" field.
func (m *AppGoodMutation) ResetVisible() {
	m.visible = nil
	delete(m.clearedFields, appgood.FieldVisible)
}

// SetGoodName sets the "good_name" field.
func (m *AppGoodMutation) SetGoodName(s string) {
	m.good_name = &s
}

// GoodName returns the value of the "good_name" field in the mutation.
func (m *AppGoodMutation) GoodName() (r string, exists bool) {
	v := m.good_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodName returns the old "good_name" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldGoodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodName: %w", err)
	}
	return oldValue.GoodName, nil
}

// ClearGoodName clears the value of the "good_name" field.
func (m *AppGoodMutation) ClearGoodName() {
	m.good_name = nil
	m.clearedFields[appgood.FieldGoodName] = struct{}{}
}

// GoodNameCleared returns if the "good_name" field was cleared in this mutation.
func (m *AppGoodMutation) GoodNameCleared() bool {
	_, ok := m.clearedFields[appgood.FieldGoodName]
	return ok
}

// ResetGoodName resets all changes to the "good_name" field.
func (m *AppGoodMutation) ResetGoodName() {
	m.good_name = nil
	delete(m.clearedFields, appgood.FieldGoodName)
}

// SetPrice sets the "price" field.
func (m *AppGoodMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *AppGoodMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *AppGoodMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[appgood.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *AppGoodMutation) PriceCleared() bool {
	_, ok := m.clearedFields[appgood.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *AppGoodMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, appgood.FieldPrice)
}

// SetDisplayIndex sets the "display_index" field.
func (m *AppGoodMutation) SetDisplayIndex(i int32) {
	m.display_index = &i
	m.adddisplay_index = nil
}

// DisplayIndex returns the value of the "display_index" field in the mutation.
func (m *AppGoodMutation) DisplayIndex() (r int32, exists bool) {
	v := m.display_index
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayIndex returns the old "display_index" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDisplayIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayIndex: %w", err)
	}
	return oldValue.DisplayIndex, nil
}

// AddDisplayIndex adds i to the "display_index" field.
func (m *AppGoodMutation) AddDisplayIndex(i int32) {
	if m.adddisplay_index != nil {
		*m.adddisplay_index += i
	} else {
		m.adddisplay_index = &i
	}
}

// AddedDisplayIndex returns the value that was added to the "display_index" field in this mutation.
func (m *AppGoodMutation) AddedDisplayIndex() (r int32, exists bool) {
	v := m.adddisplay_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplayIndex clears the value of the "display_index" field.
func (m *AppGoodMutation) ClearDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	m.clearedFields[appgood.FieldDisplayIndex] = struct{}{}
}

// DisplayIndexCleared returns if the "display_index" field was cleared in this mutation.
func (m *AppGoodMutation) DisplayIndexCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDisplayIndex]
	return ok
}

// ResetDisplayIndex resets all changes to the "display_index" field.
func (m *AppGoodMutation) ResetDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	delete(m.clearedFields, appgood.FieldDisplayIndex)
}

// SetPurchaseLimit sets the "purchase_limit" field.
func (m *AppGoodMutation) SetPurchaseLimit(i int32) {
	m.purchase_limit = &i
	m.addpurchase_limit = nil
}

// PurchaseLimit returns the value of the "purchase_limit" field in the mutation.
func (m *AppGoodMutation) PurchaseLimit() (r int32, exists bool) {
	v := m.purchase_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseLimit returns the old "purchase_limit" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldPurchaseLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseLimit: %w", err)
	}
	return oldValue.PurchaseLimit, nil
}

// AddPurchaseLimit adds i to the "purchase_limit" field.
func (m *AppGoodMutation) AddPurchaseLimit(i int32) {
	if m.addpurchase_limit != nil {
		*m.addpurchase_limit += i
	} else {
		m.addpurchase_limit = &i
	}
}

// AddedPurchaseLimit returns the value that was added to the "purchase_limit" field in this mutation.
func (m *AppGoodMutation) AddedPurchaseLimit() (r int32, exists bool) {
	v := m.addpurchase_limit
	if v == nil {
		return
	}
	return *v, true
}

// ClearPurchaseLimit clears the value of the "purchase_limit" field.
func (m *AppGoodMutation) ClearPurchaseLimit() {
	m.purchase_limit = nil
	m.addpurchase_limit = nil
	m.clearedFields[appgood.FieldPurchaseLimit] = struct{}{}
}

// PurchaseLimitCleared returns if the "purchase_limit" field was cleared in this mutation.
func (m *AppGoodMutation) PurchaseLimitCleared() bool {
	_, ok := m.clearedFields[appgood.FieldPurchaseLimit]
	return ok
}

// ResetPurchaseLimit resets all changes to the "purchase_limit" field.
func (m *AppGoodMutation) ResetPurchaseLimit() {
	m.purchase_limit = nil
	m.addpurchase_limit = nil
	delete(m.clearedFields, appgood.FieldPurchaseLimit)
}

// SetSaleStartAt sets the "sale_start_at" field.
func (m *AppGoodMutation) SetSaleStartAt(u uint32) {
	m.sale_start_at = &u
	m.addsale_start_at = nil
}

// SaleStartAt returns the value of the "sale_start_at" field in the mutation.
func (m *AppGoodMutation) SaleStartAt() (r uint32, exists bool) {
	v := m.sale_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleStartAt returns the old "sale_start_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldSaleStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleStartAt: %w", err)
	}
	return oldValue.SaleStartAt, nil
}

// AddSaleStartAt adds u to the "sale_start_at" field.
func (m *AppGoodMutation) AddSaleStartAt(u int32) {
	if m.addsale_start_at != nil {
		*m.addsale_start_at += u
	} else {
		m.addsale_start_at = &u
	}
}

// AddedSaleStartAt returns the value that was added to the "sale_start_at" field in this mutation.
func (m *AppGoodMutation) AddedSaleStartAt() (r int32, exists bool) {
	v := m.addsale_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaleStartAt clears the value of the "sale_start_at" field.
func (m *AppGoodMutation) ClearSaleStartAt() {
	m.sale_start_at = nil
	m.addsale_start_at = nil
	m.clearedFields[appgood.FieldSaleStartAt] = struct{}{}
}

// SaleStartAtCleared returns if the "sale_start_at" field was cleared in this mutation.
func (m *AppGoodMutation) SaleStartAtCleared() bool {
	_, ok := m.clearedFields[appgood.FieldSaleStartAt]
	return ok
}

// ResetSaleStartAt resets all changes to the "sale_start_at" field.
func (m *AppGoodMutation) ResetSaleStartAt() {
	m.sale_start_at = nil
	m.addsale_start_at = nil
	delete(m.clearedFields, appgood.FieldSaleStartAt)
}

// SetSaleEndAt sets the "sale_end_at" field.
func (m *AppGoodMutation) SetSaleEndAt(u uint32) {
	m.sale_end_at = &u
	m.addsale_end_at = nil
}

// SaleEndAt returns the value of the "sale_end_at" field in the mutation.
func (m *AppGoodMutation) SaleEndAt() (r uint32, exists bool) {
	v := m.sale_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleEndAt returns the old "sale_end_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldSaleEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleEndAt: %w", err)
	}
	return oldValue.SaleEndAt, nil
}

// AddSaleEndAt adds u to the "sale_end_at" field.
func (m *AppGoodMutation) AddSaleEndAt(u int32) {
	if m.addsale_end_at != nil {
		*m.addsale_end_at += u
	} else {
		m.addsale_end_at = &u
	}
}

// AddedSaleEndAt returns the value that was added to the "sale_end_at" field in this mutation.
func (m *AppGoodMutation) AddedSaleEndAt() (r int32, exists bool) {
	v := m.addsale_end_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaleEndAt clears the value of the "sale_end_at" field.
func (m *AppGoodMutation) ClearSaleEndAt() {
	m.sale_end_at = nil
	m.addsale_end_at = nil
	m.clearedFields[appgood.FieldSaleEndAt] = struct{}{}
}

// SaleEndAtCleared returns if the "sale_end_at" field was cleared in this mutation.
func (m *AppGoodMutation) SaleEndAtCleared() bool {
	_, ok := m.clearedFields[appgood.FieldSaleEndAt]
	return ok
}

// ResetSaleEndAt resets all changes to the "sale_end_at" field.
func (m *AppGoodMutation) ResetSaleEndAt() {
	m.sale_end_at = nil
	m.addsale_end_at = nil
	delete(m.clearedFields, appgood.FieldSaleEndAt)
}

// SetServiceStartAt sets the "service_start_at" field.
func (m *AppGoodMutation) SetServiceStartAt(u uint32) {
	m.service_start_at = &u
	m.addservice_start_at = nil
}

// ServiceStartAt returns the value of the "service_start_at" field in the mutation.
func (m *AppGoodMutation) ServiceStartAt() (r uint32, exists bool) {
	v := m.service_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceStartAt returns the old "service_start_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldServiceStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceStartAt: %w", err)
	}
	return oldValue.ServiceStartAt, nil
}

// AddServiceStartAt adds u to the "service_start_at" field.
func (m *AppGoodMutation) AddServiceStartAt(u int32) {
	if m.addservice_start_at != nil {
		*m.addservice_start_at += u
	} else {
		m.addservice_start_at = &u
	}
}

// AddedServiceStartAt returns the value that was added to the "service_start_at" field in this mutation.
func (m *AppGoodMutation) AddedServiceStartAt() (r int32, exists bool) {
	v := m.addservice_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearServiceStartAt clears the value of the "service_start_at" field.
func (m *AppGoodMutation) ClearServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	m.clearedFields[appgood.FieldServiceStartAt] = struct{}{}
}

// ServiceStartAtCleared returns if the "service_start_at" field was cleared in this mutation.
func (m *AppGoodMutation) ServiceStartAtCleared() bool {
	_, ok := m.clearedFields[appgood.FieldServiceStartAt]
	return ok
}

// ResetServiceStartAt resets all changes to the "service_start_at" field.
func (m *AppGoodMutation) ResetServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	delete(m.clearedFields, appgood.FieldServiceStartAt)
}

// SetDescriptions sets the "descriptions" field.
func (m *AppGoodMutation) SetDescriptions(s []string) {
	m.descriptions = &s
}

// Descriptions returns the value of the "descriptions" field in the mutation.
func (m *AppGoodMutation) Descriptions() (r []string, exists bool) {
	v := m.descriptions
	if v == nil {
		return
	}
	return *v, true
}

// OldDescriptions returns the old "descriptions" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDescriptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescriptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescriptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescriptions: %w", err)
	}
	return oldValue.Descriptions, nil
}

// ClearDescriptions clears the value of the "descriptions" field.
func (m *AppGoodMutation) ClearDescriptions() {
	m.descriptions = nil
	m.clearedFields[appgood.FieldDescriptions] = struct{}{}
}

// DescriptionsCleared returns if the "descriptions" field was cleared in this mutation.
func (m *AppGoodMutation) DescriptionsCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDescriptions]
	return ok
}

// ResetDescriptions resets all changes to the "descriptions" field.
func (m *AppGoodMutation) ResetDescriptions() {
	m.descriptions = nil
	delete(m.clearedFields, appgood.FieldDescriptions)
}

// SetGoodBanner sets the "good_banner" field.
func (m *AppGoodMutation) SetGoodBanner(s string) {
	m.good_banner = &s
}

// GoodBanner returns the value of the "good_banner" field in the mutation.
func (m *AppGoodMutation) GoodBanner() (r string, exists bool) {
	v := m.good_banner
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodBanner returns the old "good_banner" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldGoodBanner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodBanner: %w", err)
	}
	return oldValue.GoodBanner, nil
}

// ClearGoodBanner clears the value of the "good_banner" field.
func (m *AppGoodMutation) ClearGoodBanner() {
	m.good_banner = nil
	m.clearedFields[appgood.FieldGoodBanner] = struct{}{}
}

// GoodBannerCleared returns if the "good_banner" field was cleared in this mutation.
func (m *AppGoodMutation) GoodBannerCleared() bool {
	_, ok := m.clearedFields[appgood.FieldGoodBanner]
	return ok
}

// ResetGoodBanner resets all changes to the "good_banner" field.
func (m *AppGoodMutation) ResetGoodBanner() {
	m.good_banner = nil
	delete(m.clearedFields, appgood.FieldGoodBanner)
}

// SetDisplayNames sets the "display_names" field.
func (m *AppGoodMutation) SetDisplayNames(s []string) {
	m.display_names = &s
}

// DisplayNames returns the value of the "display_names" field in the mutation.
func (m *AppGoodMutation) DisplayNames() (r []string, exists bool) {
	v := m.display_names
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNames returns the old "display_names" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDisplayNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNames: %w", err)
	}
	return oldValue.DisplayNames, nil
}

// ClearDisplayNames clears the value of the "display_names" field.
func (m *AppGoodMutation) ClearDisplayNames() {
	m.display_names = nil
	m.clearedFields[appgood.FieldDisplayNames] = struct{}{}
}

// DisplayNamesCleared returns if the "display_names" field was cleared in this mutation.
func (m *AppGoodMutation) DisplayNamesCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDisplayNames]
	return ok
}

// ResetDisplayNames resets all changes to the "display_names" field.
func (m *AppGoodMutation) ResetDisplayNames() {
	m.display_names = nil
	delete(m.clearedFields, appgood.FieldDisplayNames)
}

// SetEnablePurchase sets the "enable_purchase" field.
func (m *AppGoodMutation) SetEnablePurchase(b bool) {
	m.enable_purchase = &b
}

// EnablePurchase returns the value of the "enable_purchase" field in the mutation.
func (m *AppGoodMutation) EnablePurchase() (r bool, exists bool) {
	v := m.enable_purchase
	if v == nil {
		return
	}
	return *v, true
}

// OldEnablePurchase returns the old "enable_purchase" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEnablePurchase(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnablePurchase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnablePurchase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnablePurchase: %w", err)
	}
	return oldValue.EnablePurchase, nil
}

// ClearEnablePurchase clears the value of the "enable_purchase" field.
func (m *AppGoodMutation) ClearEnablePurchase() {
	m.enable_purchase = nil
	m.clearedFields[appgood.FieldEnablePurchase] = struct{}{}
}

// EnablePurchaseCleared returns if the "enable_purchase" field was cleared in this mutation.
func (m *AppGoodMutation) EnablePurchaseCleared() bool {
	_, ok := m.clearedFields[appgood.FieldEnablePurchase]
	return ok
}

// ResetEnablePurchase resets all changes to the "enable_purchase" field.
func (m *AppGoodMutation) ResetEnablePurchase() {
	m.enable_purchase = nil
	delete(m.clearedFields, appgood.FieldEnablePurchase)
}

// SetEnableProductPage sets the "enable_product_page" field.
func (m *AppGoodMutation) SetEnableProductPage(b bool) {
	m.enable_product_page = &b
}

// EnableProductPage returns the value of the "enable_product_page" field in the mutation.
func (m *AppGoodMutation) EnableProductPage() (r bool, exists bool) {
	v := m.enable_product_page
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableProductPage returns the old "enable_product_page" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEnableProductPage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableProductPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableProductPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableProductPage: %w", err)
	}
	return oldValue.EnableProductPage, nil
}

// ClearEnableProductPage clears the value of the "enable_product_page" field.
func (m *AppGoodMutation) ClearEnableProductPage() {
	m.enable_product_page = nil
	m.clearedFields[appgood.FieldEnableProductPage] = struct{}{}
}

// EnableProductPageCleared returns if the "enable_product_page" field was cleared in this mutation.
func (m *AppGoodMutation) EnableProductPageCleared() bool {
	_, ok := m.clearedFields[appgood.FieldEnableProductPage]
	return ok
}

// ResetEnableProductPage resets all changes to the "enable_product_page" field.
func (m *AppGoodMutation) ResetEnableProductPage() {
	m.enable_product_page = nil
	delete(m.clearedFields, appgood.FieldEnableProductPage)
}

// SetCancelMode sets the "cancel_mode" field.
func (m *AppGoodMutation) SetCancelMode(s string) {
	m.cancel_mode = &s
}

// CancelMode returns the value of the "cancel_mode" field in the mutation.
func (m *AppGoodMutation) CancelMode() (r string, exists bool) {
	v := m.cancel_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelMode returns the old "cancel_mode" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldCancelMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelMode: %w", err)
	}
	return oldValue.CancelMode, nil
}

// ClearCancelMode clears the value of the "cancel_mode" field.
func (m *AppGoodMutation) ClearCancelMode() {
	m.cancel_mode = nil
	m.clearedFields[appgood.FieldCancelMode] = struct{}{}
}

// CancelModeCleared returns if the "cancel_mode" field was cleared in this mutation.
func (m *AppGoodMutation) CancelModeCleared() bool {
	_, ok := m.clearedFields[appgood.FieldCancelMode]
	return ok
}

// ResetCancelMode resets all changes to the "cancel_mode" field.
func (m *AppGoodMutation) ResetCancelMode() {
	m.cancel_mode = nil
	delete(m.clearedFields, appgood.FieldCancelMode)
}

// SetUserPurchaseLimit sets the "user_purchase_limit" field.
func (m *AppGoodMutation) SetUserPurchaseLimit(d decimal.Decimal) {
	m.user_purchase_limit = &d
}

// UserPurchaseLimit returns the value of the "user_purchase_limit" field in the mutation.
func (m *AppGoodMutation) UserPurchaseLimit() (r decimal.Decimal, exists bool) {
	v := m.user_purchase_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldUserPurchaseLimit returns the old "user_purchase_limit" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldUserPurchaseLimit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserPurchaseLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserPurchaseLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserPurchaseLimit: %w", err)
	}
	return oldValue.UserPurchaseLimit, nil
}

// ClearUserPurchaseLimit clears the value of the "user_purchase_limit" field.
func (m *AppGoodMutation) ClearUserPurchaseLimit() {
	m.user_purchase_limit = nil
	m.clearedFields[appgood.FieldUserPurchaseLimit] = struct{}{}
}

// UserPurchaseLimitCleared returns if the "user_purchase_limit" field was cleared in this mutation.
func (m *AppGoodMutation) UserPurchaseLimitCleared() bool {
	_, ok := m.clearedFields[appgood.FieldUserPurchaseLimit]
	return ok
}

// ResetUserPurchaseLimit resets all changes to the "user_purchase_limit" field.
func (m *AppGoodMutation) ResetUserPurchaseLimit() {
	m.user_purchase_limit = nil
	delete(m.clearedFields, appgood.FieldUserPurchaseLimit)
}

// SetDisplayColors sets the "display_colors" field.
func (m *AppGoodMutation) SetDisplayColors(s []string) {
	m.display_colors = &s
}

// DisplayColors returns the value of the "display_colors" field in the mutation.
func (m *AppGoodMutation) DisplayColors() (r []string, exists bool) {
	v := m.display_colors
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayColors returns the old "display_colors" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDisplayColors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayColors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayColors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayColors: %w", err)
	}
	return oldValue.DisplayColors, nil
}

// ClearDisplayColors clears the value of the "display_colors" field.
func (m *AppGoodMutation) ClearDisplayColors() {
	m.display_colors = nil
	m.clearedFields[appgood.FieldDisplayColors] = struct{}{}
}

// DisplayColorsCleared returns if the "display_colors" field was cleared in this mutation.
func (m *AppGoodMutation) DisplayColorsCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDisplayColors]
	return ok
}

// ResetDisplayColors resets all changes to the "display_colors" field.
func (m *AppGoodMutation) ResetDisplayColors() {
	m.display_colors = nil
	delete(m.clearedFields, appgood.FieldDisplayColors)
}

// SetCancellableBeforeStart sets the "cancellable_before_start" field.
func (m *AppGoodMutation) SetCancellableBeforeStart(u uint32) {
	m.cancellable_before_start = &u
	m.addcancellable_before_start = nil
}

// CancellableBeforeStart returns the value of the "cancellable_before_start" field in the mutation.
func (m *AppGoodMutation) CancellableBeforeStart() (r uint32, exists bool) {
	v := m.cancellable_before_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCancellableBeforeStart returns the old "cancellable_before_start" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldCancellableBeforeStart(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancellableBeforeStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancellableBeforeStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancellableBeforeStart: %w", err)
	}
	return oldValue.CancellableBeforeStart, nil
}

// AddCancellableBeforeStart adds u to the "cancellable_before_start" field.
func (m *AppGoodMutation) AddCancellableBeforeStart(u int32) {
	if m.addcancellable_before_start != nil {
		*m.addcancellable_before_start += u
	} else {
		m.addcancellable_before_start = &u
	}
}

// AddedCancellableBeforeStart returns the value that was added to the "cancellable_before_start" field in this mutation.
func (m *AppGoodMutation) AddedCancellableBeforeStart() (r int32, exists bool) {
	v := m.addcancellable_before_start
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancellableBeforeStart clears the value of the "cancellable_before_start" field.
func (m *AppGoodMutation) ClearCancellableBeforeStart() {
	m.cancellable_before_start = nil
	m.addcancellable_before_start = nil
	m.clearedFields[appgood.FieldCancellableBeforeStart] = struct{}{}
}

// CancellableBeforeStartCleared returns if the "cancellable_before_start" field was cleared in this mutation.
func (m *AppGoodMutation) CancellableBeforeStartCleared() bool {
	_, ok := m.clearedFields[appgood.FieldCancellableBeforeStart]
	return ok
}

// ResetCancellableBeforeStart resets all changes to the "cancellable_before_start" field.
func (m *AppGoodMutation) ResetCancellableBeforeStart() {
	m.cancellable_before_start = nil
	m.addcancellable_before_start = nil
	delete(m.clearedFields, appgood.FieldCancellableBeforeStart)
}

// SetProductPage sets the "product_page" field.
func (m *AppGoodMutation) SetProductPage(s string) {
	m.product_page = &s
}

// ProductPage returns the value of the "product_page" field in the mutation.
func (m *AppGoodMutation) ProductPage() (r string, exists bool) {
	v := m.product_page
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPage returns the old "product_page" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldProductPage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPage: %w", err)
	}
	return oldValue.ProductPage, nil
}

// ClearProductPage clears the value of the "product_page" field.
func (m *AppGoodMutation) ClearProductPage() {
	m.product_page = nil
	m.clearedFields[appgood.FieldProductPage] = struct{}{}
}

// ProductPageCleared returns if the "product_page" field was cleared in this mutation.
func (m *AppGoodMutation) ProductPageCleared() bool {
	_, ok := m.clearedFields[appgood.FieldProductPage]
	return ok
}

// ResetProductPage resets all changes to the "product_page" field.
func (m *AppGoodMutation) ResetProductPage() {
	m.product_page = nil
	delete(m.clearedFields, appgood.FieldProductPage)
}

// SetEnableSetCommission sets the "enable_set_commission" field.
func (m *AppGoodMutation) SetEnableSetCommission(b bool) {
	m.enable_set_commission = &b
}

// EnableSetCommission returns the value of the "enable_set_commission" field in the mutation.
func (m *AppGoodMutation) EnableSetCommission() (r bool, exists bool) {
	v := m.enable_set_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableSetCommission returns the old "enable_set_commission" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEnableSetCommission(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableSetCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableSetCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableSetCommission: %w", err)
	}
	return oldValue.EnableSetCommission, nil
}

// ClearEnableSetCommission clears the value of the "enable_set_commission" field.
func (m *AppGoodMutation) ClearEnableSetCommission() {
	m.enable_set_commission = nil
	m.clearedFields[appgood.FieldEnableSetCommission] = struct{}{}
}

// EnableSetCommissionCleared returns if the "enable_set_commission" field was cleared in this mutation.
func (m *AppGoodMutation) EnableSetCommissionCleared() bool {
	_, ok := m.clearedFields[appgood.FieldEnableSetCommission]
	return ok
}

// ResetEnableSetCommission resets all changes to the "enable_set_commission" field.
func (m *AppGoodMutation) ResetEnableSetCommission() {
	m.enable_set_commission = nil
	delete(m.clearedFields, appgood.FieldEnableSetCommission)
}

// SetPosters sets the "posters" field.
func (m *AppGoodMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *AppGoodMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *AppGoodMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[appgood.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *AppGoodMutation) PostersCleared() bool {
	_, ok := m.clearedFields[appgood.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *AppGoodMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, appgood.FieldPosters)
}

// Where appends a list predicates to the AppGoodMutation builder.
func (m *AppGoodMutation) Where(ps ...predicate.AppGood) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppGoodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppGood).
func (m *AppGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, appgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgood.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appgood.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appgood.FieldGoodID)
	}
	if m.online != nil {
		fields = append(fields, appgood.FieldOnline)
	}
	if m.visible != nil {
		fields = append(fields, appgood.FieldVisible)
	}
	if m.good_name != nil {
		fields = append(fields, appgood.FieldGoodName)
	}
	if m.price != nil {
		fields = append(fields, appgood.FieldPrice)
	}
	if m.display_index != nil {
		fields = append(fields, appgood.FieldDisplayIndex)
	}
	if m.purchase_limit != nil {
		fields = append(fields, appgood.FieldPurchaseLimit)
	}
	if m.sale_start_at != nil {
		fields = append(fields, appgood.FieldSaleStartAt)
	}
	if m.sale_end_at != nil {
		fields = append(fields, appgood.FieldSaleEndAt)
	}
	if m.service_start_at != nil {
		fields = append(fields, appgood.FieldServiceStartAt)
	}
	if m.descriptions != nil {
		fields = append(fields, appgood.FieldDescriptions)
	}
	if m.good_banner != nil {
		fields = append(fields, appgood.FieldGoodBanner)
	}
	if m.display_names != nil {
		fields = append(fields, appgood.FieldDisplayNames)
	}
	if m.enable_purchase != nil {
		fields = append(fields, appgood.FieldEnablePurchase)
	}
	if m.enable_product_page != nil {
		fields = append(fields, appgood.FieldEnableProductPage)
	}
	if m.cancel_mode != nil {
		fields = append(fields, appgood.FieldCancelMode)
	}
	if m.user_purchase_limit != nil {
		fields = append(fields, appgood.FieldUserPurchaseLimit)
	}
	if m.display_colors != nil {
		fields = append(fields, appgood.FieldDisplayColors)
	}
	if m.cancellable_before_start != nil {
		fields = append(fields, appgood.FieldCancellableBeforeStart)
	}
	if m.product_page != nil {
		fields = append(fields, appgood.FieldProductPage)
	}
	if m.enable_set_commission != nil {
		fields = append(fields, appgood.FieldEnableSetCommission)
	}
	if m.posters != nil {
		fields = append(fields, appgood.FieldPosters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgood.FieldCreatedAt:
		return m.CreatedAt()
	case appgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgood.FieldDeletedAt:
		return m.DeletedAt()
	case appgood.FieldAppID:
		return m.AppID()
	case appgood.FieldGoodID:
		return m.GoodID()
	case appgood.FieldOnline:
		return m.Online()
	case appgood.FieldVisible:
		return m.Visible()
	case appgood.FieldGoodName:
		return m.GoodName()
	case appgood.FieldPrice:
		return m.Price()
	case appgood.FieldDisplayIndex:
		return m.DisplayIndex()
	case appgood.FieldPurchaseLimit:
		return m.PurchaseLimit()
	case appgood.FieldSaleStartAt:
		return m.SaleStartAt()
	case appgood.FieldSaleEndAt:
		return m.SaleEndAt()
	case appgood.FieldServiceStartAt:
		return m.ServiceStartAt()
	case appgood.FieldDescriptions:
		return m.Descriptions()
	case appgood.FieldGoodBanner:
		return m.GoodBanner()
	case appgood.FieldDisplayNames:
		return m.DisplayNames()
	case appgood.FieldEnablePurchase:
		return m.EnablePurchase()
	case appgood.FieldEnableProductPage:
		return m.EnableProductPage()
	case appgood.FieldCancelMode:
		return m.CancelMode()
	case appgood.FieldUserPurchaseLimit:
		return m.UserPurchaseLimit()
	case appgood.FieldDisplayColors:
		return m.DisplayColors()
	case appgood.FieldCancellableBeforeStart:
		return m.CancellableBeforeStart()
	case appgood.FieldProductPage:
		return m.ProductPage()
	case appgood.FieldEnableSetCommission:
		return m.EnableSetCommission()
	case appgood.FieldPosters:
		return m.Posters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgood.FieldAppID:
		return m.OldAppID(ctx)
	case appgood.FieldGoodID:
		return m.OldGoodID(ctx)
	case appgood.FieldOnline:
		return m.OldOnline(ctx)
	case appgood.FieldVisible:
		return m.OldVisible(ctx)
	case appgood.FieldGoodName:
		return m.OldGoodName(ctx)
	case appgood.FieldPrice:
		return m.OldPrice(ctx)
	case appgood.FieldDisplayIndex:
		return m.OldDisplayIndex(ctx)
	case appgood.FieldPurchaseLimit:
		return m.OldPurchaseLimit(ctx)
	case appgood.FieldSaleStartAt:
		return m.OldSaleStartAt(ctx)
	case appgood.FieldSaleEndAt:
		return m.OldSaleEndAt(ctx)
	case appgood.FieldServiceStartAt:
		return m.OldServiceStartAt(ctx)
	case appgood.FieldDescriptions:
		return m.OldDescriptions(ctx)
	case appgood.FieldGoodBanner:
		return m.OldGoodBanner(ctx)
	case appgood.FieldDisplayNames:
		return m.OldDisplayNames(ctx)
	case appgood.FieldEnablePurchase:
		return m.OldEnablePurchase(ctx)
	case appgood.FieldEnableProductPage:
		return m.OldEnableProductPage(ctx)
	case appgood.FieldCancelMode:
		return m.OldCancelMode(ctx)
	case appgood.FieldUserPurchaseLimit:
		return m.OldUserPurchaseLimit(ctx)
	case appgood.FieldDisplayColors:
		return m.OldDisplayColors(ctx)
	case appgood.FieldCancellableBeforeStart:
		return m.OldCancellableBeforeStart(ctx)
	case appgood.FieldProductPage:
		return m.OldProductPage(ctx)
	case appgood.FieldEnableSetCommission:
		return m.OldEnableSetCommission(ctx)
	case appgood.FieldPosters:
		return m.OldPosters(ctx)
	}
	return nil, fmt.Errorf("unknown AppGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgood.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appgood.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appgood.FieldOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case appgood.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	case appgood.FieldGoodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodName(v)
		return nil
	case appgood.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case appgood.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayIndex(v)
		return nil
	case appgood.FieldPurchaseLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseLimit(v)
		return nil
	case appgood.FieldSaleStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleStartAt(v)
		return nil
	case appgood.FieldSaleEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleEndAt(v)
		return nil
	case appgood.FieldServiceStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceStartAt(v)
		return nil
	case appgood.FieldDescriptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescriptions(v)
		return nil
	case appgood.FieldGoodBanner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodBanner(v)
		return nil
	case appgood.FieldDisplayNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNames(v)
		return nil
	case appgood.FieldEnablePurchase:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnablePurchase(v)
		return nil
	case appgood.FieldEnableProductPage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableProductPage(v)
		return nil
	case appgood.FieldCancelMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelMode(v)
		return nil
	case appgood.FieldUserPurchaseLimit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserPurchaseLimit(v)
		return nil
	case appgood.FieldDisplayColors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayColors(v)
		return nil
	case appgood.FieldCancellableBeforeStart:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancellableBeforeStart(v)
		return nil
	case appgood.FieldProductPage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPage(v)
		return nil
	case appgood.FieldEnableSetCommission:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableSetCommission(v)
		return nil
	case appgood.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	}
	return fmt.Errorf("unknown AppGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgood.FieldDeletedAt)
	}
	if m.adddisplay_index != nil {
		fields = append(fields, appgood.FieldDisplayIndex)
	}
	if m.addpurchase_limit != nil {
		fields = append(fields, appgood.FieldPurchaseLimit)
	}
	if m.addsale_start_at != nil {
		fields = append(fields, appgood.FieldSaleStartAt)
	}
	if m.addsale_end_at != nil {
		fields = append(fields, appgood.FieldSaleEndAt)
	}
	if m.addservice_start_at != nil {
		fields = append(fields, appgood.FieldServiceStartAt)
	}
	if m.addcancellable_before_start != nil {
		fields = append(fields, appgood.FieldCancellableBeforeStart)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgood.FieldDisplayIndex:
		return m.AddedDisplayIndex()
	case appgood.FieldPurchaseLimit:
		return m.AddedPurchaseLimit()
	case appgood.FieldSaleStartAt:
		return m.AddedSaleStartAt()
	case appgood.FieldSaleEndAt:
		return m.AddedSaleEndAt()
	case appgood.FieldServiceStartAt:
		return m.AddedServiceStartAt()
	case appgood.FieldCancellableBeforeStart:
		return m.AddedCancellableBeforeStart()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgood.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayIndex(v)
		return nil
	case appgood.FieldPurchaseLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchaseLimit(v)
		return nil
	case appgood.FieldSaleStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleStartAt(v)
		return nil
	case appgood.FieldSaleEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleEndAt(v)
		return nil
	case appgood.FieldServiceStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceStartAt(v)
		return nil
	case appgood.FieldCancellableBeforeStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancellableBeforeStart(v)
		return nil
	}
	return fmt.Errorf("unknown AppGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgood.FieldOnline) {
		fields = append(fields, appgood.FieldOnline)
	}
	if m.FieldCleared(appgood.FieldVisible) {
		fields = append(fields, appgood.FieldVisible)
	}
	if m.FieldCleared(appgood.FieldGoodName) {
		fields = append(fields, appgood.FieldGoodName)
	}
	if m.FieldCleared(appgood.FieldPrice) {
		fields = append(fields, appgood.FieldPrice)
	}
	if m.FieldCleared(appgood.FieldDisplayIndex) {
		fields = append(fields, appgood.FieldDisplayIndex)
	}
	if m.FieldCleared(appgood.FieldPurchaseLimit) {
		fields = append(fields, appgood.FieldPurchaseLimit)
	}
	if m.FieldCleared(appgood.FieldSaleStartAt) {
		fields = append(fields, appgood.FieldSaleStartAt)
	}
	if m.FieldCleared(appgood.FieldSaleEndAt) {
		fields = append(fields, appgood.FieldSaleEndAt)
	}
	if m.FieldCleared(appgood.FieldServiceStartAt) {
		fields = append(fields, appgood.FieldServiceStartAt)
	}
	if m.FieldCleared(appgood.FieldDescriptions) {
		fields = append(fields, appgood.FieldDescriptions)
	}
	if m.FieldCleared(appgood.FieldGoodBanner) {
		fields = append(fields, appgood.FieldGoodBanner)
	}
	if m.FieldCleared(appgood.FieldDisplayNames) {
		fields = append(fields, appgood.FieldDisplayNames)
	}
	if m.FieldCleared(appgood.FieldEnablePurchase) {
		fields = append(fields, appgood.FieldEnablePurchase)
	}
	if m.FieldCleared(appgood.FieldEnableProductPage) {
		fields = append(fields, appgood.FieldEnableProductPage)
	}
	if m.FieldCleared(appgood.FieldCancelMode) {
		fields = append(fields, appgood.FieldCancelMode)
	}
	if m.FieldCleared(appgood.FieldUserPurchaseLimit) {
		fields = append(fields, appgood.FieldUserPurchaseLimit)
	}
	if m.FieldCleared(appgood.FieldDisplayColors) {
		fields = append(fields, appgood.FieldDisplayColors)
	}
	if m.FieldCleared(appgood.FieldCancellableBeforeStart) {
		fields = append(fields, appgood.FieldCancellableBeforeStart)
	}
	if m.FieldCleared(appgood.FieldProductPage) {
		fields = append(fields, appgood.FieldProductPage)
	}
	if m.FieldCleared(appgood.FieldEnableSetCommission) {
		fields = append(fields, appgood.FieldEnableSetCommission)
	}
	if m.FieldCleared(appgood.FieldPosters) {
		fields = append(fields, appgood.FieldPosters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodMutation) ClearField(name string) error {
	switch name {
	case appgood.FieldOnline:
		m.ClearOnline()
		return nil
	case appgood.FieldVisible:
		m.ClearVisible()
		return nil
	case appgood.FieldGoodName:
		m.ClearGoodName()
		return nil
	case appgood.FieldPrice:
		m.ClearPrice()
		return nil
	case appgood.FieldDisplayIndex:
		m.ClearDisplayIndex()
		return nil
	case appgood.FieldPurchaseLimit:
		m.ClearPurchaseLimit()
		return nil
	case appgood.FieldSaleStartAt:
		m.ClearSaleStartAt()
		return nil
	case appgood.FieldSaleEndAt:
		m.ClearSaleEndAt()
		return nil
	case appgood.FieldServiceStartAt:
		m.ClearServiceStartAt()
		return nil
	case appgood.FieldDescriptions:
		m.ClearDescriptions()
		return nil
	case appgood.FieldGoodBanner:
		m.ClearGoodBanner()
		return nil
	case appgood.FieldDisplayNames:
		m.ClearDisplayNames()
		return nil
	case appgood.FieldEnablePurchase:
		m.ClearEnablePurchase()
		return nil
	case appgood.FieldEnableProductPage:
		m.ClearEnableProductPage()
		return nil
	case appgood.FieldCancelMode:
		m.ClearCancelMode()
		return nil
	case appgood.FieldUserPurchaseLimit:
		m.ClearUserPurchaseLimit()
		return nil
	case appgood.FieldDisplayColors:
		m.ClearDisplayColors()
		return nil
	case appgood.FieldCancellableBeforeStart:
		m.ClearCancellableBeforeStart()
		return nil
	case appgood.FieldProductPage:
		m.ClearProductPage()
		return nil
	case appgood.FieldEnableSetCommission:
		m.ClearEnableSetCommission()
		return nil
	case appgood.FieldPosters:
		m.ClearPosters()
		return nil
	}
	return fmt.Errorf("unknown AppGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodMutation) ResetField(name string) error {
	switch name {
	case appgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgood.FieldAppID:
		m.ResetAppID()
		return nil
	case appgood.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appgood.FieldOnline:
		m.ResetOnline()
		return nil
	case appgood.FieldVisible:
		m.ResetVisible()
		return nil
	case appgood.FieldGoodName:
		m.ResetGoodName()
		return nil
	case appgood.FieldPrice:
		m.ResetPrice()
		return nil
	case appgood.FieldDisplayIndex:
		m.ResetDisplayIndex()
		return nil
	case appgood.FieldPurchaseLimit:
		m.ResetPurchaseLimit()
		return nil
	case appgood.FieldSaleStartAt:
		m.ResetSaleStartAt()
		return nil
	case appgood.FieldSaleEndAt:
		m.ResetSaleEndAt()
		return nil
	case appgood.FieldServiceStartAt:
		m.ResetServiceStartAt()
		return nil
	case appgood.FieldDescriptions:
		m.ResetDescriptions()
		return nil
	case appgood.FieldGoodBanner:
		m.ResetGoodBanner()
		return nil
	case appgood.FieldDisplayNames:
		m.ResetDisplayNames()
		return nil
	case appgood.FieldEnablePurchase:
		m.ResetEnablePurchase()
		return nil
	case appgood.FieldEnableProductPage:
		m.ResetEnableProductPage()
		return nil
	case appgood.FieldCancelMode:
		m.ResetCancelMode()
		return nil
	case appgood.FieldUserPurchaseLimit:
		m.ResetUserPurchaseLimit()
		return nil
	case appgood.FieldDisplayColors:
		m.ResetDisplayColors()
		return nil
	case appgood.FieldCancellableBeforeStart:
		m.ResetCancellableBeforeStart()
		return nil
	case appgood.FieldProductPage:
		m.ResetProductPage()
		return nil
	case appgood.FieldEnableSetCommission:
		m.ResetEnableSetCommission()
		return nil
	case appgood.FieldPosters:
		m.ResetPosters()
		return nil
	}
	return fmt.Errorf("unknown AppGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGood edge %s", name)
}

// AppStockMutation represents an operation that mutates the AppStock nodes in the graph.
type AppStockMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	good_id       *uuid.UUID
	total         *decimal.Decimal
	spot_quantity *decimal.Decimal
	locked        *decimal.Decimal
	in_service    *decimal.Decimal
	wait_start    *decimal.Decimal
	sold          *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppStock, error)
	predicates    []predicate.AppStock
}

var _ ent.Mutation = (*AppStockMutation)(nil)

// appstockOption allows management of the mutation configuration using functional options.
type appstockOption func(*AppStockMutation)

// newAppStockMutation creates new mutation for the AppStock entity.
func newAppStockMutation(c config, op Op, opts ...appstockOption) *AppStockMutation {
	m := &AppStockMutation{
		config:        c,
		op:            op,
		typ:           TypeAppStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppStockID sets the ID field of the mutation.
func withAppStockID(id uuid.UUID) appstockOption {
	return func(m *AppStockMutation) {
		var (
			err   error
			once  sync.Once
			value *AppStock
		)
		m.oldValue = func(ctx context.Context) (*AppStock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppStock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppStock sets the old AppStock of the mutation.
func withAppStock(node *AppStock) appstockOption {
	return func(m *AppStockMutation) {
		m.oldValue = func(context.Context) (*AppStock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppStockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppStockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppStock entities.
func (m *AppStockMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppStockMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppStockMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppStock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppStockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppStockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppStockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppStockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppStockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppStockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppStockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppStockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppStockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppStockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppStockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppStockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppStockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppStockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppStockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppStockMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppStockMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppStockMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *AppStockMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppStockMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppStockMutation) ResetGoodID() {
	m.good_id = nil
}

// SetTotal sets the "total" field.
func (m *AppStockMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
}

// Total returns the value of the "total" field in the mutation.
func (m *AppStockMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldTotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// ClearTotal clears the value of the "total" field.
func (m *AppStockMutation) ClearTotal() {
	m.total = nil
	m.clearedFields[appstock.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *AppStockMutation) TotalCleared() bool {
	_, ok := m.clearedFields[appstock.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *AppStockMutation) ResetTotal() {
	m.total = nil
	delete(m.clearedFields, appstock.FieldTotal)
}

// SetSpotQuantity sets the "spot_quantity" field.
func (m *AppStockMutation) SetSpotQuantity(d decimal.Decimal) {
	m.spot_quantity = &d
}

// SpotQuantity returns the value of the "spot_quantity" field in the mutation.
func (m *AppStockMutation) SpotQuantity() (r decimal.Decimal, exists bool) {
	v := m.spot_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotQuantity returns the old "spot_quantity" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldSpotQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotQuantity: %w", err)
	}
	return oldValue.SpotQuantity, nil
}

// ClearSpotQuantity clears the value of the "spot_quantity" field.
func (m *AppStockMutation) ClearSpotQuantity() {
	m.spot_quantity = nil
	m.clearedFields[appstock.FieldSpotQuantity] = struct{}{}
}

// SpotQuantityCleared returns if the "spot_quantity" field was cleared in this mutation.
func (m *AppStockMutation) SpotQuantityCleared() bool {
	_, ok := m.clearedFields[appstock.FieldSpotQuantity]
	return ok
}

// ResetSpotQuantity resets all changes to the "spot_quantity" field.
func (m *AppStockMutation) ResetSpotQuantity() {
	m.spot_quantity = nil
	delete(m.clearedFields, appstock.FieldSpotQuantity)
}

// SetLocked sets the "locked" field.
func (m *AppStockMutation) SetLocked(d decimal.Decimal) {
	m.locked = &d
}

// Locked returns the value of the "locked" field in the mutation.
func (m *AppStockMutation) Locked() (r decimal.Decimal, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ClearLocked clears the value of the "locked" field.
func (m *AppStockMutation) ClearLocked() {
	m.locked = nil
	m.clearedFields[appstock.FieldLocked] = struct{}{}
}

// LockedCleared returns if the "locked" field was cleared in this mutation.
func (m *AppStockMutation) LockedCleared() bool {
	_, ok := m.clearedFields[appstock.FieldLocked]
	return ok
}

// ResetLocked resets all changes to the "locked" field.
func (m *AppStockMutation) ResetLocked() {
	m.locked = nil
	delete(m.clearedFields, appstock.FieldLocked)
}

// SetInService sets the "in_service" field.
func (m *AppStockMutation) SetInService(d decimal.Decimal) {
	m.in_service = &d
}

// InService returns the value of the "in_service" field in the mutation.
func (m *AppStockMutation) InService() (r decimal.Decimal, exists bool) {
	v := m.in_service
	if v == nil {
		return
	}
	return *v, true
}

// OldInService returns the old "in_service" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldInService(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInService: %w", err)
	}
	return oldValue.InService, nil
}

// ClearInService clears the value of the "in_service" field.
func (m *AppStockMutation) ClearInService() {
	m.in_service = nil
	m.clearedFields[appstock.FieldInService] = struct{}{}
}

// InServiceCleared returns if the "in_service" field was cleared in this mutation.
func (m *AppStockMutation) InServiceCleared() bool {
	_, ok := m.clearedFields[appstock.FieldInService]
	return ok
}

// ResetInService resets all changes to the "in_service" field.
func (m *AppStockMutation) ResetInService() {
	m.in_service = nil
	delete(m.clearedFields, appstock.FieldInService)
}

// SetWaitStart sets the "wait_start" field.
func (m *AppStockMutation) SetWaitStart(d decimal.Decimal) {
	m.wait_start = &d
}

// WaitStart returns the value of the "wait_start" field in the mutation.
func (m *AppStockMutation) WaitStart() (r decimal.Decimal, exists bool) {
	v := m.wait_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWaitStart returns the old "wait_start" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldWaitStart(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaitStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaitStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaitStart: %w", err)
	}
	return oldValue.WaitStart, nil
}

// ClearWaitStart clears the value of the "wait_start" field.
func (m *AppStockMutation) ClearWaitStart() {
	m.wait_start = nil
	m.clearedFields[appstock.FieldWaitStart] = struct{}{}
}

// WaitStartCleared returns if the "wait_start" field was cleared in this mutation.
func (m *AppStockMutation) WaitStartCleared() bool {
	_, ok := m.clearedFields[appstock.FieldWaitStart]
	return ok
}

// ResetWaitStart resets all changes to the "wait_start" field.
func (m *AppStockMutation) ResetWaitStart() {
	m.wait_start = nil
	delete(m.clearedFields, appstock.FieldWaitStart)
}

// SetSold sets the "sold" field.
func (m *AppStockMutation) SetSold(d decimal.Decimal) {
	m.sold = &d
}

// Sold returns the value of the "sold" field in the mutation.
func (m *AppStockMutation) Sold() (r decimal.Decimal, exists bool) {
	v := m.sold
	if v == nil {
		return
	}
	return *v, true
}

// OldSold returns the old "sold" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldSold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSold: %w", err)
	}
	return oldValue.Sold, nil
}

// ClearSold clears the value of the "sold" field.
func (m *AppStockMutation) ClearSold() {
	m.sold = nil
	m.clearedFields[appstock.FieldSold] = struct{}{}
}

// SoldCleared returns if the "sold" field was cleared in this mutation.
func (m *AppStockMutation) SoldCleared() bool {
	_, ok := m.clearedFields[appstock.FieldSold]
	return ok
}

// ResetSold resets all changes to the "sold" field.
func (m *AppStockMutation) ResetSold() {
	m.sold = nil
	delete(m.clearedFields, appstock.FieldSold)
}

// Where appends a list predicates to the AppStockMutation builder.
func (m *AppStockMutation) Where(ps ...predicate.AppStock) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppStockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppStock).
func (m *AppStockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppStockMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, appstock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appstock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appstock.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appstock.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appstock.FieldGoodID)
	}
	if m.total != nil {
		fields = append(fields, appstock.FieldTotal)
	}
	if m.spot_quantity != nil {
		fields = append(fields, appstock.FieldSpotQuantity)
	}
	if m.locked != nil {
		fields = append(fields, appstock.FieldLocked)
	}
	if m.in_service != nil {
		fields = append(fields, appstock.FieldInService)
	}
	if m.wait_start != nil {
		fields = append(fields, appstock.FieldWaitStart)
	}
	if m.sold != nil {
		fields = append(fields, appstock.FieldSold)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppStockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appstock.FieldCreatedAt:
		return m.CreatedAt()
	case appstock.FieldUpdatedAt:
		return m.UpdatedAt()
	case appstock.FieldDeletedAt:
		return m.DeletedAt()
	case appstock.FieldAppID:
		return m.AppID()
	case appstock.FieldGoodID:
		return m.GoodID()
	case appstock.FieldTotal:
		return m.Total()
	case appstock.FieldSpotQuantity:
		return m.SpotQuantity()
	case appstock.FieldLocked:
		return m.Locked()
	case appstock.FieldInService:
		return m.InService()
	case appstock.FieldWaitStart:
		return m.WaitStart()
	case appstock.FieldSold:
		return m.Sold()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppStockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appstock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appstock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appstock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appstock.FieldAppID:
		return m.OldAppID(ctx)
	case appstock.FieldGoodID:
		return m.OldGoodID(ctx)
	case appstock.FieldTotal:
		return m.OldTotal(ctx)
	case appstock.FieldSpotQuantity:
		return m.OldSpotQuantity(ctx)
	case appstock.FieldLocked:
		return m.OldLocked(ctx)
	case appstock.FieldInService:
		return m.OldInService(ctx)
	case appstock.FieldWaitStart:
		return m.OldWaitStart(ctx)
	case appstock.FieldSold:
		return m.OldSold(ctx)
	}
	return nil, fmt.Errorf("unknown AppStock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appstock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appstock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appstock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appstock.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appstock.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appstock.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case appstock.FieldSpotQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotQuantity(v)
		return nil
	case appstock.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case appstock.FieldInService:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInService(v)
		return nil
	case appstock.FieldWaitStart:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaitStart(v)
		return nil
	case appstock.FieldSold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSold(v)
		return nil
	}
	return fmt.Errorf("unknown AppStock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppStockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appstock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appstock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appstock.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppStockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appstock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appstock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appstock.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appstock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appstock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appstock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppStock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppStockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appstock.FieldTotal) {
		fields = append(fields, appstock.FieldTotal)
	}
	if m.FieldCleared(appstock.FieldSpotQuantity) {
		fields = append(fields, appstock.FieldSpotQuantity)
	}
	if m.FieldCleared(appstock.FieldLocked) {
		fields = append(fields, appstock.FieldLocked)
	}
	if m.FieldCleared(appstock.FieldInService) {
		fields = append(fields, appstock.FieldInService)
	}
	if m.FieldCleared(appstock.FieldWaitStart) {
		fields = append(fields, appstock.FieldWaitStart)
	}
	if m.FieldCleared(appstock.FieldSold) {
		fields = append(fields, appstock.FieldSold)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppStockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppStockMutation) ClearField(name string) error {
	switch name {
	case appstock.FieldTotal:
		m.ClearTotal()
		return nil
	case appstock.FieldSpotQuantity:
		m.ClearSpotQuantity()
		return nil
	case appstock.FieldLocked:
		m.ClearLocked()
		return nil
	case appstock.FieldInService:
		m.ClearInService()
		return nil
	case appstock.FieldWaitStart:
		m.ClearWaitStart()
		return nil
	case appstock.FieldSold:
		m.ClearSold()
		return nil
	}
	return fmt.Errorf("unknown AppStock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppStockMutation) ResetField(name string) error {
	switch name {
	case appstock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appstock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appstock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appstock.FieldAppID:
		m.ResetAppID()
		return nil
	case appstock.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appstock.FieldTotal:
		m.ResetTotal()
		return nil
	case appstock.FieldSpotQuantity:
		m.ResetSpotQuantity()
		return nil
	case appstock.FieldLocked:
		m.ResetLocked()
		return nil
	case appstock.FieldInService:
		m.ResetInService()
		return nil
	case appstock.FieldWaitStart:
		m.ResetWaitStart()
		return nil
	case appstock.FieldSold:
		m.ResetSold()
		return nil
	}
	return fmt.Errorf("unknown AppStock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppStockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppStockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppStockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppStockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppStockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppStockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppStockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppStock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppStockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppStock edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	good_id       *uuid.UUID
	order_id      *uuid.UUID
	content       *string
	reply_to_id   *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Comment, error)
	predicates    []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uuid.UUID) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CommentMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CommentMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CommentMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CommentMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CommentMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CommentMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *CommentMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CommentMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CommentMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *CommentMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *CommentMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *CommentMutation) ResetGoodID() {
	m.good_id = nil
}

// SetOrderID sets the "order_id" field.
func (m *CommentMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CommentMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CommentMutation) ResetOrderID() {
	m.order_id = nil
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *CommentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[comment.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *CommentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[comment.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, comment.FieldContent)
}

// SetReplyToID sets the "reply_to_id" field.
func (m *CommentMutation) SetReplyToID(u uuid.UUID) {
	m.reply_to_id = &u
}

// ReplyToID returns the value of the "reply_to_id" field in the mutation.
func (m *CommentMutation) ReplyToID() (r uuid.UUID, exists bool) {
	v := m.reply_to_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyToID returns the old "reply_to_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyToID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyToID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyToID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyToID: %w", err)
	}
	return oldValue.ReplyToID, nil
}

// ClearReplyToID clears the value of the "reply_to_id" field.
func (m *CommentMutation) ClearReplyToID() {
	m.reply_to_id = nil
	m.clearedFields[comment.FieldReplyToID] = struct{}{}
}

// ReplyToIDCleared returns if the "reply_to_id" field was cleared in this mutation.
func (m *CommentMutation) ReplyToIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyToID]
	return ok
}

// ResetReplyToID resets all changes to the "reply_to_id" field.
func (m *CommentMutation) ResetReplyToID() {
	m.reply_to_id = nil
	delete(m.clearedFields, comment.FieldReplyToID)
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, comment.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, comment.FieldGoodID)
	}
	if m.order_id != nil {
		fields = append(fields, comment.FieldOrderID)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.reply_to_id != nil {
		fields = append(fields, comment.FieldReplyToID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldDeletedAt:
		return m.DeletedAt()
	case comment.FieldAppID:
		return m.AppID()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldGoodID:
		return m.GoodID()
	case comment.FieldOrderID:
		return m.OrderID()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldReplyToID:
		return m.ReplyToID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case comment.FieldAppID:
		return m.OldAppID(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldGoodID:
		return m.OldGoodID(ctx)
	case comment.FieldOrderID:
		return m.OldOrderID(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldReplyToID:
		return m.OldReplyToID(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case comment.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case comment.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldReplyToID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyToID(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.AddedCreatedAt()
	case comment.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case comment.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldContent) {
		fields = append(fields, comment.FieldContent)
	}
	if m.FieldCleared(comment.FieldReplyToID) {
		fields = append(fields, comment.FieldReplyToID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldContent:
		m.ClearContent()
		return nil
	case comment.FieldReplyToID:
		m.ClearReplyToID()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case comment.FieldAppID:
		m.ResetAppID()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldGoodID:
		m.ResetGoodID()
		return nil
	case comment.FieldOrderID:
		m.ResetOrderID()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldReplyToID:
		m.ResetReplyToID()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Comment edge %s", name)
}

// DeviceInfoMutation represents an operation that mutates the DeviceInfo nodes in the graph.
type DeviceInfoMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *uint32
	addcreated_at       *int32
	updated_at          *uint32
	addupdated_at       *int32
	deleted_at          *uint32
	adddeleted_at       *int32
	_type               *string
	manufacturer        *string
	power_comsuption    *uint32
	addpower_comsuption *int32
	shipment_at         *uint32
	addshipment_at      *int32
	posters             *[]string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*DeviceInfo, error)
	predicates          []predicate.DeviceInfo
}

var _ ent.Mutation = (*DeviceInfoMutation)(nil)

// deviceinfoOption allows management of the mutation configuration using functional options.
type deviceinfoOption func(*DeviceInfoMutation)

// newDeviceInfoMutation creates new mutation for the DeviceInfo entity.
func newDeviceInfoMutation(c config, op Op, opts ...deviceinfoOption) *DeviceInfoMutation {
	m := &DeviceInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInfoID sets the ID field of the mutation.
func withDeviceInfoID(id uuid.UUID) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInfo
		)
		m.oldValue = func(ctx context.Context) (*DeviceInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInfo sets the old DeviceInfo of the mutation.
func withDeviceInfo(node *DeviceInfo) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		m.oldValue = func(context.Context) (*DeviceInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceInfo entities.
func (m *DeviceInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceInfoMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceInfoMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *DeviceInfoMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *DeviceInfoMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceInfoMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceInfoMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *DeviceInfoMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *DeviceInfoMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceInfoMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceInfoMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *DeviceInfoMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DeviceInfoMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetType sets the "type" field.
func (m *DeviceInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *DeviceInfoMutation) ClearType() {
	m._type = nil
	m.clearedFields[deviceinfo.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *DeviceInfoMutation) TypeCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *DeviceInfoMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, deviceinfo.FieldType)
}

// SetManufacturer sets the "manufacturer" field.
func (m *DeviceInfoMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *DeviceInfoMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *DeviceInfoMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[deviceinfo.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *DeviceInfoMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *DeviceInfoMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, deviceinfo.FieldManufacturer)
}

// SetPowerComsuption sets the "power_comsuption" field.
func (m *DeviceInfoMutation) SetPowerComsuption(u uint32) {
	m.power_comsuption = &u
	m.addpower_comsuption = nil
}

// PowerComsuption returns the value of the "power_comsuption" field in the mutation.
func (m *DeviceInfoMutation) PowerComsuption() (r uint32, exists bool) {
	v := m.power_comsuption
	if v == nil {
		return
	}
	return *v, true
}

// OldPowerComsuption returns the old "power_comsuption" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldPowerComsuption(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPowerComsuption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPowerComsuption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPowerComsuption: %w", err)
	}
	return oldValue.PowerComsuption, nil
}

// AddPowerComsuption adds u to the "power_comsuption" field.
func (m *DeviceInfoMutation) AddPowerComsuption(u int32) {
	if m.addpower_comsuption != nil {
		*m.addpower_comsuption += u
	} else {
		m.addpower_comsuption = &u
	}
}

// AddedPowerComsuption returns the value that was added to the "power_comsuption" field in this mutation.
func (m *DeviceInfoMutation) AddedPowerComsuption() (r int32, exists bool) {
	v := m.addpower_comsuption
	if v == nil {
		return
	}
	return *v, true
}

// ClearPowerComsuption clears the value of the "power_comsuption" field.
func (m *DeviceInfoMutation) ClearPowerComsuption() {
	m.power_comsuption = nil
	m.addpower_comsuption = nil
	m.clearedFields[deviceinfo.FieldPowerComsuption] = struct{}{}
}

// PowerComsuptionCleared returns if the "power_comsuption" field was cleared in this mutation.
func (m *DeviceInfoMutation) PowerComsuptionCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldPowerComsuption]
	return ok
}

// ResetPowerComsuption resets all changes to the "power_comsuption" field.
func (m *DeviceInfoMutation) ResetPowerComsuption() {
	m.power_comsuption = nil
	m.addpower_comsuption = nil
	delete(m.clearedFields, deviceinfo.FieldPowerComsuption)
}

// SetShipmentAt sets the "shipment_at" field.
func (m *DeviceInfoMutation) SetShipmentAt(u uint32) {
	m.shipment_at = &u
	m.addshipment_at = nil
}

// ShipmentAt returns the value of the "shipment_at" field in the mutation.
func (m *DeviceInfoMutation) ShipmentAt() (r uint32, exists bool) {
	v := m.shipment_at
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentAt returns the old "shipment_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldShipmentAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentAt: %w", err)
	}
	return oldValue.ShipmentAt, nil
}

// AddShipmentAt adds u to the "shipment_at" field.
func (m *DeviceInfoMutation) AddShipmentAt(u int32) {
	if m.addshipment_at != nil {
		*m.addshipment_at += u
	} else {
		m.addshipment_at = &u
	}
}

// AddedShipmentAt returns the value that was added to the "shipment_at" field in this mutation.
func (m *DeviceInfoMutation) AddedShipmentAt() (r int32, exists bool) {
	v := m.addshipment_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipmentAt clears the value of the "shipment_at" field.
func (m *DeviceInfoMutation) ClearShipmentAt() {
	m.shipment_at = nil
	m.addshipment_at = nil
	m.clearedFields[deviceinfo.FieldShipmentAt] = struct{}{}
}

// ShipmentAtCleared returns if the "shipment_at" field was cleared in this mutation.
func (m *DeviceInfoMutation) ShipmentAtCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldShipmentAt]
	return ok
}

// ResetShipmentAt resets all changes to the "shipment_at" field.
func (m *DeviceInfoMutation) ResetShipmentAt() {
	m.shipment_at = nil
	m.addshipment_at = nil
	delete(m.clearedFields, deviceinfo.FieldShipmentAt)
}

// SetPosters sets the "posters" field.
func (m *DeviceInfoMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *DeviceInfoMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *DeviceInfoMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[deviceinfo.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *DeviceInfoMutation) PostersCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *DeviceInfoMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, deviceinfo.FieldPosters)
}

// Where appends a list predicates to the DeviceInfoMutation builder.
func (m *DeviceInfoMutation) Where(ps ...predicate.DeviceInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeviceInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeviceInfo).
func (m *DeviceInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInfoMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, deviceinfo.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.manufacturer != nil {
		fields = append(fields, deviceinfo.FieldManufacturer)
	}
	if m.power_comsuption != nil {
		fields = append(fields, deviceinfo.FieldPowerComsuption)
	}
	if m.shipment_at != nil {
		fields = append(fields, deviceinfo.FieldShipmentAt)
	}
	if m.posters != nil {
		fields = append(fields, deviceinfo.FieldPosters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldCreatedAt:
		return m.CreatedAt()
	case deviceinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceinfo.FieldDeletedAt:
		return m.DeletedAt()
	case deviceinfo.FieldType:
		return m.GetType()
	case deviceinfo.FieldManufacturer:
		return m.Manufacturer()
	case deviceinfo.FieldPowerComsuption:
		return m.PowerComsuption()
	case deviceinfo.FieldShipmentAt:
		return m.ShipmentAt()
	case deviceinfo.FieldPosters:
		return m.Posters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case deviceinfo.FieldType:
		return m.OldType(ctx)
	case deviceinfo.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case deviceinfo.FieldPowerComsuption:
		return m.OldPowerComsuption(ctx)
	case deviceinfo.FieldShipmentAt:
		return m.OldShipmentAt(ctx)
	case deviceinfo.FieldPosters:
		return m.OldPosters(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceinfo.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case deviceinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case deviceinfo.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case deviceinfo.FieldPowerComsuption:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPowerComsuption(v)
		return nil
	case deviceinfo.FieldShipmentAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentAt(v)
		return nil
	case deviceinfo.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, deviceinfo.FieldDeletedAt)
	}
	if m.addpower_comsuption != nil {
		fields = append(fields, deviceinfo.FieldPowerComsuption)
	}
	if m.addshipment_at != nil {
		fields = append(fields, deviceinfo.FieldShipmentAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case deviceinfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case deviceinfo.FieldDeletedAt:
		return m.AddedDeletedAt()
	case deviceinfo.FieldPowerComsuption:
		return m.AddedPowerComsuption()
	case deviceinfo.FieldShipmentAt:
		return m.AddedShipmentAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case deviceinfo.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case deviceinfo.FieldPowerComsuption:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPowerComsuption(v)
		return nil
	case deviceinfo.FieldShipmentAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipmentAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceinfo.FieldType) {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.FieldCleared(deviceinfo.FieldManufacturer) {
		fields = append(fields, deviceinfo.FieldManufacturer)
	}
	if m.FieldCleared(deviceinfo.FieldPowerComsuption) {
		fields = append(fields, deviceinfo.FieldPowerComsuption)
	}
	if m.FieldCleared(deviceinfo.FieldShipmentAt) {
		fields = append(fields, deviceinfo.FieldShipmentAt)
	}
	if m.FieldCleared(deviceinfo.FieldPosters) {
		fields = append(fields, deviceinfo.FieldPosters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ClearField(name string) error {
	switch name {
	case deviceinfo.FieldType:
		m.ClearType()
		return nil
	case deviceinfo.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case deviceinfo.FieldPowerComsuption:
		m.ClearPowerComsuption()
		return nil
	case deviceinfo.FieldShipmentAt:
		m.ClearShipmentAt()
		return nil
	case deviceinfo.FieldPosters:
		m.ClearPosters()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ResetField(name string) error {
	switch name {
	case deviceinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case deviceinfo.FieldType:
		m.ResetType()
		return nil
	case deviceinfo.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case deviceinfo.FieldPowerComsuption:
		m.ResetPowerComsuption()
		return nil
	case deviceinfo.FieldShipmentAt:
		m.ResetShipmentAt()
		return nil
	case deviceinfo.FieldPosters:
		m.ResetPosters()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeviceInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeviceInfo edge %s", name)
}

// ExtraInfoMutation represents an operation that mutates the ExtraInfo nodes in the graph.
type ExtraInfoMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	good_id       *uuid.UUID
	posters       *[]string
	labels        *[]string
	vote_count    *uint32
	addvote_count *int32
	rating_v1     *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ExtraInfo, error)
	predicates    []predicate.ExtraInfo
}

var _ ent.Mutation = (*ExtraInfoMutation)(nil)

// extrainfoOption allows management of the mutation configuration using functional options.
type extrainfoOption func(*ExtraInfoMutation)

// newExtraInfoMutation creates new mutation for the ExtraInfo entity.
func newExtraInfoMutation(c config, op Op, opts ...extrainfoOption) *ExtraInfoMutation {
	m := &ExtraInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeExtraInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtraInfoID sets the ID field of the mutation.
func withExtraInfoID(id uuid.UUID) extrainfoOption {
	return func(m *ExtraInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ExtraInfo
		)
		m.oldValue = func(ctx context.Context) (*ExtraInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExtraInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtraInfo sets the old ExtraInfo of the mutation.
func withExtraInfo(node *ExtraInfo) extrainfoOption {
	return func(m *ExtraInfoMutation) {
		m.oldValue = func(context.Context) (*ExtraInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtraInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtraInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExtraInfo entities.
func (m *ExtraInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtraInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtraInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExtraInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExtraInfoMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExtraInfoMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ExtraInfoMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ExtraInfoMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExtraInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExtraInfoMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExtraInfoMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ExtraInfoMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ExtraInfoMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExtraInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExtraInfoMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExtraInfoMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ExtraInfoMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ExtraInfoMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExtraInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *ExtraInfoMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *ExtraInfoMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *ExtraInfoMutation) ResetGoodID() {
	m.good_id = nil
}

// SetPosters sets the "posters" field.
func (m *ExtraInfoMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *ExtraInfoMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *ExtraInfoMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[extrainfo.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *ExtraInfoMutation) PostersCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *ExtraInfoMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, extrainfo.FieldPosters)
}

// SetLabels sets the "labels" field.
func (m *ExtraInfoMutation) SetLabels(s []string) {
	m.labels = &s
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ExtraInfoMutation) Labels() (r []string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldLabels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ExtraInfoMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[extrainfo.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ExtraInfoMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ExtraInfoMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, extrainfo.FieldLabels)
}

// SetVoteCount sets the "vote_count" field.
func (m *ExtraInfoMutation) SetVoteCount(u uint32) {
	m.vote_count = &u
	m.addvote_count = nil
}

// VoteCount returns the value of the "vote_count" field in the mutation.
func (m *ExtraInfoMutation) VoteCount() (r uint32, exists bool) {
	v := m.vote_count
	if v == nil {
		return
	}
	return *v, true
}

// OldVoteCount returns the old "vote_count" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldVoteCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoteCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoteCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoteCount: %w", err)
	}
	return oldValue.VoteCount, nil
}

// AddVoteCount adds u to the "vote_count" field.
func (m *ExtraInfoMutation) AddVoteCount(u int32) {
	if m.addvote_count != nil {
		*m.addvote_count += u
	} else {
		m.addvote_count = &u
	}
}

// AddedVoteCount returns the value that was added to the "vote_count" field in this mutation.
func (m *ExtraInfoMutation) AddedVoteCount() (r int32, exists bool) {
	v := m.addvote_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearVoteCount clears the value of the "vote_count" field.
func (m *ExtraInfoMutation) ClearVoteCount() {
	m.vote_count = nil
	m.addvote_count = nil
	m.clearedFields[extrainfo.FieldVoteCount] = struct{}{}
}

// VoteCountCleared returns if the "vote_count" field was cleared in this mutation.
func (m *ExtraInfoMutation) VoteCountCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldVoteCount]
	return ok
}

// ResetVoteCount resets all changes to the "vote_count" field.
func (m *ExtraInfoMutation) ResetVoteCount() {
	m.vote_count = nil
	m.addvote_count = nil
	delete(m.clearedFields, extrainfo.FieldVoteCount)
}

// SetRatingV1 sets the "rating_v1" field.
func (m *ExtraInfoMutation) SetRatingV1(d decimal.Decimal) {
	m.rating_v1 = &d
}

// RatingV1 returns the value of the "rating_v1" field in the mutation.
func (m *ExtraInfoMutation) RatingV1() (r decimal.Decimal, exists bool) {
	v := m.rating_v1
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingV1 returns the old "rating_v1" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldRatingV1(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingV1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingV1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingV1: %w", err)
	}
	return oldValue.RatingV1, nil
}

// ClearRatingV1 clears the value of the "rating_v1" field.
func (m *ExtraInfoMutation) ClearRatingV1() {
	m.rating_v1 = nil
	m.clearedFields[extrainfo.FieldRatingV1] = struct{}{}
}

// RatingV1Cleared returns if the "rating_v1" field was cleared in this mutation.
func (m *ExtraInfoMutation) RatingV1Cleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldRatingV1]
	return ok
}

// ResetRatingV1 resets all changes to the "rating_v1" field.
func (m *ExtraInfoMutation) ResetRatingV1() {
	m.rating_v1 = nil
	delete(m.clearedFields, extrainfo.FieldRatingV1)
}

// Where appends a list predicates to the ExtraInfoMutation builder.
func (m *ExtraInfoMutation) Where(ps ...predicate.ExtraInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ExtraInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ExtraInfo).
func (m *ExtraInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtraInfoMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, extrainfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, extrainfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, extrainfo.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, extrainfo.FieldGoodID)
	}
	if m.posters != nil {
		fields = append(fields, extrainfo.FieldPosters)
	}
	if m.labels != nil {
		fields = append(fields, extrainfo.FieldLabels)
	}
	if m.vote_count != nil {
		fields = append(fields, extrainfo.FieldVoteCount)
	}
	if m.rating_v1 != nil {
		fields = append(fields, extrainfo.FieldRatingV1)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtraInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extrainfo.FieldCreatedAt:
		return m.CreatedAt()
	case extrainfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case extrainfo.FieldDeletedAt:
		return m.DeletedAt()
	case extrainfo.FieldGoodID:
		return m.GoodID()
	case extrainfo.FieldPosters:
		return m.Posters()
	case extrainfo.FieldLabels:
		return m.Labels()
	case extrainfo.FieldVoteCount:
		return m.VoteCount()
	case extrainfo.FieldRatingV1:
		return m.RatingV1()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtraInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extrainfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case extrainfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case extrainfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case extrainfo.FieldGoodID:
		return m.OldGoodID(ctx)
	case extrainfo.FieldPosters:
		return m.OldPosters(ctx)
	case extrainfo.FieldLabels:
		return m.OldLabels(ctx)
	case extrainfo.FieldVoteCount:
		return m.OldVoteCount(ctx)
	case extrainfo.FieldRatingV1:
		return m.OldRatingV1(ctx)
	}
	return nil, fmt.Errorf("unknown ExtraInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extrainfo.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case extrainfo.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case extrainfo.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case extrainfo.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case extrainfo.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	case extrainfo.FieldLabels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case extrainfo.FieldVoteCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoteCount(v)
		return nil
	case extrainfo.FieldRatingV1:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingV1(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtraInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, extrainfo.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, extrainfo.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, extrainfo.FieldDeletedAt)
	}
	if m.addvote_count != nil {
		fields = append(fields, extrainfo.FieldVoteCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtraInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case extrainfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case extrainfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case extrainfo.FieldDeletedAt:
		return m.AddedDeletedAt()
	case extrainfo.FieldVoteCount:
		return m.AddedVoteCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case extrainfo.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case extrainfo.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case extrainfo.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case extrainfo.FieldVoteCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoteCount(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtraInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extrainfo.FieldPosters) {
		fields = append(fields, extrainfo.FieldPosters)
	}
	if m.FieldCleared(extrainfo.FieldLabels) {
		fields = append(fields, extrainfo.FieldLabels)
	}
	if m.FieldCleared(extrainfo.FieldVoteCount) {
		fields = append(fields, extrainfo.FieldVoteCount)
	}
	if m.FieldCleared(extrainfo.FieldRatingV1) {
		fields = append(fields, extrainfo.FieldRatingV1)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtraInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtraInfoMutation) ClearField(name string) error {
	switch name {
	case extrainfo.FieldPosters:
		m.ClearPosters()
		return nil
	case extrainfo.FieldLabels:
		m.ClearLabels()
		return nil
	case extrainfo.FieldVoteCount:
		m.ClearVoteCount()
		return nil
	case extrainfo.FieldRatingV1:
		m.ClearRatingV1()
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtraInfoMutation) ResetField(name string) error {
	switch name {
	case extrainfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case extrainfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case extrainfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case extrainfo.FieldGoodID:
		m.ResetGoodID()
		return nil
	case extrainfo.FieldPosters:
		m.ResetPosters()
		return nil
	case extrainfo.FieldLabels:
		m.ResetLabels()
		return nil
	case extrainfo.FieldVoteCount:
		m.ResetVoteCount()
		return nil
	case extrainfo.FieldRatingV1:
		m.ResetRatingV1()
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtraInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtraInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtraInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtraInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtraInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtraInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtraInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExtraInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtraInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExtraInfo edge %s", name)
}

// GoodMutation represents an operation that mutates the Good nodes in the graph.
type GoodMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *uint32
	addcreated_at             *int32
	updated_at                *uint32
	addupdated_at             *int32
	deleted_at                *uint32
	adddeleted_at             *int32
	device_info_id            *uuid.UUID
	duration_days             *int32
	addduration_days          *int32
	coin_type_id              *uuid.UUID
	inherit_from_good_id      *uuid.UUID
	vendor_location_id        *uuid.UUID
	price                     *decimal.Decimal
	benefit_type              *string
	good_type                 *string
	title                     *string
	unit                      *string
	unit_amount               *int32
	addunit_amount            *int32
	support_coin_type_ids     *[]uuid.UUID
	delivery_at               *uint32
	adddelivery_at            *int32
	start_at                  *uint32
	addstart_at               *int32
	test_only                 *bool
	benefit_interval_hours    *uint32
	addbenefit_interval_hours *int32
	unit_lock_deposit         *decimal.Decimal
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Good, error)
	predicates                []predicate.Good
}

var _ ent.Mutation = (*GoodMutation)(nil)

// goodOption allows management of the mutation configuration using functional options.
type goodOption func(*GoodMutation)

// newGoodMutation creates new mutation for the Good entity.
func newGoodMutation(c config, op Op, opts ...goodOption) *GoodMutation {
	m := &GoodMutation{
		config:        c,
		op:            op,
		typ:           TypeGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodID sets the ID field of the mutation.
func withGoodID(id uuid.UUID) goodOption {
	return func(m *GoodMutation) {
		var (
			err   error
			once  sync.Once
			value *Good
		)
		m.oldValue = func(ctx context.Context) (*Good, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Good.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGood sets the old Good of the mutation.
func withGood(node *Good) goodOption {
	return func(m *GoodMutation) {
		m.oldValue = func(context.Context) (*Good, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Good entities.
func (m *GoodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Good.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *GoodMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info_id = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *GoodMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *GoodMutation) ResetDeviceInfoID() {
	m.device_info_id = nil
}

// SetDurationDays sets the "duration_days" field.
func (m *GoodMutation) SetDurationDays(i int32) {
	m.duration_days = &i
	m.addduration_days = nil
}

// DurationDays returns the value of the "duration_days" field in the mutation.
func (m *GoodMutation) DurationDays() (r int32, exists bool) {
	v := m.duration_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDays returns the old "duration_days" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDurationDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDays: %w", err)
	}
	return oldValue.DurationDays, nil
}

// AddDurationDays adds i to the "duration_days" field.
func (m *GoodMutation) AddDurationDays(i int32) {
	if m.addduration_days != nil {
		*m.addduration_days += i
	} else {
		m.addduration_days = &i
	}
}

// AddedDurationDays returns the value that was added to the "duration_days" field in this mutation.
func (m *GoodMutation) AddedDurationDays() (r int32, exists bool) {
	v := m.addduration_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationDays clears the value of the "duration_days" field.
func (m *GoodMutation) ClearDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	m.clearedFields[good.FieldDurationDays] = struct{}{}
}

// DurationDaysCleared returns if the "duration_days" field was cleared in this mutation.
func (m *GoodMutation) DurationDaysCleared() bool {
	_, ok := m.clearedFields[good.FieldDurationDays]
	return ok
}

// ResetDurationDays resets all changes to the "duration_days" field.
func (m *GoodMutation) ResetDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	delete(m.clearedFields, good.FieldDurationDays)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *GoodMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *GoodMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *GoodMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
}

// SetInheritFromGoodID sets the "inherit_from_good_id" field.
func (m *GoodMutation) SetInheritFromGoodID(u uuid.UUID) {
	m.inherit_from_good_id = &u
}

// InheritFromGoodID returns the value of the "inherit_from_good_id" field in the mutation.
func (m *GoodMutation) InheritFromGoodID() (r uuid.UUID, exists bool) {
	v := m.inherit_from_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritFromGoodID returns the old "inherit_from_good_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldInheritFromGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritFromGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritFromGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritFromGoodID: %w", err)
	}
	return oldValue.InheritFromGoodID, nil
}

// ClearInheritFromGoodID clears the value of the "inherit_from_good_id" field.
func (m *GoodMutation) ClearInheritFromGoodID() {
	m.inherit_from_good_id = nil
	m.clearedFields[good.FieldInheritFromGoodID] = struct{}{}
}

// InheritFromGoodIDCleared returns if the "inherit_from_good_id" field was cleared in this mutation.
func (m *GoodMutation) InheritFromGoodIDCleared() bool {
	_, ok := m.clearedFields[good.FieldInheritFromGoodID]
	return ok
}

// ResetInheritFromGoodID resets all changes to the "inherit_from_good_id" field.
func (m *GoodMutation) ResetInheritFromGoodID() {
	m.inherit_from_good_id = nil
	delete(m.clearedFields, good.FieldInheritFromGoodID)
}

// SetVendorLocationID sets the "vendor_location_id" field.
func (m *GoodMutation) SetVendorLocationID(u uuid.UUID) {
	m.vendor_location_id = &u
}

// VendorLocationID returns the value of the "vendor_location_id" field in the mutation.
func (m *GoodMutation) VendorLocationID() (r uuid.UUID, exists bool) {
	v := m.vendor_location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorLocationID returns the old "vendor_location_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldVendorLocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorLocationID: %w", err)
	}
	return oldValue.VendorLocationID, nil
}

// ResetVendorLocationID resets all changes to the "vendor_location_id" field.
func (m *GoodMutation) ResetVendorLocationID() {
	m.vendor_location_id = nil
}

// SetPrice sets the "price" field.
func (m *GoodMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *GoodMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *GoodMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[good.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *GoodMutation) PriceCleared() bool {
	_, ok := m.clearedFields[good.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *GoodMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, good.FieldPrice)
}

// SetBenefitType sets the "benefit_type" field.
func (m *GoodMutation) SetBenefitType(s string) {
	m.benefit_type = &s
}

// BenefitType returns the value of the "benefit_type" field in the mutation.
func (m *GoodMutation) BenefitType() (r string, exists bool) {
	v := m.benefit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitType returns the old "benefit_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldBenefitType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitType: %w", err)
	}
	return oldValue.BenefitType, nil
}

// ClearBenefitType clears the value of the "benefit_type" field.
func (m *GoodMutation) ClearBenefitType() {
	m.benefit_type = nil
	m.clearedFields[good.FieldBenefitType] = struct{}{}
}

// BenefitTypeCleared returns if the "benefit_type" field was cleared in this mutation.
func (m *GoodMutation) BenefitTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldBenefitType]
	return ok
}

// ResetBenefitType resets all changes to the "benefit_type" field.
func (m *GoodMutation) ResetBenefitType() {
	m.benefit_type = nil
	delete(m.clearedFields, good.FieldBenefitType)
}

// SetGoodType sets the "good_type" field.
func (m *GoodMutation) SetGoodType(s string) {
	m.good_type = &s
}

// GoodType returns the value of the "good_type" field in the mutation.
func (m *GoodMutation) GoodType() (r string, exists bool) {
	v := m.good_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodType returns the old "good_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldGoodType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodType: %w", err)
	}
	return oldValue.GoodType, nil
}

// ClearGoodType clears the value of the "good_type" field.
func (m *GoodMutation) ClearGoodType() {
	m.good_type = nil
	m.clearedFields[good.FieldGoodType] = struct{}{}
}

// GoodTypeCleared returns if the "good_type" field was cleared in this mutation.
func (m *GoodMutation) GoodTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldGoodType]
	return ok
}

// ResetGoodType resets all changes to the "good_type" field.
func (m *GoodMutation) ResetGoodType() {
	m.good_type = nil
	delete(m.clearedFields, good.FieldGoodType)
}

// SetTitle sets the "title" field.
func (m *GoodMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GoodMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *GoodMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[good.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *GoodMutation) TitleCleared() bool {
	_, ok := m.clearedFields[good.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *GoodMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, good.FieldTitle)
}

// SetUnit sets the "unit" field.
func (m *GoodMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *GoodMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *GoodMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[good.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *GoodMutation) UnitCleared() bool {
	_, ok := m.clearedFields[good.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *GoodMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, good.FieldUnit)
}

// SetUnitAmount sets the "unit_amount" field.
func (m *GoodMutation) SetUnitAmount(i int32) {
	m.unit_amount = &i
	m.addunit_amount = nil
}

// UnitAmount returns the value of the "unit_amount" field in the mutation.
func (m *GoodMutation) UnitAmount() (r int32, exists bool) {
	v := m.unit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitAmount returns the old "unit_amount" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnitAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitAmount: %w", err)
	}
	return oldValue.UnitAmount, nil
}

// AddUnitAmount adds i to the "unit_amount" field.
func (m *GoodMutation) AddUnitAmount(i int32) {
	if m.addunit_amount != nil {
		*m.addunit_amount += i
	} else {
		m.addunit_amount = &i
	}
}

// AddedUnitAmount returns the value that was added to the "unit_amount" field in this mutation.
func (m *GoodMutation) AddedUnitAmount() (r int32, exists bool) {
	v := m.addunit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitAmount clears the value of the "unit_amount" field.
func (m *GoodMutation) ClearUnitAmount() {
	m.unit_amount = nil
	m.addunit_amount = nil
	m.clearedFields[good.FieldUnitAmount] = struct{}{}
}

// UnitAmountCleared returns if the "unit_amount" field was cleared in this mutation.
func (m *GoodMutation) UnitAmountCleared() bool {
	_, ok := m.clearedFields[good.FieldUnitAmount]
	return ok
}

// ResetUnitAmount resets all changes to the "unit_amount" field.
func (m *GoodMutation) ResetUnitAmount() {
	m.unit_amount = nil
	m.addunit_amount = nil
	delete(m.clearedFields, good.FieldUnitAmount)
}

// SetSupportCoinTypeIds sets the "support_coin_type_ids" field.
func (m *GoodMutation) SetSupportCoinTypeIds(u []uuid.UUID) {
	m.support_coin_type_ids = &u
}

// SupportCoinTypeIds returns the value of the "support_coin_type_ids" field in the mutation.
func (m *GoodMutation) SupportCoinTypeIds() (r []uuid.UUID, exists bool) {
	v := m.support_coin_type_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportCoinTypeIds returns the old "support_coin_type_ids" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldSupportCoinTypeIds(ctx context.Context) (v []uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportCoinTypeIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportCoinTypeIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportCoinTypeIds: %w", err)
	}
	return oldValue.SupportCoinTypeIds, nil
}

// ClearSupportCoinTypeIds clears the value of the "support_coin_type_ids" field.
func (m *GoodMutation) ClearSupportCoinTypeIds() {
	m.support_coin_type_ids = nil
	m.clearedFields[good.FieldSupportCoinTypeIds] = struct{}{}
}

// SupportCoinTypeIdsCleared returns if the "support_coin_type_ids" field was cleared in this mutation.
func (m *GoodMutation) SupportCoinTypeIdsCleared() bool {
	_, ok := m.clearedFields[good.FieldSupportCoinTypeIds]
	return ok
}

// ResetSupportCoinTypeIds resets all changes to the "support_coin_type_ids" field.
func (m *GoodMutation) ResetSupportCoinTypeIds() {
	m.support_coin_type_ids = nil
	delete(m.clearedFields, good.FieldSupportCoinTypeIds)
}

// SetDeliveryAt sets the "delivery_at" field.
func (m *GoodMutation) SetDeliveryAt(u uint32) {
	m.delivery_at = &u
	m.adddelivery_at = nil
}

// DeliveryAt returns the value of the "delivery_at" field in the mutation.
func (m *GoodMutation) DeliveryAt() (r uint32, exists bool) {
	v := m.delivery_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryAt returns the old "delivery_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDeliveryAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryAt: %w", err)
	}
	return oldValue.DeliveryAt, nil
}

// AddDeliveryAt adds u to the "delivery_at" field.
func (m *GoodMutation) AddDeliveryAt(u int32) {
	if m.adddelivery_at != nil {
		*m.adddelivery_at += u
	} else {
		m.adddelivery_at = &u
	}
}

// AddedDeliveryAt returns the value that was added to the "delivery_at" field in this mutation.
func (m *GoodMutation) AddedDeliveryAt() (r int32, exists bool) {
	v := m.adddelivery_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryAt clears the value of the "delivery_at" field.
func (m *GoodMutation) ClearDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	m.clearedFields[good.FieldDeliveryAt] = struct{}{}
}

// DeliveryAtCleared returns if the "delivery_at" field was cleared in this mutation.
func (m *GoodMutation) DeliveryAtCleared() bool {
	_, ok := m.clearedFields[good.FieldDeliveryAt]
	return ok
}

// ResetDeliveryAt resets all changes to the "delivery_at" field.
func (m *GoodMutation) ResetDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	delete(m.clearedFields, good.FieldDeliveryAt)
}

// SetStartAt sets the "start_at" field.
func (m *GoodMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *GoodMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *GoodMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *GoodMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *GoodMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[good.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *GoodMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[good.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *GoodMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, good.FieldStartAt)
}

// SetTestOnly sets the "test_only" field.
func (m *GoodMutation) SetTestOnly(b bool) {
	m.test_only = &b
}

// TestOnly returns the value of the "test_only" field in the mutation.
func (m *GoodMutation) TestOnly() (r bool, exists bool) {
	v := m.test_only
	if v == nil {
		return
	}
	return *v, true
}

// OldTestOnly returns the old "test_only" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldTestOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestOnly: %w", err)
	}
	return oldValue.TestOnly, nil
}

// ClearTestOnly clears the value of the "test_only" field.
func (m *GoodMutation) ClearTestOnly() {
	m.test_only = nil
	m.clearedFields[good.FieldTestOnly] = struct{}{}
}

// TestOnlyCleared returns if the "test_only" field was cleared in this mutation.
func (m *GoodMutation) TestOnlyCleared() bool {
	_, ok := m.clearedFields[good.FieldTestOnly]
	return ok
}

// ResetTestOnly resets all changes to the "test_only" field.
func (m *GoodMutation) ResetTestOnly() {
	m.test_only = nil
	delete(m.clearedFields, good.FieldTestOnly)
}

// SetBenefitIntervalHours sets the "benefit_interval_hours" field.
func (m *GoodMutation) SetBenefitIntervalHours(u uint32) {
	m.benefit_interval_hours = &u
	m.addbenefit_interval_hours = nil
}

// BenefitIntervalHours returns the value of the "benefit_interval_hours" field in the mutation.
func (m *GoodMutation) BenefitIntervalHours() (r uint32, exists bool) {
	v := m.benefit_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitIntervalHours returns the old "benefit_interval_hours" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldBenefitIntervalHours(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitIntervalHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitIntervalHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitIntervalHours: %w", err)
	}
	return oldValue.BenefitIntervalHours, nil
}

// AddBenefitIntervalHours adds u to the "benefit_interval_hours" field.
func (m *GoodMutation) AddBenefitIntervalHours(u int32) {
	if m.addbenefit_interval_hours != nil {
		*m.addbenefit_interval_hours += u
	} else {
		m.addbenefit_interval_hours = &u
	}
}

// AddedBenefitIntervalHours returns the value that was added to the "benefit_interval_hours" field in this mutation.
func (m *GoodMutation) AddedBenefitIntervalHours() (r int32, exists bool) {
	v := m.addbenefit_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearBenefitIntervalHours clears the value of the "benefit_interval_hours" field.
func (m *GoodMutation) ClearBenefitIntervalHours() {
	m.benefit_interval_hours = nil
	m.addbenefit_interval_hours = nil
	m.clearedFields[good.FieldBenefitIntervalHours] = struct{}{}
}

// BenefitIntervalHoursCleared returns if the "benefit_interval_hours" field was cleared in this mutation.
func (m *GoodMutation) BenefitIntervalHoursCleared() bool {
	_, ok := m.clearedFields[good.FieldBenefitIntervalHours]
	return ok
}

// ResetBenefitIntervalHours resets all changes to the "benefit_interval_hours" field.
func (m *GoodMutation) ResetBenefitIntervalHours() {
	m.benefit_interval_hours = nil
	m.addbenefit_interval_hours = nil
	delete(m.clearedFields, good.FieldBenefitIntervalHours)
}

// SetUnitLockDeposit sets the "unit_lock_deposit" field.
func (m *GoodMutation) SetUnitLockDeposit(d decimal.Decimal) {
	m.unit_lock_deposit = &d
}

// UnitLockDeposit returns the value of the "unit_lock_deposit" field in the mutation.
func (m *GoodMutation) UnitLockDeposit() (r decimal.Decimal, exists bool) {
	v := m.unit_lock_deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitLockDeposit returns the old "unit_lock_deposit" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnitLockDeposit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitLockDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitLockDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitLockDeposit: %w", err)
	}
	return oldValue.UnitLockDeposit, nil
}

// ClearUnitLockDeposit clears the value of the "unit_lock_deposit" field.
func (m *GoodMutation) ClearUnitLockDeposit() {
	m.unit_lock_deposit = nil
	m.clearedFields[good.FieldUnitLockDeposit] = struct{}{}
}

// UnitLockDepositCleared returns if the "unit_lock_deposit" field was cleared in this mutation.
func (m *GoodMutation) UnitLockDepositCleared() bool {
	_, ok := m.clearedFields[good.FieldUnitLockDeposit]
	return ok
}

// ResetUnitLockDeposit resets all changes to the "unit_lock_deposit" field.
func (m *GoodMutation) ResetUnitLockDeposit() {
	m.unit_lock_deposit = nil
	delete(m.clearedFields, good.FieldUnitLockDeposit)
}

// Where appends a list predicates to the GoodMutation builder.
func (m *GoodMutation) Where(ps ...predicate.Good) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Good).
func (m *GoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, good.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, good.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, good.FieldDeletedAt)
	}
	if m.device_info_id != nil {
		fields = append(fields, good.FieldDeviceInfoID)
	}
	if m.duration_days != nil {
		fields = append(fields, good.FieldDurationDays)
	}
	if m.coin_type_id != nil {
		fields = append(fields, good.FieldCoinTypeID)
	}
	if m.inherit_from_good_id != nil {
		fields = append(fields, good.FieldInheritFromGoodID)
	}
	if m.vendor_location_id != nil {
		fields = append(fields, good.FieldVendorLocationID)
	}
	if m.price != nil {
		fields = append(fields, good.FieldPrice)
	}
	if m.benefit_type != nil {
		fields = append(fields, good.FieldBenefitType)
	}
	if m.good_type != nil {
		fields = append(fields, good.FieldGoodType)
	}
	if m.title != nil {
		fields = append(fields, good.FieldTitle)
	}
	if m.unit != nil {
		fields = append(fields, good.FieldUnit)
	}
	if m.unit_amount != nil {
		fields = append(fields, good.FieldUnitAmount)
	}
	if m.support_coin_type_ids != nil {
		fields = append(fields, good.FieldSupportCoinTypeIds)
	}
	if m.delivery_at != nil {
		fields = append(fields, good.FieldDeliveryAt)
	}
	if m.start_at != nil {
		fields = append(fields, good.FieldStartAt)
	}
	if m.test_only != nil {
		fields = append(fields, good.FieldTestOnly)
	}
	if m.benefit_interval_hours != nil {
		fields = append(fields, good.FieldBenefitIntervalHours)
	}
	if m.unit_lock_deposit != nil {
		fields = append(fields, good.FieldUnitLockDeposit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case good.FieldCreatedAt:
		return m.CreatedAt()
	case good.FieldUpdatedAt:
		return m.UpdatedAt()
	case good.FieldDeletedAt:
		return m.DeletedAt()
	case good.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case good.FieldDurationDays:
		return m.DurationDays()
	case good.FieldCoinTypeID:
		return m.CoinTypeID()
	case good.FieldInheritFromGoodID:
		return m.InheritFromGoodID()
	case good.FieldVendorLocationID:
		return m.VendorLocationID()
	case good.FieldPrice:
		return m.Price()
	case good.FieldBenefitType:
		return m.BenefitType()
	case good.FieldGoodType:
		return m.GoodType()
	case good.FieldTitle:
		return m.Title()
	case good.FieldUnit:
		return m.Unit()
	case good.FieldUnitAmount:
		return m.UnitAmount()
	case good.FieldSupportCoinTypeIds:
		return m.SupportCoinTypeIds()
	case good.FieldDeliveryAt:
		return m.DeliveryAt()
	case good.FieldStartAt:
		return m.StartAt()
	case good.FieldTestOnly:
		return m.TestOnly()
	case good.FieldBenefitIntervalHours:
		return m.BenefitIntervalHours()
	case good.FieldUnitLockDeposit:
		return m.UnitLockDeposit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case good.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case good.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case good.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case good.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case good.FieldDurationDays:
		return m.OldDurationDays(ctx)
	case good.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case good.FieldInheritFromGoodID:
		return m.OldInheritFromGoodID(ctx)
	case good.FieldVendorLocationID:
		return m.OldVendorLocationID(ctx)
	case good.FieldPrice:
		return m.OldPrice(ctx)
	case good.FieldBenefitType:
		return m.OldBenefitType(ctx)
	case good.FieldGoodType:
		return m.OldGoodType(ctx)
	case good.FieldTitle:
		return m.OldTitle(ctx)
	case good.FieldUnit:
		return m.OldUnit(ctx)
	case good.FieldUnitAmount:
		return m.OldUnitAmount(ctx)
	case good.FieldSupportCoinTypeIds:
		return m.OldSupportCoinTypeIds(ctx)
	case good.FieldDeliveryAt:
		return m.OldDeliveryAt(ctx)
	case good.FieldStartAt:
		return m.OldStartAt(ctx)
	case good.FieldTestOnly:
		return m.OldTestOnly(ctx)
	case good.FieldBenefitIntervalHours:
		return m.OldBenefitIntervalHours(ctx)
	case good.FieldUnitLockDeposit:
		return m.OldUnitLockDeposit(ctx)
	}
	return nil, fmt.Errorf("unknown Good field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case good.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case good.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case good.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case good.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case good.FieldDurationDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDays(v)
		return nil
	case good.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case good.FieldInheritFromGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritFromGoodID(v)
		return nil
	case good.FieldVendorLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorLocationID(v)
		return nil
	case good.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case good.FieldBenefitType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitType(v)
		return nil
	case good.FieldGoodType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodType(v)
		return nil
	case good.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case good.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case good.FieldUnitAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitAmount(v)
		return nil
	case good.FieldSupportCoinTypeIds:
		v, ok := value.([]uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportCoinTypeIds(v)
		return nil
	case good.FieldDeliveryAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryAt(v)
		return nil
	case good.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case good.FieldTestOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestOnly(v)
		return nil
	case good.FieldBenefitIntervalHours:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitIntervalHours(v)
		return nil
	case good.FieldUnitLockDeposit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitLockDeposit(v)
		return nil
	}
	return fmt.Errorf("unknown Good field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, good.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, good.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, good.FieldDeletedAt)
	}
	if m.addduration_days != nil {
		fields = append(fields, good.FieldDurationDays)
	}
	if m.addunit_amount != nil {
		fields = append(fields, good.FieldUnitAmount)
	}
	if m.adddelivery_at != nil {
		fields = append(fields, good.FieldDeliveryAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, good.FieldStartAt)
	}
	if m.addbenefit_interval_hours != nil {
		fields = append(fields, good.FieldBenefitIntervalHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case good.FieldCreatedAt:
		return m.AddedCreatedAt()
	case good.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case good.FieldDeletedAt:
		return m.AddedDeletedAt()
	case good.FieldDurationDays:
		return m.AddedDurationDays()
	case good.FieldUnitAmount:
		return m.AddedUnitAmount()
	case good.FieldDeliveryAt:
		return m.AddedDeliveryAt()
	case good.FieldStartAt:
		return m.AddedStartAt()
	case good.FieldBenefitIntervalHours:
		return m.AddedBenefitIntervalHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case good.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case good.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case good.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case good.FieldDurationDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationDays(v)
		return nil
	case good.FieldUnitAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitAmount(v)
		return nil
	case good.FieldDeliveryAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryAt(v)
		return nil
	case good.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case good.FieldBenefitIntervalHours:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBenefitIntervalHours(v)
		return nil
	}
	return fmt.Errorf("unknown Good numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(good.FieldDurationDays) {
		fields = append(fields, good.FieldDurationDays)
	}
	if m.FieldCleared(good.FieldInheritFromGoodID) {
		fields = append(fields, good.FieldInheritFromGoodID)
	}
	if m.FieldCleared(good.FieldPrice) {
		fields = append(fields, good.FieldPrice)
	}
	if m.FieldCleared(good.FieldBenefitType) {
		fields = append(fields, good.FieldBenefitType)
	}
	if m.FieldCleared(good.FieldGoodType) {
		fields = append(fields, good.FieldGoodType)
	}
	if m.FieldCleared(good.FieldTitle) {
		fields = append(fields, good.FieldTitle)
	}
	if m.FieldCleared(good.FieldUnit) {
		fields = append(fields, good.FieldUnit)
	}
	if m.FieldCleared(good.FieldUnitAmount) {
		fields = append(fields, good.FieldUnitAmount)
	}
	if m.FieldCleared(good.FieldSupportCoinTypeIds) {
		fields = append(fields, good.FieldSupportCoinTypeIds)
	}
	if m.FieldCleared(good.FieldDeliveryAt) {
		fields = append(fields, good.FieldDeliveryAt)
	}
	if m.FieldCleared(good.FieldStartAt) {
		fields = append(fields, good.FieldStartAt)
	}
	if m.FieldCleared(good.FieldTestOnly) {
		fields = append(fields, good.FieldTestOnly)
	}
	if m.FieldCleared(good.FieldBenefitIntervalHours) {
		fields = append(fields, good.FieldBenefitIntervalHours)
	}
	if m.FieldCleared(good.FieldUnitLockDeposit) {
		fields = append(fields, good.FieldUnitLockDeposit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodMutation) ClearField(name string) error {
	switch name {
	case good.FieldDurationDays:
		m.ClearDurationDays()
		return nil
	case good.FieldInheritFromGoodID:
		m.ClearInheritFromGoodID()
		return nil
	case good.FieldPrice:
		m.ClearPrice()
		return nil
	case good.FieldBenefitType:
		m.ClearBenefitType()
		return nil
	case good.FieldGoodType:
		m.ClearGoodType()
		return nil
	case good.FieldTitle:
		m.ClearTitle()
		return nil
	case good.FieldUnit:
		m.ClearUnit()
		return nil
	case good.FieldUnitAmount:
		m.ClearUnitAmount()
		return nil
	case good.FieldSupportCoinTypeIds:
		m.ClearSupportCoinTypeIds()
		return nil
	case good.FieldDeliveryAt:
		m.ClearDeliveryAt()
		return nil
	case good.FieldStartAt:
		m.ClearStartAt()
		return nil
	case good.FieldTestOnly:
		m.ClearTestOnly()
		return nil
	case good.FieldBenefitIntervalHours:
		m.ClearBenefitIntervalHours()
		return nil
	case good.FieldUnitLockDeposit:
		m.ClearUnitLockDeposit()
		return nil
	}
	return fmt.Errorf("unknown Good nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodMutation) ResetField(name string) error {
	switch name {
	case good.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case good.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case good.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case good.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case good.FieldDurationDays:
		m.ResetDurationDays()
		return nil
	case good.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case good.FieldInheritFromGoodID:
		m.ResetInheritFromGoodID()
		return nil
	case good.FieldVendorLocationID:
		m.ResetVendorLocationID()
		return nil
	case good.FieldPrice:
		m.ResetPrice()
		return nil
	case good.FieldBenefitType:
		m.ResetBenefitType()
		return nil
	case good.FieldGoodType:
		m.ResetGoodType()
		return nil
	case good.FieldTitle:
		m.ResetTitle()
		return nil
	case good.FieldUnit:
		m.ResetUnit()
		return nil
	case good.FieldUnitAmount:
		m.ResetUnitAmount()
		return nil
	case good.FieldSupportCoinTypeIds:
		m.ResetSupportCoinTypeIds()
		return nil
	case good.FieldDeliveryAt:
		m.ResetDeliveryAt()
		return nil
	case good.FieldStartAt:
		m.ResetStartAt()
		return nil
	case good.FieldTestOnly:
		m.ResetTestOnly()
		return nil
	case good.FieldBenefitIntervalHours:
		m.ResetBenefitIntervalHours()
		return nil
	case good.FieldUnitLockDeposit:
		m.ResetUnitLockDeposit()
		return nil
	}
	return fmt.Errorf("unknown Good field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Good unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Good edge %s", name)
}

// GoodRewardMutation represents an operation that mutates the GoodReward nodes in the graph.
type GoodRewardMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *uint32
	addcreated_at            *int32
	updated_at               *uint32
	addupdated_at            *int32
	deleted_at               *uint32
	adddeleted_at            *int32
	good_id                  *uuid.UUID
	reward_state             *string
	last_reward_at           *uint32
	addlast_reward_at        *int32
	reward_tid               *uuid.UUID
	next_reward_start_amount *decimal.Decimal
	last_reward_amount       *decimal.Decimal
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*GoodReward, error)
	predicates               []predicate.GoodReward
}

var _ ent.Mutation = (*GoodRewardMutation)(nil)

// goodrewardOption allows management of the mutation configuration using functional options.
type goodrewardOption func(*GoodRewardMutation)

// newGoodRewardMutation creates new mutation for the GoodReward entity.
func newGoodRewardMutation(c config, op Op, opts ...goodrewardOption) *GoodRewardMutation {
	m := &GoodRewardMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodReward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodRewardID sets the ID field of the mutation.
func withGoodRewardID(id uuid.UUID) goodrewardOption {
	return func(m *GoodRewardMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodReward
		)
		m.oldValue = func(ctx context.Context) (*GoodReward, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodReward.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodReward sets the old GoodReward of the mutation.
func withGoodReward(node *GoodReward) goodrewardOption {
	return func(m *GoodRewardMutation) {
		m.oldValue = func(context.Context) (*GoodReward, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodRewardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodRewardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodReward entities.
func (m *GoodRewardMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodRewardMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodRewardMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodReward.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodRewardMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodRewardMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodRewardMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodRewardMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodRewardMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodRewardMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodRewardMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodRewardMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodRewardMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodRewardMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodRewardMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodRewardMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodRewardMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodRewardMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodRewardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodRewardMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodRewardMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodRewardMutation) ResetGoodID() {
	m.good_id = nil
}

// SetRewardState sets the "reward_state" field.
func (m *GoodRewardMutation) SetRewardState(s string) {
	m.reward_state = &s
}

// RewardState returns the value of the "reward_state" field in the mutation.
func (m *GoodRewardMutation) RewardState() (r string, exists bool) {
	v := m.reward_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardState returns the old "reward_state" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldRewardState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardState: %w", err)
	}
	return oldValue.RewardState, nil
}

// ClearRewardState clears the value of the "reward_state" field.
func (m *GoodRewardMutation) ClearRewardState() {
	m.reward_state = nil
	m.clearedFields[goodreward.FieldRewardState] = struct{}{}
}

// RewardStateCleared returns if the "reward_state" field was cleared in this mutation.
func (m *GoodRewardMutation) RewardStateCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldRewardState]
	return ok
}

// ResetRewardState resets all changes to the "reward_state" field.
func (m *GoodRewardMutation) ResetRewardState() {
	m.reward_state = nil
	delete(m.clearedFields, goodreward.FieldRewardState)
}

// SetLastRewardAt sets the "last_reward_at" field.
func (m *GoodRewardMutation) SetLastRewardAt(u uint32) {
	m.last_reward_at = &u
	m.addlast_reward_at = nil
}

// LastRewardAt returns the value of the "last_reward_at" field in the mutation.
func (m *GoodRewardMutation) LastRewardAt() (r uint32, exists bool) {
	v := m.last_reward_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRewardAt returns the old "last_reward_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldLastRewardAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRewardAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRewardAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRewardAt: %w", err)
	}
	return oldValue.LastRewardAt, nil
}

// AddLastRewardAt adds u to the "last_reward_at" field.
func (m *GoodRewardMutation) AddLastRewardAt(u int32) {
	if m.addlast_reward_at != nil {
		*m.addlast_reward_at += u
	} else {
		m.addlast_reward_at = &u
	}
}

// AddedLastRewardAt returns the value that was added to the "last_reward_at" field in this mutation.
func (m *GoodRewardMutation) AddedLastRewardAt() (r int32, exists bool) {
	v := m.addlast_reward_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastRewardAt clears the value of the "last_reward_at" field.
func (m *GoodRewardMutation) ClearLastRewardAt() {
	m.last_reward_at = nil
	m.addlast_reward_at = nil
	m.clearedFields[goodreward.FieldLastRewardAt] = struct{}{}
}

// LastRewardAtCleared returns if the "last_reward_at" field was cleared in this mutation.
func (m *GoodRewardMutation) LastRewardAtCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldLastRewardAt]
	return ok
}

// ResetLastRewardAt resets all changes to the "last_reward_at" field.
func (m *GoodRewardMutation) ResetLastRewardAt() {
	m.last_reward_at = nil
	m.addlast_reward_at = nil
	delete(m.clearedFields, goodreward.FieldLastRewardAt)
}

// SetRewardTid sets the "reward_tid" field.
func (m *GoodRewardMutation) SetRewardTid(u uuid.UUID) {
	m.reward_tid = &u
}

// RewardTid returns the value of the "reward_tid" field in the mutation.
func (m *GoodRewardMutation) RewardTid() (r uuid.UUID, exists bool) {
	v := m.reward_tid
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardTid returns the old "reward_tid" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldRewardTid(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardTid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardTid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardTid: %w", err)
	}
	return oldValue.RewardTid, nil
}

// ClearRewardTid clears the value of the "reward_tid" field.
func (m *GoodRewardMutation) ClearRewardTid() {
	m.reward_tid = nil
	m.clearedFields[goodreward.FieldRewardTid] = struct{}{}
}

// RewardTidCleared returns if the "reward_tid" field was cleared in this mutation.
func (m *GoodRewardMutation) RewardTidCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldRewardTid]
	return ok
}

// ResetRewardTid resets all changes to the "reward_tid" field.
func (m *GoodRewardMutation) ResetRewardTid() {
	m.reward_tid = nil
	delete(m.clearedFields, goodreward.FieldRewardTid)
}

// SetNextRewardStartAmount sets the "next_reward_start_amount" field.
func (m *GoodRewardMutation) SetNextRewardStartAmount(d decimal.Decimal) {
	m.next_reward_start_amount = &d
}

// NextRewardStartAmount returns the value of the "next_reward_start_amount" field in the mutation.
func (m *GoodRewardMutation) NextRewardStartAmount() (r decimal.Decimal, exists bool) {
	v := m.next_reward_start_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRewardStartAmount returns the old "next_reward_start_amount" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldNextRewardStartAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRewardStartAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRewardStartAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRewardStartAmount: %w", err)
	}
	return oldValue.NextRewardStartAmount, nil
}

// ClearNextRewardStartAmount clears the value of the "next_reward_start_amount" field.
func (m *GoodRewardMutation) ClearNextRewardStartAmount() {
	m.next_reward_start_amount = nil
	m.clearedFields[goodreward.FieldNextRewardStartAmount] = struct{}{}
}

// NextRewardStartAmountCleared returns if the "next_reward_start_amount" field was cleared in this mutation.
func (m *GoodRewardMutation) NextRewardStartAmountCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldNextRewardStartAmount]
	return ok
}

// ResetNextRewardStartAmount resets all changes to the "next_reward_start_amount" field.
func (m *GoodRewardMutation) ResetNextRewardStartAmount() {
	m.next_reward_start_amount = nil
	delete(m.clearedFields, goodreward.FieldNextRewardStartAmount)
}

// SetLastRewardAmount sets the "last_reward_amount" field.
func (m *GoodRewardMutation) SetLastRewardAmount(d decimal.Decimal) {
	m.last_reward_amount = &d
}

// LastRewardAmount returns the value of the "last_reward_amount" field in the mutation.
func (m *GoodRewardMutation) LastRewardAmount() (r decimal.Decimal, exists bool) {
	v := m.last_reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRewardAmount returns the old "last_reward_amount" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldLastRewardAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRewardAmount: %w", err)
	}
	return oldValue.LastRewardAmount, nil
}

// ClearLastRewardAmount clears the value of the "last_reward_amount" field.
func (m *GoodRewardMutation) ClearLastRewardAmount() {
	m.last_reward_amount = nil
	m.clearedFields[goodreward.FieldLastRewardAmount] = struct{}{}
}

// LastRewardAmountCleared returns if the "last_reward_amount" field was cleared in this mutation.
func (m *GoodRewardMutation) LastRewardAmountCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldLastRewardAmount]
	return ok
}

// ResetLastRewardAmount resets all changes to the "last_reward_amount" field.
func (m *GoodRewardMutation) ResetLastRewardAmount() {
	m.last_reward_amount = nil
	delete(m.clearedFields, goodreward.FieldLastRewardAmount)
}

// Where appends a list predicates to the GoodRewardMutation builder.
func (m *GoodRewardMutation) Where(ps ...predicate.GoodReward) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodRewardMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodReward).
func (m *GoodRewardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodRewardMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, goodreward.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodreward.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodreward.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, goodreward.FieldGoodID)
	}
	if m.reward_state != nil {
		fields = append(fields, goodreward.FieldRewardState)
	}
	if m.last_reward_at != nil {
		fields = append(fields, goodreward.FieldLastRewardAt)
	}
	if m.reward_tid != nil {
		fields = append(fields, goodreward.FieldRewardTid)
	}
	if m.next_reward_start_amount != nil {
		fields = append(fields, goodreward.FieldNextRewardStartAmount)
	}
	if m.last_reward_amount != nil {
		fields = append(fields, goodreward.FieldLastRewardAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodRewardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodreward.FieldCreatedAt:
		return m.CreatedAt()
	case goodreward.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodreward.FieldDeletedAt:
		return m.DeletedAt()
	case goodreward.FieldGoodID:
		return m.GoodID()
	case goodreward.FieldRewardState:
		return m.RewardState()
	case goodreward.FieldLastRewardAt:
		return m.LastRewardAt()
	case goodreward.FieldRewardTid:
		return m.RewardTid()
	case goodreward.FieldNextRewardStartAmount:
		return m.NextRewardStartAmount()
	case goodreward.FieldLastRewardAmount:
		return m.LastRewardAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodRewardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodreward.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodreward.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodreward.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodreward.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodreward.FieldRewardState:
		return m.OldRewardState(ctx)
	case goodreward.FieldLastRewardAt:
		return m.OldLastRewardAt(ctx)
	case goodreward.FieldRewardTid:
		return m.OldRewardTid(ctx)
	case goodreward.FieldNextRewardStartAmount:
		return m.OldNextRewardStartAmount(ctx)
	case goodreward.FieldLastRewardAmount:
		return m.OldLastRewardAmount(ctx)
	}
	return nil, fmt.Errorf("unknown GoodReward field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodreward.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodreward.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodreward.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodreward.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodreward.FieldRewardState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardState(v)
		return nil
	case goodreward.FieldLastRewardAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRewardAt(v)
		return nil
	case goodreward.FieldRewardTid:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardTid(v)
		return nil
	case goodreward.FieldNextRewardStartAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRewardStartAmount(v)
		return nil
	case goodreward.FieldLastRewardAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRewardAmount(v)
		return nil
	}
	return fmt.Errorf("unknown GoodReward field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodRewardMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodreward.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodreward.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodreward.FieldDeletedAt)
	}
	if m.addlast_reward_at != nil {
		fields = append(fields, goodreward.FieldLastRewardAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodRewardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodreward.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodreward.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodreward.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodreward.FieldLastRewardAt:
		return m.AddedLastRewardAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodreward.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodreward.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodreward.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodreward.FieldLastRewardAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastRewardAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodReward numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodRewardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodreward.FieldRewardState) {
		fields = append(fields, goodreward.FieldRewardState)
	}
	if m.FieldCleared(goodreward.FieldLastRewardAt) {
		fields = append(fields, goodreward.FieldLastRewardAt)
	}
	if m.FieldCleared(goodreward.FieldRewardTid) {
		fields = append(fields, goodreward.FieldRewardTid)
	}
	if m.FieldCleared(goodreward.FieldNextRewardStartAmount) {
		fields = append(fields, goodreward.FieldNextRewardStartAmount)
	}
	if m.FieldCleared(goodreward.FieldLastRewardAmount) {
		fields = append(fields, goodreward.FieldLastRewardAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodRewardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodRewardMutation) ClearField(name string) error {
	switch name {
	case goodreward.FieldRewardState:
		m.ClearRewardState()
		return nil
	case goodreward.FieldLastRewardAt:
		m.ClearLastRewardAt()
		return nil
	case goodreward.FieldRewardTid:
		m.ClearRewardTid()
		return nil
	case goodreward.FieldNextRewardStartAmount:
		m.ClearNextRewardStartAmount()
		return nil
	case goodreward.FieldLastRewardAmount:
		m.ClearLastRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodReward nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodRewardMutation) ResetField(name string) error {
	switch name {
	case goodreward.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodreward.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodreward.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodreward.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodreward.FieldRewardState:
		m.ResetRewardState()
		return nil
	case goodreward.FieldLastRewardAt:
		m.ResetLastRewardAt()
		return nil
	case goodreward.FieldRewardTid:
		m.ResetRewardTid()
		return nil
	case goodreward.FieldNextRewardStartAmount:
		m.ResetNextRewardStartAmount()
		return nil
	case goodreward.FieldLastRewardAmount:
		m.ResetLastRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodReward field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodRewardMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodRewardMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodRewardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodRewardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodRewardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodRewardMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodRewardMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodReward unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodRewardMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodReward edge %s", name)
}

// GoodRewardHistoryMutation represents an operation that mutates the GoodRewardHistory nodes in the graph.
type GoodRewardHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	good_id       *uuid.UUID
	reward_at     *uint32
	addreward_at  *int32
	tid           *uuid.UUID
	amount        *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GoodRewardHistory, error)
	predicates    []predicate.GoodRewardHistory
}

var _ ent.Mutation = (*GoodRewardHistoryMutation)(nil)

// goodrewardhistoryOption allows management of the mutation configuration using functional options.
type goodrewardhistoryOption func(*GoodRewardHistoryMutation)

// newGoodRewardHistoryMutation creates new mutation for the GoodRewardHistory entity.
func newGoodRewardHistoryMutation(c config, op Op, opts ...goodrewardhistoryOption) *GoodRewardHistoryMutation {
	m := &GoodRewardHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodRewardHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodRewardHistoryID sets the ID field of the mutation.
func withGoodRewardHistoryID(id uuid.UUID) goodrewardhistoryOption {
	return func(m *GoodRewardHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodRewardHistory
		)
		m.oldValue = func(ctx context.Context) (*GoodRewardHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodRewardHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodRewardHistory sets the old GoodRewardHistory of the mutation.
func withGoodRewardHistory(node *GoodRewardHistory) goodrewardhistoryOption {
	return func(m *GoodRewardHistoryMutation) {
		m.oldValue = func(context.Context) (*GoodRewardHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodRewardHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodRewardHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodRewardHistory entities.
func (m *GoodRewardHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodRewardHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodRewardHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodRewardHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodRewardHistoryMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodRewardHistoryMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodRewardHistoryMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodRewardHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodRewardHistoryMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodRewardHistoryMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodRewardHistoryMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodRewardHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodRewardHistoryMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodRewardHistoryMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodRewardHistoryMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodRewardHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodRewardHistoryMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodRewardHistoryMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodRewardHistoryMutation) ResetGoodID() {
	m.good_id = nil
}

// SetRewardAt sets the "reward_at" field.
func (m *GoodRewardHistoryMutation) SetRewardAt(u uint32) {
	m.reward_at = &u
	m.addreward_at = nil
}

// RewardAt returns the value of the "reward_at" field in the mutation.
func (m *GoodRewardHistoryMutation) RewardAt() (r uint32, exists bool) {
	v := m.reward_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardAt returns the old "reward_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldRewardAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardAt: %w", err)
	}
	return oldValue.RewardAt, nil
}

// AddRewardAt adds u to the "reward_at" field.
func (m *GoodRewardHistoryMutation) AddRewardAt(u int32) {
	if m.addreward_at != nil {
		*m.addreward_at += u
	} else {
		m.addreward_at = &u
	}
}

// AddedRewardAt returns the value that was added to the "reward_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedRewardAt() (r int32, exists bool) {
	v := m.addreward_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearRewardAt clears the value of the "reward_at" field.
func (m *GoodRewardHistoryMutation) ClearRewardAt() {
	m.reward_at = nil
	m.addreward_at = nil
	m.clearedFields[goodrewardhistory.FieldRewardAt] = struct{}{}
}

// RewardAtCleared returns if the "reward_at" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) RewardAtCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldRewardAt]
	return ok
}

// ResetRewardAt resets all changes to the "reward_at" field.
func (m *GoodRewardHistoryMutation) ResetRewardAt() {
	m.reward_at = nil
	m.addreward_at = nil
	delete(m.clearedFields, goodrewardhistory.FieldRewardAt)
}

// SetTid sets the "tid" field.
func (m *GoodRewardHistoryMutation) SetTid(u uuid.UUID) {
	m.tid = &u
}

// Tid returns the value of the "tid" field in the mutation.
func (m *GoodRewardHistoryMutation) Tid() (r uuid.UUID, exists bool) {
	v := m.tid
	if v == nil {
		return
	}
	return *v, true
}

// OldTid returns the old "tid" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldTid(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTid: %w", err)
	}
	return oldValue.Tid, nil
}

// ClearTid clears the value of the "tid" field.
func (m *GoodRewardHistoryMutation) ClearTid() {
	m.tid = nil
	m.clearedFields[goodrewardhistory.FieldTid] = struct{}{}
}

// TidCleared returns if the "tid" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) TidCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldTid]
	return ok
}

// ResetTid resets all changes to the "tid" field.
func (m *GoodRewardHistoryMutation) ResetTid() {
	m.tid = nil
	delete(m.clearedFields, goodrewardhistory.FieldTid)
}

// SetAmount sets the "amount" field.
func (m *GoodRewardHistoryMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GoodRewardHistoryMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *GoodRewardHistoryMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[goodrewardhistory.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) AmountCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *GoodRewardHistoryMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, goodrewardhistory.FieldAmount)
}

// Where appends a list predicates to the GoodRewardHistoryMutation builder.
func (m *GoodRewardHistoryMutation) Where(ps ...predicate.GoodRewardHistory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodRewardHistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodRewardHistory).
func (m *GoodRewardHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodRewardHistoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, goodrewardhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodrewardhistory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodrewardhistory.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, goodrewardhistory.FieldGoodID)
	}
	if m.reward_at != nil {
		fields = append(fields, goodrewardhistory.FieldRewardAt)
	}
	if m.tid != nil {
		fields = append(fields, goodrewardhistory.FieldTid)
	}
	if m.amount != nil {
		fields = append(fields, goodrewardhistory.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodRewardHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		return m.CreatedAt()
	case goodrewardhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodrewardhistory.FieldDeletedAt:
		return m.DeletedAt()
	case goodrewardhistory.FieldGoodID:
		return m.GoodID()
	case goodrewardhistory.FieldRewardAt:
		return m.RewardAt()
	case goodrewardhistory.FieldTid:
		return m.Tid()
	case goodrewardhistory.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodRewardHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodrewardhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodrewardhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodrewardhistory.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodrewardhistory.FieldRewardAt:
		return m.OldRewardAt(ctx)
	case goodrewardhistory.FieldTid:
		return m.OldTid(ctx)
	case goodrewardhistory.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown GoodRewardHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodrewardhistory.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodrewardhistory.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodrewardhistory.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodrewardhistory.FieldRewardAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardAt(v)
		return nil
	case goodrewardhistory.FieldTid:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTid(v)
		return nil
	case goodrewardhistory.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodRewardHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodrewardhistory.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodrewardhistory.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodrewardhistory.FieldDeletedAt)
	}
	if m.addreward_at != nil {
		fields = append(fields, goodrewardhistory.FieldRewardAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodRewardHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodrewardhistory.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodrewardhistory.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodrewardhistory.FieldRewardAt:
		return m.AddedRewardAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodrewardhistory.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodrewardhistory.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodrewardhistory.FieldRewardAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRewardAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodRewardHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodrewardhistory.FieldRewardAt) {
		fields = append(fields, goodrewardhistory.FieldRewardAt)
	}
	if m.FieldCleared(goodrewardhistory.FieldTid) {
		fields = append(fields, goodrewardhistory.FieldTid)
	}
	if m.FieldCleared(goodrewardhistory.FieldAmount) {
		fields = append(fields, goodrewardhistory.FieldAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodRewardHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodRewardHistoryMutation) ClearField(name string) error {
	switch name {
	case goodrewardhistory.FieldRewardAt:
		m.ClearRewardAt()
		return nil
	case goodrewardhistory.FieldTid:
		m.ClearTid()
		return nil
	case goodrewardhistory.FieldAmount:
		m.ClearAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodRewardHistoryMutation) ResetField(name string) error {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodrewardhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodrewardhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodrewardhistory.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodrewardhistory.FieldRewardAt:
		m.ResetRewardAt()
		return nil
	case goodrewardhistory.FieldTid:
		m.ResetTid()
		return nil
	case goodrewardhistory.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodRewardHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodRewardHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodRewardHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodRewardHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodRewardHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodRewardHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodRewardHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodRewardHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodRewardHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodRewardHistory edge %s", name)
}

// PromotionMutation represents an operation that mutates the Promotion nodes in the graph.
type PromotionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	good_id       *uuid.UUID
	message       *string
	start_at      *uint32
	addstart_at   *int32
	end_at        *uint32
	addend_at     *int32
	price         *decimal.Decimal
	posters       *[]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Promotion, error)
	predicates    []predicate.Promotion
}

var _ ent.Mutation = (*PromotionMutation)(nil)

// promotionOption allows management of the mutation configuration using functional options.
type promotionOption func(*PromotionMutation)

// newPromotionMutation creates new mutation for the Promotion entity.
func newPromotionMutation(c config, op Op, opts ...promotionOption) *PromotionMutation {
	m := &PromotionMutation{
		config:        c,
		op:            op,
		typ:           TypePromotion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionID sets the ID field of the mutation.
func withPromotionID(id uuid.UUID) promotionOption {
	return func(m *PromotionMutation) {
		var (
			err   error
			once  sync.Once
			value *Promotion
		)
		m.oldValue = func(ctx context.Context) (*Promotion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Promotion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotion sets the old Promotion of the mutation.
func withPromotion(node *Promotion) promotionOption {
	return func(m *PromotionMutation) {
		m.oldValue = func(context.Context) (*Promotion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Promotion entities.
func (m *PromotionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Promotion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *PromotionMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PromotionMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *PromotionMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PromotionMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *PromotionMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PromotionMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *PromotionMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PromotionMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PromotionMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *PromotionMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *PromotionMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *PromotionMutation) ResetGoodID() {
	m.good_id = nil
}

// SetMessage sets the "message" field.
func (m *PromotionMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *PromotionMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *PromotionMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[promotion.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *PromotionMutation) MessageCleared() bool {
	_, ok := m.clearedFields[promotion.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *PromotionMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, promotion.FieldMessage)
}

// SetStartAt sets the "start_at" field.
func (m *PromotionMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *PromotionMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *PromotionMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *PromotionMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *PromotionMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[promotion.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *PromotionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[promotion.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *PromotionMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, promotion.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *PromotionMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *PromotionMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *PromotionMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *PromotionMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *PromotionMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[promotion.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *PromotionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[promotion.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *PromotionMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, promotion.FieldEndAt)
}

// SetPrice sets the "price" field.
func (m *PromotionMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *PromotionMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *PromotionMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[promotion.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *PromotionMutation) PriceCleared() bool {
	_, ok := m.clearedFields[promotion.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *PromotionMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, promotion.FieldPrice)
}

// SetPosters sets the "posters" field.
func (m *PromotionMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *PromotionMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *PromotionMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[promotion.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *PromotionMutation) PostersCleared() bool {
	_, ok := m.clearedFields[promotion.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *PromotionMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, promotion.FieldPosters)
}

// Where appends a list predicates to the PromotionMutation builder.
func (m *PromotionMutation) Where(ps ...predicate.Promotion) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PromotionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Promotion).
func (m *PromotionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, promotion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotion.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotion.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, promotion.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, promotion.FieldGoodID)
	}
	if m.message != nil {
		fields = append(fields, promotion.FieldMessage)
	}
	if m.start_at != nil {
		fields = append(fields, promotion.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, promotion.FieldEndAt)
	}
	if m.price != nil {
		fields = append(fields, promotion.FieldPrice)
	}
	if m.posters != nil {
		fields = append(fields, promotion.FieldPosters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotion.FieldCreatedAt:
		return m.CreatedAt()
	case promotion.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotion.FieldDeletedAt:
		return m.DeletedAt()
	case promotion.FieldAppID:
		return m.AppID()
	case promotion.FieldGoodID:
		return m.GoodID()
	case promotion.FieldMessage:
		return m.Message()
	case promotion.FieldStartAt:
		return m.StartAt()
	case promotion.FieldEndAt:
		return m.EndAt()
	case promotion.FieldPrice:
		return m.Price()
	case promotion.FieldPosters:
		return m.Posters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotion.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotion.FieldAppID:
		return m.OldAppID(ctx)
	case promotion.FieldGoodID:
		return m.OldGoodID(ctx)
	case promotion.FieldMessage:
		return m.OldMessage(ctx)
	case promotion.FieldStartAt:
		return m.OldStartAt(ctx)
	case promotion.FieldEndAt:
		return m.OldEndAt(ctx)
	case promotion.FieldPrice:
		return m.OldPrice(ctx)
	case promotion.FieldPosters:
		return m.OldPosters(ctx)
	}
	return nil, fmt.Errorf("unknown Promotion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotion.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotion.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotion.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotion.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case promotion.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case promotion.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case promotion.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case promotion.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case promotion.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case promotion.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	}
	return fmt.Errorf("unknown Promotion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, promotion.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, promotion.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, promotion.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, promotion.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, promotion.FieldEndAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotion.FieldCreatedAt:
		return m.AddedCreatedAt()
	case promotion.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case promotion.FieldDeletedAt:
		return m.AddedDeletedAt()
	case promotion.FieldStartAt:
		return m.AddedStartAt()
	case promotion.FieldEndAt:
		return m.AddedEndAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotion.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case promotion.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case promotion.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case promotion.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case promotion.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown Promotion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotion.FieldMessage) {
		fields = append(fields, promotion.FieldMessage)
	}
	if m.FieldCleared(promotion.FieldStartAt) {
		fields = append(fields, promotion.FieldStartAt)
	}
	if m.FieldCleared(promotion.FieldEndAt) {
		fields = append(fields, promotion.FieldEndAt)
	}
	if m.FieldCleared(promotion.FieldPrice) {
		fields = append(fields, promotion.FieldPrice)
	}
	if m.FieldCleared(promotion.FieldPosters) {
		fields = append(fields, promotion.FieldPosters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionMutation) ClearField(name string) error {
	switch name {
	case promotion.FieldMessage:
		m.ClearMessage()
		return nil
	case promotion.FieldStartAt:
		m.ClearStartAt()
		return nil
	case promotion.FieldEndAt:
		m.ClearEndAt()
		return nil
	case promotion.FieldPrice:
		m.ClearPrice()
		return nil
	case promotion.FieldPosters:
		m.ClearPosters()
		return nil
	}
	return fmt.Errorf("unknown Promotion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionMutation) ResetField(name string) error {
	switch name {
	case promotion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotion.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotion.FieldAppID:
		m.ResetAppID()
		return nil
	case promotion.FieldGoodID:
		m.ResetGoodID()
		return nil
	case promotion.FieldMessage:
		m.ResetMessage()
		return nil
	case promotion.FieldStartAt:
		m.ResetStartAt()
		return nil
	case promotion.FieldEndAt:
		m.ResetEndAt()
		return nil
	case promotion.FieldPrice:
		m.ResetPrice()
		return nil
	case promotion.FieldPosters:
		m.ResetPosters()
		return nil
	}
	return fmt.Errorf("unknown Promotion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Promotion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Promotion edge %s", name)
}

// RecommendMutation represents an operation that mutates the Recommend nodes in the graph.
type RecommendMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *uint32
	addcreated_at      *int32
	updated_at         *uint32
	addupdated_at      *int32
	deleted_at         *uint32
	adddeleted_at      *int32
	app_id             *uuid.UUID
	good_id            *uuid.UUID
	recommender_id     *uuid.UUID
	message            *string
	recommend_index    *float64
	addrecommend_index *float64
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Recommend, error)
	predicates         []predicate.Recommend
}

var _ ent.Mutation = (*RecommendMutation)(nil)

// recommendOption allows management of the mutation configuration using functional options.
type recommendOption func(*RecommendMutation)

// newRecommendMutation creates new mutation for the Recommend entity.
func newRecommendMutation(c config, op Op, opts ...recommendOption) *RecommendMutation {
	m := &RecommendMutation{
		config:        c,
		op:            op,
		typ:           TypeRecommend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecommendID sets the ID field of the mutation.
func withRecommendID(id uuid.UUID) recommendOption {
	return func(m *RecommendMutation) {
		var (
			err   error
			once  sync.Once
			value *Recommend
		)
		m.oldValue = func(ctx context.Context) (*Recommend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recommend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecommend sets the old Recommend of the mutation.
func withRecommend(node *Recommend) recommendOption {
	return func(m *RecommendMutation) {
		m.oldValue = func(context.Context) (*Recommend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecommendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecommendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Recommend entities.
func (m *RecommendMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecommendMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecommendMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Recommend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RecommendMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecommendMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RecommendMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RecommendMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecommendMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecommendMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecommendMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RecommendMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RecommendMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecommendMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RecommendMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RecommendMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RecommendMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RecommendMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RecommendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *RecommendMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *RecommendMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *RecommendMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *RecommendMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *RecommendMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *RecommendMutation) ResetGoodID() {
	m.good_id = nil
}

// SetRecommenderID sets the "recommender_id" field.
func (m *RecommendMutation) SetRecommenderID(u uuid.UUID) {
	m.recommender_id = &u
}

// RecommenderID returns the value of the "recommender_id" field in the mutation.
func (m *RecommendMutation) RecommenderID() (r uuid.UUID, exists bool) {
	v := m.recommender_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommenderID returns the old "recommender_id" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldRecommenderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommenderID: %w", err)
	}
	return oldValue.RecommenderID, nil
}

// ClearRecommenderID clears the value of the "recommender_id" field.
func (m *RecommendMutation) ClearRecommenderID() {
	m.recommender_id = nil
	m.clearedFields[recommend.FieldRecommenderID] = struct{}{}
}

// RecommenderIDCleared returns if the "recommender_id" field was cleared in this mutation.
func (m *RecommendMutation) RecommenderIDCleared() bool {
	_, ok := m.clearedFields[recommend.FieldRecommenderID]
	return ok
}

// ResetRecommenderID resets all changes to the "recommender_id" field.
func (m *RecommendMutation) ResetRecommenderID() {
	m.recommender_id = nil
	delete(m.clearedFields, recommend.FieldRecommenderID)
}

// SetMessage sets the "message" field.
func (m *RecommendMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *RecommendMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *RecommendMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[recommend.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *RecommendMutation) MessageCleared() bool {
	_, ok := m.clearedFields[recommend.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *RecommendMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, recommend.FieldMessage)
}

// SetRecommendIndex sets the "recommend_index" field.
func (m *RecommendMutation) SetRecommendIndex(f float64) {
	m.recommend_index = &f
	m.addrecommend_index = nil
}

// RecommendIndex returns the value of the "recommend_index" field in the mutation.
func (m *RecommendMutation) RecommendIndex() (r float64, exists bool) {
	v := m.recommend_index
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendIndex returns the old "recommend_index" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldRecommendIndex(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendIndex: %w", err)
	}
	return oldValue.RecommendIndex, nil
}

// AddRecommendIndex adds f to the "recommend_index" field.
func (m *RecommendMutation) AddRecommendIndex(f float64) {
	if m.addrecommend_index != nil {
		*m.addrecommend_index += f
	} else {
		m.addrecommend_index = &f
	}
}

// AddedRecommendIndex returns the value that was added to the "recommend_index" field in this mutation.
func (m *RecommendMutation) AddedRecommendIndex() (r float64, exists bool) {
	v := m.addrecommend_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecommendIndex clears the value of the "recommend_index" field.
func (m *RecommendMutation) ClearRecommendIndex() {
	m.recommend_index = nil
	m.addrecommend_index = nil
	m.clearedFields[recommend.FieldRecommendIndex] = struct{}{}
}

// RecommendIndexCleared returns if the "recommend_index" field was cleared in this mutation.
func (m *RecommendMutation) RecommendIndexCleared() bool {
	_, ok := m.clearedFields[recommend.FieldRecommendIndex]
	return ok
}

// ResetRecommendIndex resets all changes to the "recommend_index" field.
func (m *RecommendMutation) ResetRecommendIndex() {
	m.recommend_index = nil
	m.addrecommend_index = nil
	delete(m.clearedFields, recommend.FieldRecommendIndex)
}

// Where appends a list predicates to the RecommendMutation builder.
func (m *RecommendMutation) Where(ps ...predicate.Recommend) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RecommendMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Recommend).
func (m *RecommendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecommendMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, recommend.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recommend.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, recommend.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, recommend.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, recommend.FieldGoodID)
	}
	if m.recommender_id != nil {
		fields = append(fields, recommend.FieldRecommenderID)
	}
	if m.message != nil {
		fields = append(fields, recommend.FieldMessage)
	}
	if m.recommend_index != nil {
		fields = append(fields, recommend.FieldRecommendIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecommendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recommend.FieldCreatedAt:
		return m.CreatedAt()
	case recommend.FieldUpdatedAt:
		return m.UpdatedAt()
	case recommend.FieldDeletedAt:
		return m.DeletedAt()
	case recommend.FieldAppID:
		return m.AppID()
	case recommend.FieldGoodID:
		return m.GoodID()
	case recommend.FieldRecommenderID:
		return m.RecommenderID()
	case recommend.FieldMessage:
		return m.Message()
	case recommend.FieldRecommendIndex:
		return m.RecommendIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecommendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recommend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recommend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recommend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case recommend.FieldAppID:
		return m.OldAppID(ctx)
	case recommend.FieldGoodID:
		return m.OldGoodID(ctx)
	case recommend.FieldRecommenderID:
		return m.OldRecommenderID(ctx)
	case recommend.FieldMessage:
		return m.OldMessage(ctx)
	case recommend.FieldRecommendIndex:
		return m.OldRecommendIndex(ctx)
	}
	return nil, fmt.Errorf("unknown Recommend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecommendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recommend.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recommend.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recommend.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case recommend.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case recommend.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case recommend.FieldRecommenderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommenderID(v)
		return nil
	case recommend.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case recommend.FieldRecommendIndex:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Recommend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecommendMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, recommend.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, recommend.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, recommend.FieldDeletedAt)
	}
	if m.addrecommend_index != nil {
		fields = append(fields, recommend.FieldRecommendIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecommendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recommend.FieldCreatedAt:
		return m.AddedCreatedAt()
	case recommend.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case recommend.FieldDeletedAt:
		return m.AddedDeletedAt()
	case recommend.FieldRecommendIndex:
		return m.AddedRecommendIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecommendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recommend.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case recommend.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case recommend.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case recommend.FieldRecommendIndex:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecommendIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Recommend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecommendMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recommend.FieldRecommenderID) {
		fields = append(fields, recommend.FieldRecommenderID)
	}
	if m.FieldCleared(recommend.FieldMessage) {
		fields = append(fields, recommend.FieldMessage)
	}
	if m.FieldCleared(recommend.FieldRecommendIndex) {
		fields = append(fields, recommend.FieldRecommendIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecommendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecommendMutation) ClearField(name string) error {
	switch name {
	case recommend.FieldRecommenderID:
		m.ClearRecommenderID()
		return nil
	case recommend.FieldMessage:
		m.ClearMessage()
		return nil
	case recommend.FieldRecommendIndex:
		m.ClearRecommendIndex()
		return nil
	}
	return fmt.Errorf("unknown Recommend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecommendMutation) ResetField(name string) error {
	switch name {
	case recommend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recommend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recommend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case recommend.FieldAppID:
		m.ResetAppID()
		return nil
	case recommend.FieldGoodID:
		m.ResetGoodID()
		return nil
	case recommend.FieldRecommenderID:
		m.ResetRecommenderID()
		return nil
	case recommend.FieldMessage:
		m.ResetMessage()
		return nil
	case recommend.FieldRecommendIndex:
		m.ResetRecommendIndex()
		return nil
	}
	return fmt.Errorf("unknown Recommend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecommendMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecommendMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecommendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecommendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecommendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecommendMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecommendMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Recommend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecommendMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Recommend edge %s", name)
}

// RequiredGoodMutation represents an operation that mutates the RequiredGood nodes in the graph.
type RequiredGoodMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	app_id           *uuid.UUID
	main_good_id     *uuid.UUID
	required_good_id *uuid.UUID
	must             *bool
	commission       *bool
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*RequiredGood, error)
	predicates       []predicate.RequiredGood
}

var _ ent.Mutation = (*RequiredGoodMutation)(nil)

// requiredgoodOption allows management of the mutation configuration using functional options.
type requiredgoodOption func(*RequiredGoodMutation)

// newRequiredGoodMutation creates new mutation for the RequiredGood entity.
func newRequiredGoodMutation(c config, op Op, opts ...requiredgoodOption) *RequiredGoodMutation {
	m := &RequiredGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeRequiredGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequiredGoodID sets the ID field of the mutation.
func withRequiredGoodID(id uuid.UUID) requiredgoodOption {
	return func(m *RequiredGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *RequiredGood
		)
		m.oldValue = func(ctx context.Context) (*RequiredGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RequiredGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequiredGood sets the old RequiredGood of the mutation.
func withRequiredGood(node *RequiredGood) requiredgoodOption {
	return func(m *RequiredGoodMutation) {
		m.oldValue = func(context.Context) (*RequiredGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequiredGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequiredGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RequiredGood entities.
func (m *RequiredGoodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequiredGoodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequiredGoodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RequiredGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequiredGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequiredGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RequiredGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RequiredGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequiredGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequiredGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequiredGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RequiredGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RequiredGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequiredGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RequiredGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RequiredGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RequiredGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RequiredGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RequiredGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *RequiredGoodMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *RequiredGoodMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *RequiredGoodMutation) ResetAppID() {
	m.app_id = nil
}

// SetMainGoodID sets the "main_good_id" field.
func (m *RequiredGoodMutation) SetMainGoodID(u uuid.UUID) {
	m.main_good_id = &u
}

// MainGoodID returns the value of the "main_good_id" field in the mutation.
func (m *RequiredGoodMutation) MainGoodID() (r uuid.UUID, exists bool) {
	v := m.main_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMainGoodID returns the old "main_good_id" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldMainGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainGoodID: %w", err)
	}
	return oldValue.MainGoodID, nil
}

// ResetMainGoodID resets all changes to the "main_good_id" field.
func (m *RequiredGoodMutation) ResetMainGoodID() {
	m.main_good_id = nil
}

// SetRequiredGoodID sets the "required_good_id" field.
func (m *RequiredGoodMutation) SetRequiredGoodID(u uuid.UUID) {
	m.required_good_id = &u
}

// RequiredGoodID returns the value of the "required_good_id" field in the mutation.
func (m *RequiredGoodMutation) RequiredGoodID() (r uuid.UUID, exists bool) {
	v := m.required_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredGoodID returns the old "required_good_id" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldRequiredGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredGoodID: %w", err)
	}
	return oldValue.RequiredGoodID, nil
}

// ResetRequiredGoodID resets all changes to the "required_good_id" field.
func (m *RequiredGoodMutation) ResetRequiredGoodID() {
	m.required_good_id = nil
}

// SetMust sets the "must" field.
func (m *RequiredGoodMutation) SetMust(b bool) {
	m.must = &b
}

// Must returns the value of the "must" field in the mutation.
func (m *RequiredGoodMutation) Must() (r bool, exists bool) {
	v := m.must
	if v == nil {
		return
	}
	return *v, true
}

// OldMust returns the old "must" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldMust(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMust: %w", err)
	}
	return oldValue.Must, nil
}

// ClearMust clears the value of the "must" field.
func (m *RequiredGoodMutation) ClearMust() {
	m.must = nil
	m.clearedFields[requiredgood.FieldMust] = struct{}{}
}

// MustCleared returns if the "must" field was cleared in this mutation.
func (m *RequiredGoodMutation) MustCleared() bool {
	_, ok := m.clearedFields[requiredgood.FieldMust]
	return ok
}

// ResetMust resets all changes to the "must" field.
func (m *RequiredGoodMutation) ResetMust() {
	m.must = nil
	delete(m.clearedFields, requiredgood.FieldMust)
}

// SetCommission sets the "commission" field.
func (m *RequiredGoodMutation) SetCommission(b bool) {
	m.commission = &b
}

// Commission returns the value of the "commission" field in the mutation.
func (m *RequiredGoodMutation) Commission() (r bool, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommission returns the old "commission" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldCommission(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommission: %w", err)
	}
	return oldValue.Commission, nil
}

// ClearCommission clears the value of the "commission" field.
func (m *RequiredGoodMutation) ClearCommission() {
	m.commission = nil
	m.clearedFields[requiredgood.FieldCommission] = struct{}{}
}

// CommissionCleared returns if the "commission" field was cleared in this mutation.
func (m *RequiredGoodMutation) CommissionCleared() bool {
	_, ok := m.clearedFields[requiredgood.FieldCommission]
	return ok
}

// ResetCommission resets all changes to the "commission" field.
func (m *RequiredGoodMutation) ResetCommission() {
	m.commission = nil
	delete(m.clearedFields, requiredgood.FieldCommission)
}

// Where appends a list predicates to the RequiredGoodMutation builder.
func (m *RequiredGoodMutation) Where(ps ...predicate.RequiredGood) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RequiredGoodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RequiredGood).
func (m *RequiredGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequiredGoodMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, requiredgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, requiredgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, requiredgood.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, requiredgood.FieldAppID)
	}
	if m.main_good_id != nil {
		fields = append(fields, requiredgood.FieldMainGoodID)
	}
	if m.required_good_id != nil {
		fields = append(fields, requiredgood.FieldRequiredGoodID)
	}
	if m.must != nil {
		fields = append(fields, requiredgood.FieldMust)
	}
	if m.commission != nil {
		fields = append(fields, requiredgood.FieldCommission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequiredGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case requiredgood.FieldCreatedAt:
		return m.CreatedAt()
	case requiredgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case requiredgood.FieldDeletedAt:
		return m.DeletedAt()
	case requiredgood.FieldAppID:
		return m.AppID()
	case requiredgood.FieldMainGoodID:
		return m.MainGoodID()
	case requiredgood.FieldRequiredGoodID:
		return m.RequiredGoodID()
	case requiredgood.FieldMust:
		return m.Must()
	case requiredgood.FieldCommission:
		return m.Commission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequiredGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case requiredgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case requiredgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case requiredgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case requiredgood.FieldAppID:
		return m.OldAppID(ctx)
	case requiredgood.FieldMainGoodID:
		return m.OldMainGoodID(ctx)
	case requiredgood.FieldRequiredGoodID:
		return m.OldRequiredGoodID(ctx)
	case requiredgood.FieldMust:
		return m.OldMust(ctx)
	case requiredgood.FieldCommission:
		return m.OldCommission(ctx)
	}
	return nil, fmt.Errorf("unknown RequiredGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequiredGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case requiredgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case requiredgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case requiredgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case requiredgood.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case requiredgood.FieldMainGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainGoodID(v)
		return nil
	case requiredgood.FieldRequiredGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredGoodID(v)
		return nil
	case requiredgood.FieldMust:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMust(v)
		return nil
	case requiredgood.FieldCommission:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommission(v)
		return nil
	}
	return fmt.Errorf("unknown RequiredGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequiredGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, requiredgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, requiredgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, requiredgood.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequiredGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case requiredgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case requiredgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case requiredgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequiredGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case requiredgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case requiredgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case requiredgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RequiredGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequiredGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(requiredgood.FieldMust) {
		fields = append(fields, requiredgood.FieldMust)
	}
	if m.FieldCleared(requiredgood.FieldCommission) {
		fields = append(fields, requiredgood.FieldCommission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequiredGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequiredGoodMutation) ClearField(name string) error {
	switch name {
	case requiredgood.FieldMust:
		m.ClearMust()
		return nil
	case requiredgood.FieldCommission:
		m.ClearCommission()
		return nil
	}
	return fmt.Errorf("unknown RequiredGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequiredGoodMutation) ResetField(name string) error {
	switch name {
	case requiredgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case requiredgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case requiredgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case requiredgood.FieldAppID:
		m.ResetAppID()
		return nil
	case requiredgood.FieldMainGoodID:
		m.ResetMainGoodID()
		return nil
	case requiredgood.FieldRequiredGoodID:
		m.ResetRequiredGoodID()
		return nil
	case requiredgood.FieldMust:
		m.ResetMust()
		return nil
	case requiredgood.FieldCommission:
		m.ResetCommission()
		return nil
	}
	return fmt.Errorf("unknown RequiredGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequiredGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequiredGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequiredGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequiredGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequiredGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequiredGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequiredGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RequiredGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequiredGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RequiredGood edge %s", name)
}

// StockMutation represents an operation that mutates the Stock nodes in the graph.
type StockMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	good_id       *uuid.UUID
	total         *decimal.Decimal
	locked        *decimal.Decimal
	in_service    *decimal.Decimal
	wait_start    *decimal.Decimal
	sold          *decimal.Decimal
	app_locked    *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Stock, error)
	predicates    []predicate.Stock
}

var _ ent.Mutation = (*StockMutation)(nil)

// stockOption allows management of the mutation configuration using functional options.
type stockOption func(*StockMutation)

// newStockMutation creates new mutation for the Stock entity.
func newStockMutation(c config, op Op, opts ...stockOption) *StockMutation {
	m := &StockMutation{
		config:        c,
		op:            op,
		typ:           TypeStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockID sets the ID field of the mutation.
func withStockID(id uuid.UUID) stockOption {
	return func(m *StockMutation) {
		var (
			err   error
			once  sync.Once
			value *Stock
		)
		m.oldValue = func(ctx context.Context) (*Stock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStock sets the old Stock of the mutation.
func withStock(node *Stock) stockOption {
	return func(m *StockMutation) {
		m.oldValue = func(context.Context) (*Stock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stock entities.
func (m *StockMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *StockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *StockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *StockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *StockMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *StockMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *StockMutation) ResetGoodID() {
	m.good_id = nil
}

// SetTotal sets the "total" field.
func (m *StockMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
}

// Total returns the value of the "total" field in the mutation.
func (m *StockMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldTotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// ClearTotal clears the value of the "total" field.
func (m *StockMutation) ClearTotal() {
	m.total = nil
	m.clearedFields[stock.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *StockMutation) TotalCleared() bool {
	_, ok := m.clearedFields[stock.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *StockMutation) ResetTotal() {
	m.total = nil
	delete(m.clearedFields, stock.FieldTotal)
}

// SetLocked sets the "locked" field.
func (m *StockMutation) SetLocked(d decimal.Decimal) {
	m.locked = &d
}

// Locked returns the value of the "locked" field in the mutation.
func (m *StockMutation) Locked() (r decimal.Decimal, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ClearLocked clears the value of the "locked" field.
func (m *StockMutation) ClearLocked() {
	m.locked = nil
	m.clearedFields[stock.FieldLocked] = struct{}{}
}

// LockedCleared returns if the "locked" field was cleared in this mutation.
func (m *StockMutation) LockedCleared() bool {
	_, ok := m.clearedFields[stock.FieldLocked]
	return ok
}

// ResetLocked resets all changes to the "locked" field.
func (m *StockMutation) ResetLocked() {
	m.locked = nil
	delete(m.clearedFields, stock.FieldLocked)
}

// SetInService sets the "in_service" field.
func (m *StockMutation) SetInService(d decimal.Decimal) {
	m.in_service = &d
}

// InService returns the value of the "in_service" field in the mutation.
func (m *StockMutation) InService() (r decimal.Decimal, exists bool) {
	v := m.in_service
	if v == nil {
		return
	}
	return *v, true
}

// OldInService returns the old "in_service" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldInService(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInService: %w", err)
	}
	return oldValue.InService, nil
}

// ClearInService clears the value of the "in_service" field.
func (m *StockMutation) ClearInService() {
	m.in_service = nil
	m.clearedFields[stock.FieldInService] = struct{}{}
}

// InServiceCleared returns if the "in_service" field was cleared in this mutation.
func (m *StockMutation) InServiceCleared() bool {
	_, ok := m.clearedFields[stock.FieldInService]
	return ok
}

// ResetInService resets all changes to the "in_service" field.
func (m *StockMutation) ResetInService() {
	m.in_service = nil
	delete(m.clearedFields, stock.FieldInService)
}

// SetWaitStart sets the "wait_start" field.
func (m *StockMutation) SetWaitStart(d decimal.Decimal) {
	m.wait_start = &d
}

// WaitStart returns the value of the "wait_start" field in the mutation.
func (m *StockMutation) WaitStart() (r decimal.Decimal, exists bool) {
	v := m.wait_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWaitStart returns the old "wait_start" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldWaitStart(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaitStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaitStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaitStart: %w", err)
	}
	return oldValue.WaitStart, nil
}

// ClearWaitStart clears the value of the "wait_start" field.
func (m *StockMutation) ClearWaitStart() {
	m.wait_start = nil
	m.clearedFields[stock.FieldWaitStart] = struct{}{}
}

// WaitStartCleared returns if the "wait_start" field was cleared in this mutation.
func (m *StockMutation) WaitStartCleared() bool {
	_, ok := m.clearedFields[stock.FieldWaitStart]
	return ok
}

// ResetWaitStart resets all changes to the "wait_start" field.
func (m *StockMutation) ResetWaitStart() {
	m.wait_start = nil
	delete(m.clearedFields, stock.FieldWaitStart)
}

// SetSold sets the "sold" field.
func (m *StockMutation) SetSold(d decimal.Decimal) {
	m.sold = &d
}

// Sold returns the value of the "sold" field in the mutation.
func (m *StockMutation) Sold() (r decimal.Decimal, exists bool) {
	v := m.sold
	if v == nil {
		return
	}
	return *v, true
}

// OldSold returns the old "sold" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldSold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSold: %w", err)
	}
	return oldValue.Sold, nil
}

// ClearSold clears the value of the "sold" field.
func (m *StockMutation) ClearSold() {
	m.sold = nil
	m.clearedFields[stock.FieldSold] = struct{}{}
}

// SoldCleared returns if the "sold" field was cleared in this mutation.
func (m *StockMutation) SoldCleared() bool {
	_, ok := m.clearedFields[stock.FieldSold]
	return ok
}

// ResetSold resets all changes to the "sold" field.
func (m *StockMutation) ResetSold() {
	m.sold = nil
	delete(m.clearedFields, stock.FieldSold)
}

// SetAppLocked sets the "app_locked" field.
func (m *StockMutation) SetAppLocked(d decimal.Decimal) {
	m.app_locked = &d
}

// AppLocked returns the value of the "app_locked" field in the mutation.
func (m *StockMutation) AppLocked() (r decimal.Decimal, exists bool) {
	v := m.app_locked
	if v == nil {
		return
	}
	return *v, true
}

// OldAppLocked returns the old "app_locked" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldAppLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppLocked: %w", err)
	}
	return oldValue.AppLocked, nil
}

// ClearAppLocked clears the value of the "app_locked" field.
func (m *StockMutation) ClearAppLocked() {
	m.app_locked = nil
	m.clearedFields[stock.FieldAppLocked] = struct{}{}
}

// AppLockedCleared returns if the "app_locked" field was cleared in this mutation.
func (m *StockMutation) AppLockedCleared() bool {
	_, ok := m.clearedFields[stock.FieldAppLocked]
	return ok
}

// ResetAppLocked resets all changes to the "app_locked" field.
func (m *StockMutation) ResetAppLocked() {
	m.app_locked = nil
	delete(m.clearedFields, stock.FieldAppLocked)
}

// Where appends a list predicates to the StockMutation builder.
func (m *StockMutation) Where(ps ...predicate.Stock) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stock).
func (m *StockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, stock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, stock.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, stock.FieldGoodID)
	}
	if m.total != nil {
		fields = append(fields, stock.FieldTotal)
	}
	if m.locked != nil {
		fields = append(fields, stock.FieldLocked)
	}
	if m.in_service != nil {
		fields = append(fields, stock.FieldInService)
	}
	if m.wait_start != nil {
		fields = append(fields, stock.FieldWaitStart)
	}
	if m.sold != nil {
		fields = append(fields, stock.FieldSold)
	}
	if m.app_locked != nil {
		fields = append(fields, stock.FieldAppLocked)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldCreatedAt:
		return m.CreatedAt()
	case stock.FieldUpdatedAt:
		return m.UpdatedAt()
	case stock.FieldDeletedAt:
		return m.DeletedAt()
	case stock.FieldGoodID:
		return m.GoodID()
	case stock.FieldTotal:
		return m.Total()
	case stock.FieldLocked:
		return m.Locked()
	case stock.FieldInService:
		return m.InService()
	case stock.FieldWaitStart:
		return m.WaitStart()
	case stock.FieldSold:
		return m.Sold()
	case stock.FieldAppLocked:
		return m.AppLocked()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case stock.FieldGoodID:
		return m.OldGoodID(ctx)
	case stock.FieldTotal:
		return m.OldTotal(ctx)
	case stock.FieldLocked:
		return m.OldLocked(ctx)
	case stock.FieldInService:
		return m.OldInService(ctx)
	case stock.FieldWaitStart:
		return m.OldWaitStart(ctx)
	case stock.FieldSold:
		return m.OldSold(ctx)
	case stock.FieldAppLocked:
		return m.OldAppLocked(ctx)
	}
	return nil, fmt.Errorf("unknown Stock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case stock.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case stock.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case stock.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case stock.FieldInService:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInService(v)
		return nil
	case stock.FieldWaitStart:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaitStart(v)
		return nil
	case stock.FieldSold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSold(v)
		return nil
	case stock.FieldAppLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppLocked(v)
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, stock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, stock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, stock.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case stock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case stock.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case stock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case stock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Stock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stock.FieldTotal) {
		fields = append(fields, stock.FieldTotal)
	}
	if m.FieldCleared(stock.FieldLocked) {
		fields = append(fields, stock.FieldLocked)
	}
	if m.FieldCleared(stock.FieldInService) {
		fields = append(fields, stock.FieldInService)
	}
	if m.FieldCleared(stock.FieldWaitStart) {
		fields = append(fields, stock.FieldWaitStart)
	}
	if m.FieldCleared(stock.FieldSold) {
		fields = append(fields, stock.FieldSold)
	}
	if m.FieldCleared(stock.FieldAppLocked) {
		fields = append(fields, stock.FieldAppLocked)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockMutation) ClearField(name string) error {
	switch name {
	case stock.FieldTotal:
		m.ClearTotal()
		return nil
	case stock.FieldLocked:
		m.ClearLocked()
		return nil
	case stock.FieldInService:
		m.ClearInService()
		return nil
	case stock.FieldWaitStart:
		m.ClearWaitStart()
		return nil
	case stock.FieldSold:
		m.ClearSold()
		return nil
	case stock.FieldAppLocked:
		m.ClearAppLocked()
		return nil
	}
	return fmt.Errorf("unknown Stock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockMutation) ResetField(name string) error {
	switch name {
	case stock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case stock.FieldGoodID:
		m.ResetGoodID()
		return nil
	case stock.FieldTotal:
		m.ResetTotal()
		return nil
	case stock.FieldLocked:
		m.ResetLocked()
		return nil
	case stock.FieldInService:
		m.ResetInService()
		return nil
	case stock.FieldWaitStart:
		m.ResetWaitStart()
		return nil
	case stock.FieldSold:
		m.ResetSold()
		return nil
	case stock.FieldAppLocked:
		m.ResetAppLocked()
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Stock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Stock edge %s", name)
}

// VendorLocationMutation represents an operation that mutates the VendorLocation nodes in the graph.
type VendorLocationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	country       *string
	province      *string
	city          *string
	address       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VendorLocation, error)
	predicates    []predicate.VendorLocation
}

var _ ent.Mutation = (*VendorLocationMutation)(nil)

// vendorlocationOption allows management of the mutation configuration using functional options.
type vendorlocationOption func(*VendorLocationMutation)

// newVendorLocationMutation creates new mutation for the VendorLocation entity.
func newVendorLocationMutation(c config, op Op, opts ...vendorlocationOption) *VendorLocationMutation {
	m := &VendorLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeVendorLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVendorLocationID sets the ID field of the mutation.
func withVendorLocationID(id uuid.UUID) vendorlocationOption {
	return func(m *VendorLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *VendorLocation
		)
		m.oldValue = func(ctx context.Context) (*VendorLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VendorLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVendorLocation sets the old VendorLocation of the mutation.
func withVendorLocation(node *VendorLocation) vendorlocationOption {
	return func(m *VendorLocationMutation) {
		m.oldValue = func(context.Context) (*VendorLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VendorLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VendorLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VendorLocation entities.
func (m *VendorLocationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VendorLocationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VendorLocationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VendorLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VendorLocationMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VendorLocationMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *VendorLocationMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *VendorLocationMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VendorLocationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VendorLocationMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VendorLocationMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *VendorLocationMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *VendorLocationMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VendorLocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VendorLocationMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VendorLocationMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *VendorLocationMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *VendorLocationMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VendorLocationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCountry sets the "country" field.
func (m *VendorLocationMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *VendorLocationMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *VendorLocationMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[vendorlocation.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *VendorLocationMutation) CountryCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *VendorLocationMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, vendorlocation.FieldCountry)
}

// SetProvince sets the "province" field.
func (m *VendorLocationMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *VendorLocationMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *VendorLocationMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[vendorlocation.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *VendorLocationMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *VendorLocationMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, vendorlocation.FieldProvince)
}

// SetCity sets the "city" field.
func (m *VendorLocationMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *VendorLocationMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *VendorLocationMutation) ClearCity() {
	m.city = nil
	m.clearedFields[vendorlocation.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *VendorLocationMutation) CityCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *VendorLocationMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, vendorlocation.FieldCity)
}

// SetAddress sets the "address" field.
func (m *VendorLocationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *VendorLocationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *VendorLocationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[vendorlocation.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *VendorLocationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *VendorLocationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, vendorlocation.FieldAddress)
}

// Where appends a list predicates to the VendorLocationMutation builder.
func (m *VendorLocationMutation) Where(ps ...predicate.VendorLocation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VendorLocationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VendorLocation).
func (m *VendorLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VendorLocationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, vendorlocation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vendorlocation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vendorlocation.FieldDeletedAt)
	}
	if m.country != nil {
		fields = append(fields, vendorlocation.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, vendorlocation.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, vendorlocation.FieldCity)
	}
	if m.address != nil {
		fields = append(fields, vendorlocation.FieldAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VendorLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vendorlocation.FieldCreatedAt:
		return m.CreatedAt()
	case vendorlocation.FieldUpdatedAt:
		return m.UpdatedAt()
	case vendorlocation.FieldDeletedAt:
		return m.DeletedAt()
	case vendorlocation.FieldCountry:
		return m.Country()
	case vendorlocation.FieldProvince:
		return m.Province()
	case vendorlocation.FieldCity:
		return m.City()
	case vendorlocation.FieldAddress:
		return m.Address()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VendorLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vendorlocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vendorlocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vendorlocation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vendorlocation.FieldCountry:
		return m.OldCountry(ctx)
	case vendorlocation.FieldProvince:
		return m.OldProvince(ctx)
	case vendorlocation.FieldCity:
		return m.OldCity(ctx)
	case vendorlocation.FieldAddress:
		return m.OldAddress(ctx)
	}
	return nil, fmt.Errorf("unknown VendorLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vendorlocation.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vendorlocation.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vendorlocation.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vendorlocation.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case vendorlocation.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case vendorlocation.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case vendorlocation.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	}
	return fmt.Errorf("unknown VendorLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VendorLocationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, vendorlocation.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, vendorlocation.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, vendorlocation.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VendorLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vendorlocation.FieldCreatedAt:
		return m.AddedCreatedAt()
	case vendorlocation.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case vendorlocation.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vendorlocation.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case vendorlocation.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case vendorlocation.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VendorLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VendorLocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vendorlocation.FieldCountry) {
		fields = append(fields, vendorlocation.FieldCountry)
	}
	if m.FieldCleared(vendorlocation.FieldProvince) {
		fields = append(fields, vendorlocation.FieldProvince)
	}
	if m.FieldCleared(vendorlocation.FieldCity) {
		fields = append(fields, vendorlocation.FieldCity)
	}
	if m.FieldCleared(vendorlocation.FieldAddress) {
		fields = append(fields, vendorlocation.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VendorLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VendorLocationMutation) ClearField(name string) error {
	switch name {
	case vendorlocation.FieldCountry:
		m.ClearCountry()
		return nil
	case vendorlocation.FieldProvince:
		m.ClearProvince()
		return nil
	case vendorlocation.FieldCity:
		m.ClearCity()
		return nil
	case vendorlocation.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown VendorLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VendorLocationMutation) ResetField(name string) error {
	switch name {
	case vendorlocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vendorlocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vendorlocation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vendorlocation.FieldCountry:
		m.ResetCountry()
		return nil
	case vendorlocation.FieldProvince:
		m.ResetProvince()
		return nil
	case vendorlocation.FieldCity:
		m.ResetCity()
		return nil
	case vendorlocation.FieldAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown VendorLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VendorLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VendorLocationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VendorLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VendorLocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VendorLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VendorLocationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VendorLocationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VendorLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VendorLocationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VendorLocation edge %s", name)
}
