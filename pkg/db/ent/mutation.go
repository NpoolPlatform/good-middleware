// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/appdefaultgood"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/appgood"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/appstock"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/comment"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/deviceinfo"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/extrainfo"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/good"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/goodreward"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/goodrewardhistory"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/like"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/predicate"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/promotion"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/recommend"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/requiredgood"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/score"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/stock"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/topmost"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/topmostgood"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/vendorbrand"
	"github.com/NpoolPlatform/good-middleware/pkg/db/ent/vendorlocation"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppDefaultGood    = "AppDefaultGood"
	TypeAppGood           = "AppGood"
	TypeAppStock          = "AppStock"
	TypeComment           = "Comment"
	TypeDeviceInfo        = "DeviceInfo"
	TypeExtraInfo         = "ExtraInfo"
	TypeGood              = "Good"
	TypeGoodReward        = "GoodReward"
	TypeGoodRewardHistory = "GoodRewardHistory"
	TypeLike              = "Like"
	TypePromotion         = "Promotion"
	TypeRecommend         = "Recommend"
	TypeRequiredGood      = "RequiredGood"
	TypeScore             = "Score"
	TypeStock             = "Stock"
	TypeTopMost           = "TopMost"
	TypeTopMostGood       = "TopMostGood"
	TypeVendorBrand       = "VendorBrand"
	TypeVendorLocation    = "VendorLocation"
)

// AppDefaultGoodMutation represents an operation that mutates the AppDefaultGood nodes in the graph.
type AppDefaultGoodMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	good_id       *uuid.UUID
	app_good_id   *uuid.UUID
	coin_type_id  *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppDefaultGood, error)
	predicates    []predicate.AppDefaultGood
}

var _ ent.Mutation = (*AppDefaultGoodMutation)(nil)

// appdefaultgoodOption allows management of the mutation configuration using functional options.
type appdefaultgoodOption func(*AppDefaultGoodMutation)

// newAppDefaultGoodMutation creates new mutation for the AppDefaultGood entity.
func newAppDefaultGoodMutation(c config, op Op, opts ...appdefaultgoodOption) *AppDefaultGoodMutation {
	m := &AppDefaultGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeAppDefaultGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppDefaultGoodID sets the ID field of the mutation.
func withAppDefaultGoodID(id uuid.UUID) appdefaultgoodOption {
	return func(m *AppDefaultGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *AppDefaultGood
		)
		m.oldValue = func(ctx context.Context) (*AppDefaultGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppDefaultGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppDefaultGood sets the old AppDefaultGood of the mutation.
func withAppDefaultGood(node *AppDefaultGood) appdefaultgoodOption {
	return func(m *AppDefaultGoodMutation) {
		m.oldValue = func(context.Context) (*AppDefaultGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppDefaultGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppDefaultGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppDefaultGood entities.
func (m *AppDefaultGoodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppDefaultGoodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppDefaultGoodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppDefaultGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppDefaultGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppDefaultGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppDefaultGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppDefaultGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppDefaultGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppDefaultGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppDefaultGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppDefaultGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppDefaultGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppDefaultGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppDefaultGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppDefaultGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppDefaultGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppDefaultGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppDefaultGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppDefaultGoodMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppDefaultGoodMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppDefaultGoodMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appdefaultgood.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppDefaultGoodMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appdefaultgood.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppDefaultGoodMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appdefaultgood.FieldAppID)
}

// SetGoodID sets the "good_id" field.
func (m *AppDefaultGoodMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppDefaultGoodMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *AppDefaultGoodMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[appdefaultgood.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *AppDefaultGoodMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[appdefaultgood.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppDefaultGoodMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, appdefaultgood.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppDefaultGoodMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppDefaultGoodMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppDefaultGoodMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appdefaultgood.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppDefaultGoodMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appdefaultgood.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppDefaultGoodMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appdefaultgood.FieldAppGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *AppDefaultGoodMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *AppDefaultGoodMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the AppDefaultGood entity.
// If the AppDefaultGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppDefaultGoodMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *AppDefaultGoodMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[appdefaultgood.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *AppDefaultGoodMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[appdefaultgood.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *AppDefaultGoodMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, appdefaultgood.FieldCoinTypeID)
}

// Where appends a list predicates to the AppDefaultGoodMutation builder.
func (m *AppDefaultGoodMutation) Where(ps ...predicate.AppDefaultGood) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppDefaultGoodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppDefaultGood).
func (m *AppDefaultGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppDefaultGoodMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, appdefaultgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appdefaultgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appdefaultgood.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appdefaultgood.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appdefaultgood.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, appdefaultgood.FieldAppGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, appdefaultgood.FieldCoinTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppDefaultGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		return m.CreatedAt()
	case appdefaultgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case appdefaultgood.FieldDeletedAt:
		return m.DeletedAt()
	case appdefaultgood.FieldAppID:
		return m.AppID()
	case appdefaultgood.FieldGoodID:
		return m.GoodID()
	case appdefaultgood.FieldAppGoodID:
		return m.AppGoodID()
	case appdefaultgood.FieldCoinTypeID:
		return m.CoinTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppDefaultGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appdefaultgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appdefaultgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appdefaultgood.FieldAppID:
		return m.OldAppID(ctx)
	case appdefaultgood.FieldGoodID:
		return m.OldGoodID(ctx)
	case appdefaultgood.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appdefaultgood.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown AppDefaultGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppDefaultGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appdefaultgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appdefaultgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appdefaultgood.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appdefaultgood.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appdefaultgood.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appdefaultgood.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppDefaultGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appdefaultgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appdefaultgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appdefaultgood.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppDefaultGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appdefaultgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appdefaultgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppDefaultGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appdefaultgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appdefaultgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppDefaultGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appdefaultgood.FieldAppID) {
		fields = append(fields, appdefaultgood.FieldAppID)
	}
	if m.FieldCleared(appdefaultgood.FieldGoodID) {
		fields = append(fields, appdefaultgood.FieldGoodID)
	}
	if m.FieldCleared(appdefaultgood.FieldAppGoodID) {
		fields = append(fields, appdefaultgood.FieldAppGoodID)
	}
	if m.FieldCleared(appdefaultgood.FieldCoinTypeID) {
		fields = append(fields, appdefaultgood.FieldCoinTypeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppDefaultGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppDefaultGoodMutation) ClearField(name string) error {
	switch name {
	case appdefaultgood.FieldAppID:
		m.ClearAppID()
		return nil
	case appdefaultgood.FieldGoodID:
		m.ClearGoodID()
		return nil
	case appdefaultgood.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appdefaultgood.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppDefaultGoodMutation) ResetField(name string) error {
	switch name {
	case appdefaultgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appdefaultgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appdefaultgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appdefaultgood.FieldAppID:
		m.ResetAppID()
		return nil
	case appdefaultgood.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appdefaultgood.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appdefaultgood.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	}
	return fmt.Errorf("unknown AppDefaultGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppDefaultGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppDefaultGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppDefaultGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppDefaultGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppDefaultGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppDefaultGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppDefaultGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppDefaultGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppDefaultGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppDefaultGood edge %s", name)
}

// AppGoodMutation represents an operation that mutates the AppGood nodes in the graph.
type AppGoodMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	created_at                  *uint32
	addcreated_at               *int32
	updated_at                  *uint32
	addupdated_at               *int32
	deleted_at                  *uint32
	adddeleted_at               *int32
	app_id                      *uuid.UUID
	good_id                     *uuid.UUID
	online                      *bool
	visible                     *bool
	good_name                   *string
	price                       *decimal.Decimal
	display_index               *int32
	adddisplay_index            *int32
	purchase_limit              *int32
	addpurchase_limit           *int32
	sale_start_at               *uint32
	addsale_start_at            *int32
	sale_end_at                 *uint32
	addsale_end_at              *int32
	service_start_at            *uint32
	addservice_start_at         *int32
	descriptions                *[]string
	good_banner                 *string
	display_names               *[]string
	enable_purchase             *bool
	enable_product_page         *bool
	cancel_mode                 *string
	user_purchase_limit         *decimal.Decimal
	display_colors              *[]string
	cancellable_before_start    *uint32
	addcancellable_before_start *int32
	product_page                *string
	enable_set_commission       *bool
	posters                     *[]string
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*AppGood, error)
	predicates                  []predicate.AppGood
}

var _ ent.Mutation = (*AppGoodMutation)(nil)

// appgoodOption allows management of the mutation configuration using functional options.
type appgoodOption func(*AppGoodMutation)

// newAppGoodMutation creates new mutation for the AppGood entity.
func newAppGoodMutation(c config, op Op, opts ...appgoodOption) *AppGoodMutation {
	m := &AppGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeAppGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppGoodID sets the ID field of the mutation.
func withAppGoodID(id uuid.UUID) appgoodOption {
	return func(m *AppGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *AppGood
		)
		m.oldValue = func(ctx context.Context) (*AppGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppGood sets the old AppGood of the mutation.
func withAppGood(node *AppGood) appgoodOption {
	return func(m *AppGoodMutation) {
		m.oldValue = func(context.Context) (*AppGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppGood entities.
func (m *AppGoodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppGoodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppGoodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppGoodMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppGoodMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppGoodMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *AppGoodMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppGoodMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppGoodMutation) ResetGoodID() {
	m.good_id = nil
}

// SetOnline sets the "online" field.
func (m *AppGoodMutation) SetOnline(b bool) {
	m.online = &b
}

// Online returns the value of the "online" field in the mutation.
func (m *AppGoodMutation) Online() (r bool, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// ClearOnline clears the value of the "online" field.
func (m *AppGoodMutation) ClearOnline() {
	m.online = nil
	m.clearedFields[appgood.FieldOnline] = struct{}{}
}

// OnlineCleared returns if the "online" field was cleared in this mutation.
func (m *AppGoodMutation) OnlineCleared() bool {
	_, ok := m.clearedFields[appgood.FieldOnline]
	return ok
}

// ResetOnline resets all changes to the "online" field.
func (m *AppGoodMutation) ResetOnline() {
	m.online = nil
	delete(m.clearedFields, appgood.FieldOnline)
}

// SetVisible sets the "visible" field.
func (m *AppGoodMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *AppGoodMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ClearVisible clears the value of the "visible" field.
func (m *AppGoodMutation) ClearVisible() {
	m.visible = nil
	m.clearedFields[appgood.FieldVisible] = struct{}{}
}

// VisibleCleared returns if the "visible" field was cleared in this mutation.
func (m *AppGoodMutation) VisibleCleared() bool {
	_, ok := m.clearedFields[appgood.FieldVisible]
	return ok
}

// ResetVisible resets all changes to the "visible" field.
func (m *AppGoodMutation) ResetVisible() {
	m.visible = nil
	delete(m.clearedFields, appgood.FieldVisible)
}

// SetGoodName sets the "good_name" field.
func (m *AppGoodMutation) SetGoodName(s string) {
	m.good_name = &s
}

// GoodName returns the value of the "good_name" field in the mutation.
func (m *AppGoodMutation) GoodName() (r string, exists bool) {
	v := m.good_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodName returns the old "good_name" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldGoodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodName: %w", err)
	}
	return oldValue.GoodName, nil
}

// ClearGoodName clears the value of the "good_name" field.
func (m *AppGoodMutation) ClearGoodName() {
	m.good_name = nil
	m.clearedFields[appgood.FieldGoodName] = struct{}{}
}

// GoodNameCleared returns if the "good_name" field was cleared in this mutation.
func (m *AppGoodMutation) GoodNameCleared() bool {
	_, ok := m.clearedFields[appgood.FieldGoodName]
	return ok
}

// ResetGoodName resets all changes to the "good_name" field.
func (m *AppGoodMutation) ResetGoodName() {
	m.good_name = nil
	delete(m.clearedFields, appgood.FieldGoodName)
}

// SetPrice sets the "price" field.
func (m *AppGoodMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *AppGoodMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *AppGoodMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[appgood.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *AppGoodMutation) PriceCleared() bool {
	_, ok := m.clearedFields[appgood.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *AppGoodMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, appgood.FieldPrice)
}

// SetDisplayIndex sets the "display_index" field.
func (m *AppGoodMutation) SetDisplayIndex(i int32) {
	m.display_index = &i
	m.adddisplay_index = nil
}

// DisplayIndex returns the value of the "display_index" field in the mutation.
func (m *AppGoodMutation) DisplayIndex() (r int32, exists bool) {
	v := m.display_index
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayIndex returns the old "display_index" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDisplayIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayIndex: %w", err)
	}
	return oldValue.DisplayIndex, nil
}

// AddDisplayIndex adds i to the "display_index" field.
func (m *AppGoodMutation) AddDisplayIndex(i int32) {
	if m.adddisplay_index != nil {
		*m.adddisplay_index += i
	} else {
		m.adddisplay_index = &i
	}
}

// AddedDisplayIndex returns the value that was added to the "display_index" field in this mutation.
func (m *AppGoodMutation) AddedDisplayIndex() (r int32, exists bool) {
	v := m.adddisplay_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplayIndex clears the value of the "display_index" field.
func (m *AppGoodMutation) ClearDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	m.clearedFields[appgood.FieldDisplayIndex] = struct{}{}
}

// DisplayIndexCleared returns if the "display_index" field was cleared in this mutation.
func (m *AppGoodMutation) DisplayIndexCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDisplayIndex]
	return ok
}

// ResetDisplayIndex resets all changes to the "display_index" field.
func (m *AppGoodMutation) ResetDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	delete(m.clearedFields, appgood.FieldDisplayIndex)
}

// SetPurchaseLimit sets the "purchase_limit" field.
func (m *AppGoodMutation) SetPurchaseLimit(i int32) {
	m.purchase_limit = &i
	m.addpurchase_limit = nil
}

// PurchaseLimit returns the value of the "purchase_limit" field in the mutation.
func (m *AppGoodMutation) PurchaseLimit() (r int32, exists bool) {
	v := m.purchase_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseLimit returns the old "purchase_limit" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldPurchaseLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseLimit: %w", err)
	}
	return oldValue.PurchaseLimit, nil
}

// AddPurchaseLimit adds i to the "purchase_limit" field.
func (m *AppGoodMutation) AddPurchaseLimit(i int32) {
	if m.addpurchase_limit != nil {
		*m.addpurchase_limit += i
	} else {
		m.addpurchase_limit = &i
	}
}

// AddedPurchaseLimit returns the value that was added to the "purchase_limit" field in this mutation.
func (m *AppGoodMutation) AddedPurchaseLimit() (r int32, exists bool) {
	v := m.addpurchase_limit
	if v == nil {
		return
	}
	return *v, true
}

// ClearPurchaseLimit clears the value of the "purchase_limit" field.
func (m *AppGoodMutation) ClearPurchaseLimit() {
	m.purchase_limit = nil
	m.addpurchase_limit = nil
	m.clearedFields[appgood.FieldPurchaseLimit] = struct{}{}
}

// PurchaseLimitCleared returns if the "purchase_limit" field was cleared in this mutation.
func (m *AppGoodMutation) PurchaseLimitCleared() bool {
	_, ok := m.clearedFields[appgood.FieldPurchaseLimit]
	return ok
}

// ResetPurchaseLimit resets all changes to the "purchase_limit" field.
func (m *AppGoodMutation) ResetPurchaseLimit() {
	m.purchase_limit = nil
	m.addpurchase_limit = nil
	delete(m.clearedFields, appgood.FieldPurchaseLimit)
}

// SetSaleStartAt sets the "sale_start_at" field.
func (m *AppGoodMutation) SetSaleStartAt(u uint32) {
	m.sale_start_at = &u
	m.addsale_start_at = nil
}

// SaleStartAt returns the value of the "sale_start_at" field in the mutation.
func (m *AppGoodMutation) SaleStartAt() (r uint32, exists bool) {
	v := m.sale_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleStartAt returns the old "sale_start_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldSaleStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleStartAt: %w", err)
	}
	return oldValue.SaleStartAt, nil
}

// AddSaleStartAt adds u to the "sale_start_at" field.
func (m *AppGoodMutation) AddSaleStartAt(u int32) {
	if m.addsale_start_at != nil {
		*m.addsale_start_at += u
	} else {
		m.addsale_start_at = &u
	}
}

// AddedSaleStartAt returns the value that was added to the "sale_start_at" field in this mutation.
func (m *AppGoodMutation) AddedSaleStartAt() (r int32, exists bool) {
	v := m.addsale_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaleStartAt clears the value of the "sale_start_at" field.
func (m *AppGoodMutation) ClearSaleStartAt() {
	m.sale_start_at = nil
	m.addsale_start_at = nil
	m.clearedFields[appgood.FieldSaleStartAt] = struct{}{}
}

// SaleStartAtCleared returns if the "sale_start_at" field was cleared in this mutation.
func (m *AppGoodMutation) SaleStartAtCleared() bool {
	_, ok := m.clearedFields[appgood.FieldSaleStartAt]
	return ok
}

// ResetSaleStartAt resets all changes to the "sale_start_at" field.
func (m *AppGoodMutation) ResetSaleStartAt() {
	m.sale_start_at = nil
	m.addsale_start_at = nil
	delete(m.clearedFields, appgood.FieldSaleStartAt)
}

// SetSaleEndAt sets the "sale_end_at" field.
func (m *AppGoodMutation) SetSaleEndAt(u uint32) {
	m.sale_end_at = &u
	m.addsale_end_at = nil
}

// SaleEndAt returns the value of the "sale_end_at" field in the mutation.
func (m *AppGoodMutation) SaleEndAt() (r uint32, exists bool) {
	v := m.sale_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleEndAt returns the old "sale_end_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldSaleEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleEndAt: %w", err)
	}
	return oldValue.SaleEndAt, nil
}

// AddSaleEndAt adds u to the "sale_end_at" field.
func (m *AppGoodMutation) AddSaleEndAt(u int32) {
	if m.addsale_end_at != nil {
		*m.addsale_end_at += u
	} else {
		m.addsale_end_at = &u
	}
}

// AddedSaleEndAt returns the value that was added to the "sale_end_at" field in this mutation.
func (m *AppGoodMutation) AddedSaleEndAt() (r int32, exists bool) {
	v := m.addsale_end_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaleEndAt clears the value of the "sale_end_at" field.
func (m *AppGoodMutation) ClearSaleEndAt() {
	m.sale_end_at = nil
	m.addsale_end_at = nil
	m.clearedFields[appgood.FieldSaleEndAt] = struct{}{}
}

// SaleEndAtCleared returns if the "sale_end_at" field was cleared in this mutation.
func (m *AppGoodMutation) SaleEndAtCleared() bool {
	_, ok := m.clearedFields[appgood.FieldSaleEndAt]
	return ok
}

// ResetSaleEndAt resets all changes to the "sale_end_at" field.
func (m *AppGoodMutation) ResetSaleEndAt() {
	m.sale_end_at = nil
	m.addsale_end_at = nil
	delete(m.clearedFields, appgood.FieldSaleEndAt)
}

// SetServiceStartAt sets the "service_start_at" field.
func (m *AppGoodMutation) SetServiceStartAt(u uint32) {
	m.service_start_at = &u
	m.addservice_start_at = nil
}

// ServiceStartAt returns the value of the "service_start_at" field in the mutation.
func (m *AppGoodMutation) ServiceStartAt() (r uint32, exists bool) {
	v := m.service_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceStartAt returns the old "service_start_at" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldServiceStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceStartAt: %w", err)
	}
	return oldValue.ServiceStartAt, nil
}

// AddServiceStartAt adds u to the "service_start_at" field.
func (m *AppGoodMutation) AddServiceStartAt(u int32) {
	if m.addservice_start_at != nil {
		*m.addservice_start_at += u
	} else {
		m.addservice_start_at = &u
	}
}

// AddedServiceStartAt returns the value that was added to the "service_start_at" field in this mutation.
func (m *AppGoodMutation) AddedServiceStartAt() (r int32, exists bool) {
	v := m.addservice_start_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearServiceStartAt clears the value of the "service_start_at" field.
func (m *AppGoodMutation) ClearServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	m.clearedFields[appgood.FieldServiceStartAt] = struct{}{}
}

// ServiceStartAtCleared returns if the "service_start_at" field was cleared in this mutation.
func (m *AppGoodMutation) ServiceStartAtCleared() bool {
	_, ok := m.clearedFields[appgood.FieldServiceStartAt]
	return ok
}

// ResetServiceStartAt resets all changes to the "service_start_at" field.
func (m *AppGoodMutation) ResetServiceStartAt() {
	m.service_start_at = nil
	m.addservice_start_at = nil
	delete(m.clearedFields, appgood.FieldServiceStartAt)
}

// SetDescriptions sets the "descriptions" field.
func (m *AppGoodMutation) SetDescriptions(s []string) {
	m.descriptions = &s
}

// Descriptions returns the value of the "descriptions" field in the mutation.
func (m *AppGoodMutation) Descriptions() (r []string, exists bool) {
	v := m.descriptions
	if v == nil {
		return
	}
	return *v, true
}

// OldDescriptions returns the old "descriptions" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDescriptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescriptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescriptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescriptions: %w", err)
	}
	return oldValue.Descriptions, nil
}

// ClearDescriptions clears the value of the "descriptions" field.
func (m *AppGoodMutation) ClearDescriptions() {
	m.descriptions = nil
	m.clearedFields[appgood.FieldDescriptions] = struct{}{}
}

// DescriptionsCleared returns if the "descriptions" field was cleared in this mutation.
func (m *AppGoodMutation) DescriptionsCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDescriptions]
	return ok
}

// ResetDescriptions resets all changes to the "descriptions" field.
func (m *AppGoodMutation) ResetDescriptions() {
	m.descriptions = nil
	delete(m.clearedFields, appgood.FieldDescriptions)
}

// SetGoodBanner sets the "good_banner" field.
func (m *AppGoodMutation) SetGoodBanner(s string) {
	m.good_banner = &s
}

// GoodBanner returns the value of the "good_banner" field in the mutation.
func (m *AppGoodMutation) GoodBanner() (r string, exists bool) {
	v := m.good_banner
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodBanner returns the old "good_banner" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldGoodBanner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodBanner: %w", err)
	}
	return oldValue.GoodBanner, nil
}

// ClearGoodBanner clears the value of the "good_banner" field.
func (m *AppGoodMutation) ClearGoodBanner() {
	m.good_banner = nil
	m.clearedFields[appgood.FieldGoodBanner] = struct{}{}
}

// GoodBannerCleared returns if the "good_banner" field was cleared in this mutation.
func (m *AppGoodMutation) GoodBannerCleared() bool {
	_, ok := m.clearedFields[appgood.FieldGoodBanner]
	return ok
}

// ResetGoodBanner resets all changes to the "good_banner" field.
func (m *AppGoodMutation) ResetGoodBanner() {
	m.good_banner = nil
	delete(m.clearedFields, appgood.FieldGoodBanner)
}

// SetDisplayNames sets the "display_names" field.
func (m *AppGoodMutation) SetDisplayNames(s []string) {
	m.display_names = &s
}

// DisplayNames returns the value of the "display_names" field in the mutation.
func (m *AppGoodMutation) DisplayNames() (r []string, exists bool) {
	v := m.display_names
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayNames returns the old "display_names" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDisplayNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayNames: %w", err)
	}
	return oldValue.DisplayNames, nil
}

// ClearDisplayNames clears the value of the "display_names" field.
func (m *AppGoodMutation) ClearDisplayNames() {
	m.display_names = nil
	m.clearedFields[appgood.FieldDisplayNames] = struct{}{}
}

// DisplayNamesCleared returns if the "display_names" field was cleared in this mutation.
func (m *AppGoodMutation) DisplayNamesCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDisplayNames]
	return ok
}

// ResetDisplayNames resets all changes to the "display_names" field.
func (m *AppGoodMutation) ResetDisplayNames() {
	m.display_names = nil
	delete(m.clearedFields, appgood.FieldDisplayNames)
}

// SetEnablePurchase sets the "enable_purchase" field.
func (m *AppGoodMutation) SetEnablePurchase(b bool) {
	m.enable_purchase = &b
}

// EnablePurchase returns the value of the "enable_purchase" field in the mutation.
func (m *AppGoodMutation) EnablePurchase() (r bool, exists bool) {
	v := m.enable_purchase
	if v == nil {
		return
	}
	return *v, true
}

// OldEnablePurchase returns the old "enable_purchase" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEnablePurchase(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnablePurchase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnablePurchase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnablePurchase: %w", err)
	}
	return oldValue.EnablePurchase, nil
}

// ClearEnablePurchase clears the value of the "enable_purchase" field.
func (m *AppGoodMutation) ClearEnablePurchase() {
	m.enable_purchase = nil
	m.clearedFields[appgood.FieldEnablePurchase] = struct{}{}
}

// EnablePurchaseCleared returns if the "enable_purchase" field was cleared in this mutation.
func (m *AppGoodMutation) EnablePurchaseCleared() bool {
	_, ok := m.clearedFields[appgood.FieldEnablePurchase]
	return ok
}

// ResetEnablePurchase resets all changes to the "enable_purchase" field.
func (m *AppGoodMutation) ResetEnablePurchase() {
	m.enable_purchase = nil
	delete(m.clearedFields, appgood.FieldEnablePurchase)
}

// SetEnableProductPage sets the "enable_product_page" field.
func (m *AppGoodMutation) SetEnableProductPage(b bool) {
	m.enable_product_page = &b
}

// EnableProductPage returns the value of the "enable_product_page" field in the mutation.
func (m *AppGoodMutation) EnableProductPage() (r bool, exists bool) {
	v := m.enable_product_page
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableProductPage returns the old "enable_product_page" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEnableProductPage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableProductPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableProductPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableProductPage: %w", err)
	}
	return oldValue.EnableProductPage, nil
}

// ClearEnableProductPage clears the value of the "enable_product_page" field.
func (m *AppGoodMutation) ClearEnableProductPage() {
	m.enable_product_page = nil
	m.clearedFields[appgood.FieldEnableProductPage] = struct{}{}
}

// EnableProductPageCleared returns if the "enable_product_page" field was cleared in this mutation.
func (m *AppGoodMutation) EnableProductPageCleared() bool {
	_, ok := m.clearedFields[appgood.FieldEnableProductPage]
	return ok
}

// ResetEnableProductPage resets all changes to the "enable_product_page" field.
func (m *AppGoodMutation) ResetEnableProductPage() {
	m.enable_product_page = nil
	delete(m.clearedFields, appgood.FieldEnableProductPage)
}

// SetCancelMode sets the "cancel_mode" field.
func (m *AppGoodMutation) SetCancelMode(s string) {
	m.cancel_mode = &s
}

// CancelMode returns the value of the "cancel_mode" field in the mutation.
func (m *AppGoodMutation) CancelMode() (r string, exists bool) {
	v := m.cancel_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelMode returns the old "cancel_mode" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldCancelMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelMode: %w", err)
	}
	return oldValue.CancelMode, nil
}

// ClearCancelMode clears the value of the "cancel_mode" field.
func (m *AppGoodMutation) ClearCancelMode() {
	m.cancel_mode = nil
	m.clearedFields[appgood.FieldCancelMode] = struct{}{}
}

// CancelModeCleared returns if the "cancel_mode" field was cleared in this mutation.
func (m *AppGoodMutation) CancelModeCleared() bool {
	_, ok := m.clearedFields[appgood.FieldCancelMode]
	return ok
}

// ResetCancelMode resets all changes to the "cancel_mode" field.
func (m *AppGoodMutation) ResetCancelMode() {
	m.cancel_mode = nil
	delete(m.clearedFields, appgood.FieldCancelMode)
}

// SetUserPurchaseLimit sets the "user_purchase_limit" field.
func (m *AppGoodMutation) SetUserPurchaseLimit(d decimal.Decimal) {
	m.user_purchase_limit = &d
}

// UserPurchaseLimit returns the value of the "user_purchase_limit" field in the mutation.
func (m *AppGoodMutation) UserPurchaseLimit() (r decimal.Decimal, exists bool) {
	v := m.user_purchase_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldUserPurchaseLimit returns the old "user_purchase_limit" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldUserPurchaseLimit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserPurchaseLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserPurchaseLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserPurchaseLimit: %w", err)
	}
	return oldValue.UserPurchaseLimit, nil
}

// ClearUserPurchaseLimit clears the value of the "user_purchase_limit" field.
func (m *AppGoodMutation) ClearUserPurchaseLimit() {
	m.user_purchase_limit = nil
	m.clearedFields[appgood.FieldUserPurchaseLimit] = struct{}{}
}

// UserPurchaseLimitCleared returns if the "user_purchase_limit" field was cleared in this mutation.
func (m *AppGoodMutation) UserPurchaseLimitCleared() bool {
	_, ok := m.clearedFields[appgood.FieldUserPurchaseLimit]
	return ok
}

// ResetUserPurchaseLimit resets all changes to the "user_purchase_limit" field.
func (m *AppGoodMutation) ResetUserPurchaseLimit() {
	m.user_purchase_limit = nil
	delete(m.clearedFields, appgood.FieldUserPurchaseLimit)
}

// SetDisplayColors sets the "display_colors" field.
func (m *AppGoodMutation) SetDisplayColors(s []string) {
	m.display_colors = &s
}

// DisplayColors returns the value of the "display_colors" field in the mutation.
func (m *AppGoodMutation) DisplayColors() (r []string, exists bool) {
	v := m.display_colors
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayColors returns the old "display_colors" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldDisplayColors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayColors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayColors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayColors: %w", err)
	}
	return oldValue.DisplayColors, nil
}

// ClearDisplayColors clears the value of the "display_colors" field.
func (m *AppGoodMutation) ClearDisplayColors() {
	m.display_colors = nil
	m.clearedFields[appgood.FieldDisplayColors] = struct{}{}
}

// DisplayColorsCleared returns if the "display_colors" field was cleared in this mutation.
func (m *AppGoodMutation) DisplayColorsCleared() bool {
	_, ok := m.clearedFields[appgood.FieldDisplayColors]
	return ok
}

// ResetDisplayColors resets all changes to the "display_colors" field.
func (m *AppGoodMutation) ResetDisplayColors() {
	m.display_colors = nil
	delete(m.clearedFields, appgood.FieldDisplayColors)
}

// SetCancellableBeforeStart sets the "cancellable_before_start" field.
func (m *AppGoodMutation) SetCancellableBeforeStart(u uint32) {
	m.cancellable_before_start = &u
	m.addcancellable_before_start = nil
}

// CancellableBeforeStart returns the value of the "cancellable_before_start" field in the mutation.
func (m *AppGoodMutation) CancellableBeforeStart() (r uint32, exists bool) {
	v := m.cancellable_before_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCancellableBeforeStart returns the old "cancellable_before_start" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldCancellableBeforeStart(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancellableBeforeStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancellableBeforeStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancellableBeforeStart: %w", err)
	}
	return oldValue.CancellableBeforeStart, nil
}

// AddCancellableBeforeStart adds u to the "cancellable_before_start" field.
func (m *AppGoodMutation) AddCancellableBeforeStart(u int32) {
	if m.addcancellable_before_start != nil {
		*m.addcancellable_before_start += u
	} else {
		m.addcancellable_before_start = &u
	}
}

// AddedCancellableBeforeStart returns the value that was added to the "cancellable_before_start" field in this mutation.
func (m *AppGoodMutation) AddedCancellableBeforeStart() (r int32, exists bool) {
	v := m.addcancellable_before_start
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancellableBeforeStart clears the value of the "cancellable_before_start" field.
func (m *AppGoodMutation) ClearCancellableBeforeStart() {
	m.cancellable_before_start = nil
	m.addcancellable_before_start = nil
	m.clearedFields[appgood.FieldCancellableBeforeStart] = struct{}{}
}

// CancellableBeforeStartCleared returns if the "cancellable_before_start" field was cleared in this mutation.
func (m *AppGoodMutation) CancellableBeforeStartCleared() bool {
	_, ok := m.clearedFields[appgood.FieldCancellableBeforeStart]
	return ok
}

// ResetCancellableBeforeStart resets all changes to the "cancellable_before_start" field.
func (m *AppGoodMutation) ResetCancellableBeforeStart() {
	m.cancellable_before_start = nil
	m.addcancellable_before_start = nil
	delete(m.clearedFields, appgood.FieldCancellableBeforeStart)
}

// SetProductPage sets the "product_page" field.
func (m *AppGoodMutation) SetProductPage(s string) {
	m.product_page = &s
}

// ProductPage returns the value of the "product_page" field in the mutation.
func (m *AppGoodMutation) ProductPage() (r string, exists bool) {
	v := m.product_page
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPage returns the old "product_page" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldProductPage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPage: %w", err)
	}
	return oldValue.ProductPage, nil
}

// ClearProductPage clears the value of the "product_page" field.
func (m *AppGoodMutation) ClearProductPage() {
	m.product_page = nil
	m.clearedFields[appgood.FieldProductPage] = struct{}{}
}

// ProductPageCleared returns if the "product_page" field was cleared in this mutation.
func (m *AppGoodMutation) ProductPageCleared() bool {
	_, ok := m.clearedFields[appgood.FieldProductPage]
	return ok
}

// ResetProductPage resets all changes to the "product_page" field.
func (m *AppGoodMutation) ResetProductPage() {
	m.product_page = nil
	delete(m.clearedFields, appgood.FieldProductPage)
}

// SetEnableSetCommission sets the "enable_set_commission" field.
func (m *AppGoodMutation) SetEnableSetCommission(b bool) {
	m.enable_set_commission = &b
}

// EnableSetCommission returns the value of the "enable_set_commission" field in the mutation.
func (m *AppGoodMutation) EnableSetCommission() (r bool, exists bool) {
	v := m.enable_set_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableSetCommission returns the old "enable_set_commission" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldEnableSetCommission(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableSetCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableSetCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableSetCommission: %w", err)
	}
	return oldValue.EnableSetCommission, nil
}

// ClearEnableSetCommission clears the value of the "enable_set_commission" field.
func (m *AppGoodMutation) ClearEnableSetCommission() {
	m.enable_set_commission = nil
	m.clearedFields[appgood.FieldEnableSetCommission] = struct{}{}
}

// EnableSetCommissionCleared returns if the "enable_set_commission" field was cleared in this mutation.
func (m *AppGoodMutation) EnableSetCommissionCleared() bool {
	_, ok := m.clearedFields[appgood.FieldEnableSetCommission]
	return ok
}

// ResetEnableSetCommission resets all changes to the "enable_set_commission" field.
func (m *AppGoodMutation) ResetEnableSetCommission() {
	m.enable_set_commission = nil
	delete(m.clearedFields, appgood.FieldEnableSetCommission)
}

// SetPosters sets the "posters" field.
func (m *AppGoodMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *AppGoodMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the AppGood entity.
// If the AppGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppGoodMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *AppGoodMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[appgood.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *AppGoodMutation) PostersCleared() bool {
	_, ok := m.clearedFields[appgood.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *AppGoodMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, appgood.FieldPosters)
}

// Where appends a list predicates to the AppGoodMutation builder.
func (m *AppGoodMutation) Where(ps ...predicate.AppGood) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppGoodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppGood).
func (m *AppGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppGoodMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, appgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appgood.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appgood.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appgood.FieldGoodID)
	}
	if m.online != nil {
		fields = append(fields, appgood.FieldOnline)
	}
	if m.visible != nil {
		fields = append(fields, appgood.FieldVisible)
	}
	if m.good_name != nil {
		fields = append(fields, appgood.FieldGoodName)
	}
	if m.price != nil {
		fields = append(fields, appgood.FieldPrice)
	}
	if m.display_index != nil {
		fields = append(fields, appgood.FieldDisplayIndex)
	}
	if m.purchase_limit != nil {
		fields = append(fields, appgood.FieldPurchaseLimit)
	}
	if m.sale_start_at != nil {
		fields = append(fields, appgood.FieldSaleStartAt)
	}
	if m.sale_end_at != nil {
		fields = append(fields, appgood.FieldSaleEndAt)
	}
	if m.service_start_at != nil {
		fields = append(fields, appgood.FieldServiceStartAt)
	}
	if m.descriptions != nil {
		fields = append(fields, appgood.FieldDescriptions)
	}
	if m.good_banner != nil {
		fields = append(fields, appgood.FieldGoodBanner)
	}
	if m.display_names != nil {
		fields = append(fields, appgood.FieldDisplayNames)
	}
	if m.enable_purchase != nil {
		fields = append(fields, appgood.FieldEnablePurchase)
	}
	if m.enable_product_page != nil {
		fields = append(fields, appgood.FieldEnableProductPage)
	}
	if m.cancel_mode != nil {
		fields = append(fields, appgood.FieldCancelMode)
	}
	if m.user_purchase_limit != nil {
		fields = append(fields, appgood.FieldUserPurchaseLimit)
	}
	if m.display_colors != nil {
		fields = append(fields, appgood.FieldDisplayColors)
	}
	if m.cancellable_before_start != nil {
		fields = append(fields, appgood.FieldCancellableBeforeStart)
	}
	if m.product_page != nil {
		fields = append(fields, appgood.FieldProductPage)
	}
	if m.enable_set_commission != nil {
		fields = append(fields, appgood.FieldEnableSetCommission)
	}
	if m.posters != nil {
		fields = append(fields, appgood.FieldPosters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appgood.FieldCreatedAt:
		return m.CreatedAt()
	case appgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case appgood.FieldDeletedAt:
		return m.DeletedAt()
	case appgood.FieldAppID:
		return m.AppID()
	case appgood.FieldGoodID:
		return m.GoodID()
	case appgood.FieldOnline:
		return m.Online()
	case appgood.FieldVisible:
		return m.Visible()
	case appgood.FieldGoodName:
		return m.GoodName()
	case appgood.FieldPrice:
		return m.Price()
	case appgood.FieldDisplayIndex:
		return m.DisplayIndex()
	case appgood.FieldPurchaseLimit:
		return m.PurchaseLimit()
	case appgood.FieldSaleStartAt:
		return m.SaleStartAt()
	case appgood.FieldSaleEndAt:
		return m.SaleEndAt()
	case appgood.FieldServiceStartAt:
		return m.ServiceStartAt()
	case appgood.FieldDescriptions:
		return m.Descriptions()
	case appgood.FieldGoodBanner:
		return m.GoodBanner()
	case appgood.FieldDisplayNames:
		return m.DisplayNames()
	case appgood.FieldEnablePurchase:
		return m.EnablePurchase()
	case appgood.FieldEnableProductPage:
		return m.EnableProductPage()
	case appgood.FieldCancelMode:
		return m.CancelMode()
	case appgood.FieldUserPurchaseLimit:
		return m.UserPurchaseLimit()
	case appgood.FieldDisplayColors:
		return m.DisplayColors()
	case appgood.FieldCancellableBeforeStart:
		return m.CancellableBeforeStart()
	case appgood.FieldProductPage:
		return m.ProductPage()
	case appgood.FieldEnableSetCommission:
		return m.EnableSetCommission()
	case appgood.FieldPosters:
		return m.Posters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appgood.FieldAppID:
		return m.OldAppID(ctx)
	case appgood.FieldGoodID:
		return m.OldGoodID(ctx)
	case appgood.FieldOnline:
		return m.OldOnline(ctx)
	case appgood.FieldVisible:
		return m.OldVisible(ctx)
	case appgood.FieldGoodName:
		return m.OldGoodName(ctx)
	case appgood.FieldPrice:
		return m.OldPrice(ctx)
	case appgood.FieldDisplayIndex:
		return m.OldDisplayIndex(ctx)
	case appgood.FieldPurchaseLimit:
		return m.OldPurchaseLimit(ctx)
	case appgood.FieldSaleStartAt:
		return m.OldSaleStartAt(ctx)
	case appgood.FieldSaleEndAt:
		return m.OldSaleEndAt(ctx)
	case appgood.FieldServiceStartAt:
		return m.OldServiceStartAt(ctx)
	case appgood.FieldDescriptions:
		return m.OldDescriptions(ctx)
	case appgood.FieldGoodBanner:
		return m.OldGoodBanner(ctx)
	case appgood.FieldDisplayNames:
		return m.OldDisplayNames(ctx)
	case appgood.FieldEnablePurchase:
		return m.OldEnablePurchase(ctx)
	case appgood.FieldEnableProductPage:
		return m.OldEnableProductPage(ctx)
	case appgood.FieldCancelMode:
		return m.OldCancelMode(ctx)
	case appgood.FieldUserPurchaseLimit:
		return m.OldUserPurchaseLimit(ctx)
	case appgood.FieldDisplayColors:
		return m.OldDisplayColors(ctx)
	case appgood.FieldCancellableBeforeStart:
		return m.OldCancellableBeforeStart(ctx)
	case appgood.FieldProductPage:
		return m.OldProductPage(ctx)
	case appgood.FieldEnableSetCommission:
		return m.OldEnableSetCommission(ctx)
	case appgood.FieldPosters:
		return m.OldPosters(ctx)
	}
	return nil, fmt.Errorf("unknown AppGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appgood.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appgood.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appgood.FieldOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case appgood.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	case appgood.FieldGoodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodName(v)
		return nil
	case appgood.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case appgood.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayIndex(v)
		return nil
	case appgood.FieldPurchaseLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseLimit(v)
		return nil
	case appgood.FieldSaleStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleStartAt(v)
		return nil
	case appgood.FieldSaleEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleEndAt(v)
		return nil
	case appgood.FieldServiceStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceStartAt(v)
		return nil
	case appgood.FieldDescriptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescriptions(v)
		return nil
	case appgood.FieldGoodBanner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodBanner(v)
		return nil
	case appgood.FieldDisplayNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayNames(v)
		return nil
	case appgood.FieldEnablePurchase:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnablePurchase(v)
		return nil
	case appgood.FieldEnableProductPage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableProductPage(v)
		return nil
	case appgood.FieldCancelMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelMode(v)
		return nil
	case appgood.FieldUserPurchaseLimit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserPurchaseLimit(v)
		return nil
	case appgood.FieldDisplayColors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayColors(v)
		return nil
	case appgood.FieldCancellableBeforeStart:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancellableBeforeStart(v)
		return nil
	case appgood.FieldProductPage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPage(v)
		return nil
	case appgood.FieldEnableSetCommission:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableSetCommission(v)
		return nil
	case appgood.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	}
	return fmt.Errorf("unknown AppGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appgood.FieldDeletedAt)
	}
	if m.adddisplay_index != nil {
		fields = append(fields, appgood.FieldDisplayIndex)
	}
	if m.addpurchase_limit != nil {
		fields = append(fields, appgood.FieldPurchaseLimit)
	}
	if m.addsale_start_at != nil {
		fields = append(fields, appgood.FieldSaleStartAt)
	}
	if m.addsale_end_at != nil {
		fields = append(fields, appgood.FieldSaleEndAt)
	}
	if m.addservice_start_at != nil {
		fields = append(fields, appgood.FieldServiceStartAt)
	}
	if m.addcancellable_before_start != nil {
		fields = append(fields, appgood.FieldCancellableBeforeStart)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appgood.FieldDisplayIndex:
		return m.AddedDisplayIndex()
	case appgood.FieldPurchaseLimit:
		return m.AddedPurchaseLimit()
	case appgood.FieldSaleStartAt:
		return m.AddedSaleStartAt()
	case appgood.FieldSaleEndAt:
		return m.AddedSaleEndAt()
	case appgood.FieldServiceStartAt:
		return m.AddedServiceStartAt()
	case appgood.FieldCancellableBeforeStart:
		return m.AddedCancellableBeforeStart()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appgood.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayIndex(v)
		return nil
	case appgood.FieldPurchaseLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchaseLimit(v)
		return nil
	case appgood.FieldSaleStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleStartAt(v)
		return nil
	case appgood.FieldSaleEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleEndAt(v)
		return nil
	case appgood.FieldServiceStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceStartAt(v)
		return nil
	case appgood.FieldCancellableBeforeStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancellableBeforeStart(v)
		return nil
	}
	return fmt.Errorf("unknown AppGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appgood.FieldOnline) {
		fields = append(fields, appgood.FieldOnline)
	}
	if m.FieldCleared(appgood.FieldVisible) {
		fields = append(fields, appgood.FieldVisible)
	}
	if m.FieldCleared(appgood.FieldGoodName) {
		fields = append(fields, appgood.FieldGoodName)
	}
	if m.FieldCleared(appgood.FieldPrice) {
		fields = append(fields, appgood.FieldPrice)
	}
	if m.FieldCleared(appgood.FieldDisplayIndex) {
		fields = append(fields, appgood.FieldDisplayIndex)
	}
	if m.FieldCleared(appgood.FieldPurchaseLimit) {
		fields = append(fields, appgood.FieldPurchaseLimit)
	}
	if m.FieldCleared(appgood.FieldSaleStartAt) {
		fields = append(fields, appgood.FieldSaleStartAt)
	}
	if m.FieldCleared(appgood.FieldSaleEndAt) {
		fields = append(fields, appgood.FieldSaleEndAt)
	}
	if m.FieldCleared(appgood.FieldServiceStartAt) {
		fields = append(fields, appgood.FieldServiceStartAt)
	}
	if m.FieldCleared(appgood.FieldDescriptions) {
		fields = append(fields, appgood.FieldDescriptions)
	}
	if m.FieldCleared(appgood.FieldGoodBanner) {
		fields = append(fields, appgood.FieldGoodBanner)
	}
	if m.FieldCleared(appgood.FieldDisplayNames) {
		fields = append(fields, appgood.FieldDisplayNames)
	}
	if m.FieldCleared(appgood.FieldEnablePurchase) {
		fields = append(fields, appgood.FieldEnablePurchase)
	}
	if m.FieldCleared(appgood.FieldEnableProductPage) {
		fields = append(fields, appgood.FieldEnableProductPage)
	}
	if m.FieldCleared(appgood.FieldCancelMode) {
		fields = append(fields, appgood.FieldCancelMode)
	}
	if m.FieldCleared(appgood.FieldUserPurchaseLimit) {
		fields = append(fields, appgood.FieldUserPurchaseLimit)
	}
	if m.FieldCleared(appgood.FieldDisplayColors) {
		fields = append(fields, appgood.FieldDisplayColors)
	}
	if m.FieldCleared(appgood.FieldCancellableBeforeStart) {
		fields = append(fields, appgood.FieldCancellableBeforeStart)
	}
	if m.FieldCleared(appgood.FieldProductPage) {
		fields = append(fields, appgood.FieldProductPage)
	}
	if m.FieldCleared(appgood.FieldEnableSetCommission) {
		fields = append(fields, appgood.FieldEnableSetCommission)
	}
	if m.FieldCleared(appgood.FieldPosters) {
		fields = append(fields, appgood.FieldPosters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppGoodMutation) ClearField(name string) error {
	switch name {
	case appgood.FieldOnline:
		m.ClearOnline()
		return nil
	case appgood.FieldVisible:
		m.ClearVisible()
		return nil
	case appgood.FieldGoodName:
		m.ClearGoodName()
		return nil
	case appgood.FieldPrice:
		m.ClearPrice()
		return nil
	case appgood.FieldDisplayIndex:
		m.ClearDisplayIndex()
		return nil
	case appgood.FieldPurchaseLimit:
		m.ClearPurchaseLimit()
		return nil
	case appgood.FieldSaleStartAt:
		m.ClearSaleStartAt()
		return nil
	case appgood.FieldSaleEndAt:
		m.ClearSaleEndAt()
		return nil
	case appgood.FieldServiceStartAt:
		m.ClearServiceStartAt()
		return nil
	case appgood.FieldDescriptions:
		m.ClearDescriptions()
		return nil
	case appgood.FieldGoodBanner:
		m.ClearGoodBanner()
		return nil
	case appgood.FieldDisplayNames:
		m.ClearDisplayNames()
		return nil
	case appgood.FieldEnablePurchase:
		m.ClearEnablePurchase()
		return nil
	case appgood.FieldEnableProductPage:
		m.ClearEnableProductPage()
		return nil
	case appgood.FieldCancelMode:
		m.ClearCancelMode()
		return nil
	case appgood.FieldUserPurchaseLimit:
		m.ClearUserPurchaseLimit()
		return nil
	case appgood.FieldDisplayColors:
		m.ClearDisplayColors()
		return nil
	case appgood.FieldCancellableBeforeStart:
		m.ClearCancellableBeforeStart()
		return nil
	case appgood.FieldProductPage:
		m.ClearProductPage()
		return nil
	case appgood.FieldEnableSetCommission:
		m.ClearEnableSetCommission()
		return nil
	case appgood.FieldPosters:
		m.ClearPosters()
		return nil
	}
	return fmt.Errorf("unknown AppGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppGoodMutation) ResetField(name string) error {
	switch name {
	case appgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appgood.FieldAppID:
		m.ResetAppID()
		return nil
	case appgood.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appgood.FieldOnline:
		m.ResetOnline()
		return nil
	case appgood.FieldVisible:
		m.ResetVisible()
		return nil
	case appgood.FieldGoodName:
		m.ResetGoodName()
		return nil
	case appgood.FieldPrice:
		m.ResetPrice()
		return nil
	case appgood.FieldDisplayIndex:
		m.ResetDisplayIndex()
		return nil
	case appgood.FieldPurchaseLimit:
		m.ResetPurchaseLimit()
		return nil
	case appgood.FieldSaleStartAt:
		m.ResetSaleStartAt()
		return nil
	case appgood.FieldSaleEndAt:
		m.ResetSaleEndAt()
		return nil
	case appgood.FieldServiceStartAt:
		m.ResetServiceStartAt()
		return nil
	case appgood.FieldDescriptions:
		m.ResetDescriptions()
		return nil
	case appgood.FieldGoodBanner:
		m.ResetGoodBanner()
		return nil
	case appgood.FieldDisplayNames:
		m.ResetDisplayNames()
		return nil
	case appgood.FieldEnablePurchase:
		m.ResetEnablePurchase()
		return nil
	case appgood.FieldEnableProductPage:
		m.ResetEnableProductPage()
		return nil
	case appgood.FieldCancelMode:
		m.ResetCancelMode()
		return nil
	case appgood.FieldUserPurchaseLimit:
		m.ResetUserPurchaseLimit()
		return nil
	case appgood.FieldDisplayColors:
		m.ResetDisplayColors()
		return nil
	case appgood.FieldCancellableBeforeStart:
		m.ResetCancellableBeforeStart()
		return nil
	case appgood.FieldProductPage:
		m.ResetProductPage()
		return nil
	case appgood.FieldEnableSetCommission:
		m.ResetEnableSetCommission()
		return nil
	case appgood.FieldPosters:
		m.ResetPosters()
		return nil
	}
	return fmt.Errorf("unknown AppGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppGood edge %s", name)
}

// AppStockMutation represents an operation that mutates the AppStock nodes in the graph.
type AppStockMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	good_id       *uuid.UUID
	app_good_id   *uuid.UUID
	reserved      *decimal.Decimal
	spot_quantity *decimal.Decimal
	locked        *decimal.Decimal
	in_service    *decimal.Decimal
	wait_start    *decimal.Decimal
	sold          *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppStock, error)
	predicates    []predicate.AppStock
}

var _ ent.Mutation = (*AppStockMutation)(nil)

// appstockOption allows management of the mutation configuration using functional options.
type appstockOption func(*AppStockMutation)

// newAppStockMutation creates new mutation for the AppStock entity.
func newAppStockMutation(c config, op Op, opts ...appstockOption) *AppStockMutation {
	m := &AppStockMutation{
		config:        c,
		op:            op,
		typ:           TypeAppStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppStockID sets the ID field of the mutation.
func withAppStockID(id uuid.UUID) appstockOption {
	return func(m *AppStockMutation) {
		var (
			err   error
			once  sync.Once
			value *AppStock
		)
		m.oldValue = func(ctx context.Context) (*AppStock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppStock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppStock sets the old AppStock of the mutation.
func withAppStock(node *AppStock) appstockOption {
	return func(m *AppStockMutation) {
		m.oldValue = func(context.Context) (*AppStock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppStockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppStockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppStock entities.
func (m *AppStockMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppStockMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppStockMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppStock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppStockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppStockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppStockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppStockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppStockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppStockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppStockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppStockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppStockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppStockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppStockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppStockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppStockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppStockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppStockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppStockMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppStockMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppStockMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appstock.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppStockMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appstock.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppStockMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appstock.FieldAppID)
}

// SetGoodID sets the "good_id" field.
func (m *AppStockMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AppStockMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *AppStockMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[appstock.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *AppStockMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[appstock.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AppStockMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, appstock.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AppStockMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AppStockMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AppStockMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[appstock.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AppStockMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[appstock.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AppStockMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, appstock.FieldAppGoodID)
}

// SetReserved sets the "reserved" field.
func (m *AppStockMutation) SetReserved(d decimal.Decimal) {
	m.reserved = &d
}

// Reserved returns the value of the "reserved" field in the mutation.
func (m *AppStockMutation) Reserved() (r decimal.Decimal, exists bool) {
	v := m.reserved
	if v == nil {
		return
	}
	return *v, true
}

// OldReserved returns the old "reserved" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldReserved(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReserved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReserved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserved: %w", err)
	}
	return oldValue.Reserved, nil
}

// ClearReserved clears the value of the "reserved" field.
func (m *AppStockMutation) ClearReserved() {
	m.reserved = nil
	m.clearedFields[appstock.FieldReserved] = struct{}{}
}

// ReservedCleared returns if the "reserved" field was cleared in this mutation.
func (m *AppStockMutation) ReservedCleared() bool {
	_, ok := m.clearedFields[appstock.FieldReserved]
	return ok
}

// ResetReserved resets all changes to the "reserved" field.
func (m *AppStockMutation) ResetReserved() {
	m.reserved = nil
	delete(m.clearedFields, appstock.FieldReserved)
}

// SetSpotQuantity sets the "spot_quantity" field.
func (m *AppStockMutation) SetSpotQuantity(d decimal.Decimal) {
	m.spot_quantity = &d
}

// SpotQuantity returns the value of the "spot_quantity" field in the mutation.
func (m *AppStockMutation) SpotQuantity() (r decimal.Decimal, exists bool) {
	v := m.spot_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotQuantity returns the old "spot_quantity" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldSpotQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotQuantity: %w", err)
	}
	return oldValue.SpotQuantity, nil
}

// ClearSpotQuantity clears the value of the "spot_quantity" field.
func (m *AppStockMutation) ClearSpotQuantity() {
	m.spot_quantity = nil
	m.clearedFields[appstock.FieldSpotQuantity] = struct{}{}
}

// SpotQuantityCleared returns if the "spot_quantity" field was cleared in this mutation.
func (m *AppStockMutation) SpotQuantityCleared() bool {
	_, ok := m.clearedFields[appstock.FieldSpotQuantity]
	return ok
}

// ResetSpotQuantity resets all changes to the "spot_quantity" field.
func (m *AppStockMutation) ResetSpotQuantity() {
	m.spot_quantity = nil
	delete(m.clearedFields, appstock.FieldSpotQuantity)
}

// SetLocked sets the "locked" field.
func (m *AppStockMutation) SetLocked(d decimal.Decimal) {
	m.locked = &d
}

// Locked returns the value of the "locked" field in the mutation.
func (m *AppStockMutation) Locked() (r decimal.Decimal, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ClearLocked clears the value of the "locked" field.
func (m *AppStockMutation) ClearLocked() {
	m.locked = nil
	m.clearedFields[appstock.FieldLocked] = struct{}{}
}

// LockedCleared returns if the "locked" field was cleared in this mutation.
func (m *AppStockMutation) LockedCleared() bool {
	_, ok := m.clearedFields[appstock.FieldLocked]
	return ok
}

// ResetLocked resets all changes to the "locked" field.
func (m *AppStockMutation) ResetLocked() {
	m.locked = nil
	delete(m.clearedFields, appstock.FieldLocked)
}

// SetInService sets the "in_service" field.
func (m *AppStockMutation) SetInService(d decimal.Decimal) {
	m.in_service = &d
}

// InService returns the value of the "in_service" field in the mutation.
func (m *AppStockMutation) InService() (r decimal.Decimal, exists bool) {
	v := m.in_service
	if v == nil {
		return
	}
	return *v, true
}

// OldInService returns the old "in_service" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldInService(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInService: %w", err)
	}
	return oldValue.InService, nil
}

// ClearInService clears the value of the "in_service" field.
func (m *AppStockMutation) ClearInService() {
	m.in_service = nil
	m.clearedFields[appstock.FieldInService] = struct{}{}
}

// InServiceCleared returns if the "in_service" field was cleared in this mutation.
func (m *AppStockMutation) InServiceCleared() bool {
	_, ok := m.clearedFields[appstock.FieldInService]
	return ok
}

// ResetInService resets all changes to the "in_service" field.
func (m *AppStockMutation) ResetInService() {
	m.in_service = nil
	delete(m.clearedFields, appstock.FieldInService)
}

// SetWaitStart sets the "wait_start" field.
func (m *AppStockMutation) SetWaitStart(d decimal.Decimal) {
	m.wait_start = &d
}

// WaitStart returns the value of the "wait_start" field in the mutation.
func (m *AppStockMutation) WaitStart() (r decimal.Decimal, exists bool) {
	v := m.wait_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWaitStart returns the old "wait_start" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldWaitStart(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaitStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaitStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaitStart: %w", err)
	}
	return oldValue.WaitStart, nil
}

// ClearWaitStart clears the value of the "wait_start" field.
func (m *AppStockMutation) ClearWaitStart() {
	m.wait_start = nil
	m.clearedFields[appstock.FieldWaitStart] = struct{}{}
}

// WaitStartCleared returns if the "wait_start" field was cleared in this mutation.
func (m *AppStockMutation) WaitStartCleared() bool {
	_, ok := m.clearedFields[appstock.FieldWaitStart]
	return ok
}

// ResetWaitStart resets all changes to the "wait_start" field.
func (m *AppStockMutation) ResetWaitStart() {
	m.wait_start = nil
	delete(m.clearedFields, appstock.FieldWaitStart)
}

// SetSold sets the "sold" field.
func (m *AppStockMutation) SetSold(d decimal.Decimal) {
	m.sold = &d
}

// Sold returns the value of the "sold" field in the mutation.
func (m *AppStockMutation) Sold() (r decimal.Decimal, exists bool) {
	v := m.sold
	if v == nil {
		return
	}
	return *v, true
}

// OldSold returns the old "sold" field's value of the AppStock entity.
// If the AppStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppStockMutation) OldSold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSold: %w", err)
	}
	return oldValue.Sold, nil
}

// ClearSold clears the value of the "sold" field.
func (m *AppStockMutation) ClearSold() {
	m.sold = nil
	m.clearedFields[appstock.FieldSold] = struct{}{}
}

// SoldCleared returns if the "sold" field was cleared in this mutation.
func (m *AppStockMutation) SoldCleared() bool {
	_, ok := m.clearedFields[appstock.FieldSold]
	return ok
}

// ResetSold resets all changes to the "sold" field.
func (m *AppStockMutation) ResetSold() {
	m.sold = nil
	delete(m.clearedFields, appstock.FieldSold)
}

// Where appends a list predicates to the AppStockMutation builder.
func (m *AppStockMutation) Where(ps ...predicate.AppStock) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppStockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppStock).
func (m *AppStockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppStockMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, appstock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appstock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appstock.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appstock.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, appstock.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, appstock.FieldAppGoodID)
	}
	if m.reserved != nil {
		fields = append(fields, appstock.FieldReserved)
	}
	if m.spot_quantity != nil {
		fields = append(fields, appstock.FieldSpotQuantity)
	}
	if m.locked != nil {
		fields = append(fields, appstock.FieldLocked)
	}
	if m.in_service != nil {
		fields = append(fields, appstock.FieldInService)
	}
	if m.wait_start != nil {
		fields = append(fields, appstock.FieldWaitStart)
	}
	if m.sold != nil {
		fields = append(fields, appstock.FieldSold)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppStockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appstock.FieldCreatedAt:
		return m.CreatedAt()
	case appstock.FieldUpdatedAt:
		return m.UpdatedAt()
	case appstock.FieldDeletedAt:
		return m.DeletedAt()
	case appstock.FieldAppID:
		return m.AppID()
	case appstock.FieldGoodID:
		return m.GoodID()
	case appstock.FieldAppGoodID:
		return m.AppGoodID()
	case appstock.FieldReserved:
		return m.Reserved()
	case appstock.FieldSpotQuantity:
		return m.SpotQuantity()
	case appstock.FieldLocked:
		return m.Locked()
	case appstock.FieldInService:
		return m.InService()
	case appstock.FieldWaitStart:
		return m.WaitStart()
	case appstock.FieldSold:
		return m.Sold()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppStockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appstock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appstock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appstock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appstock.FieldAppID:
		return m.OldAppID(ctx)
	case appstock.FieldGoodID:
		return m.OldGoodID(ctx)
	case appstock.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case appstock.FieldReserved:
		return m.OldReserved(ctx)
	case appstock.FieldSpotQuantity:
		return m.OldSpotQuantity(ctx)
	case appstock.FieldLocked:
		return m.OldLocked(ctx)
	case appstock.FieldInService:
		return m.OldInService(ctx)
	case appstock.FieldWaitStart:
		return m.OldWaitStart(ctx)
	case appstock.FieldSold:
		return m.OldSold(ctx)
	}
	return nil, fmt.Errorf("unknown AppStock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appstock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appstock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appstock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appstock.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appstock.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case appstock.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case appstock.FieldReserved:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserved(v)
		return nil
	case appstock.FieldSpotQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotQuantity(v)
		return nil
	case appstock.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case appstock.FieldInService:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInService(v)
		return nil
	case appstock.FieldWaitStart:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaitStart(v)
		return nil
	case appstock.FieldSold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSold(v)
		return nil
	}
	return fmt.Errorf("unknown AppStock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppStockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appstock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appstock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appstock.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppStockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appstock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appstock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appstock.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppStockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appstock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appstock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appstock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppStock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppStockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appstock.FieldAppID) {
		fields = append(fields, appstock.FieldAppID)
	}
	if m.FieldCleared(appstock.FieldGoodID) {
		fields = append(fields, appstock.FieldGoodID)
	}
	if m.FieldCleared(appstock.FieldAppGoodID) {
		fields = append(fields, appstock.FieldAppGoodID)
	}
	if m.FieldCleared(appstock.FieldReserved) {
		fields = append(fields, appstock.FieldReserved)
	}
	if m.FieldCleared(appstock.FieldSpotQuantity) {
		fields = append(fields, appstock.FieldSpotQuantity)
	}
	if m.FieldCleared(appstock.FieldLocked) {
		fields = append(fields, appstock.FieldLocked)
	}
	if m.FieldCleared(appstock.FieldInService) {
		fields = append(fields, appstock.FieldInService)
	}
	if m.FieldCleared(appstock.FieldWaitStart) {
		fields = append(fields, appstock.FieldWaitStart)
	}
	if m.FieldCleared(appstock.FieldSold) {
		fields = append(fields, appstock.FieldSold)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppStockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppStockMutation) ClearField(name string) error {
	switch name {
	case appstock.FieldAppID:
		m.ClearAppID()
		return nil
	case appstock.FieldGoodID:
		m.ClearGoodID()
		return nil
	case appstock.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case appstock.FieldReserved:
		m.ClearReserved()
		return nil
	case appstock.FieldSpotQuantity:
		m.ClearSpotQuantity()
		return nil
	case appstock.FieldLocked:
		m.ClearLocked()
		return nil
	case appstock.FieldInService:
		m.ClearInService()
		return nil
	case appstock.FieldWaitStart:
		m.ClearWaitStart()
		return nil
	case appstock.FieldSold:
		m.ClearSold()
		return nil
	}
	return fmt.Errorf("unknown AppStock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppStockMutation) ResetField(name string) error {
	switch name {
	case appstock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appstock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appstock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appstock.FieldAppID:
		m.ResetAppID()
		return nil
	case appstock.FieldGoodID:
		m.ResetGoodID()
		return nil
	case appstock.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case appstock.FieldReserved:
		m.ResetReserved()
		return nil
	case appstock.FieldSpotQuantity:
		m.ResetSpotQuantity()
		return nil
	case appstock.FieldLocked:
		m.ResetLocked()
		return nil
	case appstock.FieldInService:
		m.ResetInService()
		return nil
	case appstock.FieldWaitStart:
		m.ResetWaitStart()
		return nil
	case appstock.FieldSold:
		m.ResetSold()
		return nil
	}
	return fmt.Errorf("unknown AppStock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppStockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppStockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppStockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppStockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppStockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppStockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppStockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppStock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppStockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppStock edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	good_id       *uuid.UUID
	order_id      *uuid.UUID
	content       *string
	reply_to_id   *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Comment, error)
	predicates    []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id uuid.UUID) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CommentMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CommentMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CommentMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CommentMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CommentMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CommentMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *CommentMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CommentMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CommentMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *CommentMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *CommentMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *CommentMutation) ResetGoodID() {
	m.good_id = nil
}

// SetOrderID sets the "order_id" field.
func (m *CommentMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CommentMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *CommentMutation) ClearOrderID() {
	m.order_id = nil
	m.clearedFields[comment.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *CommentMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CommentMutation) ResetOrderID() {
	m.order_id = nil
	delete(m.clearedFields, comment.FieldOrderID)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *CommentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[comment.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *CommentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[comment.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, comment.FieldContent)
}

// SetReplyToID sets the "reply_to_id" field.
func (m *CommentMutation) SetReplyToID(u uuid.UUID) {
	m.reply_to_id = &u
}

// ReplyToID returns the value of the "reply_to_id" field in the mutation.
func (m *CommentMutation) ReplyToID() (r uuid.UUID, exists bool) {
	v := m.reply_to_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyToID returns the old "reply_to_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyToID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyToID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyToID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyToID: %w", err)
	}
	return oldValue.ReplyToID, nil
}

// ClearReplyToID clears the value of the "reply_to_id" field.
func (m *CommentMutation) ClearReplyToID() {
	m.reply_to_id = nil
	m.clearedFields[comment.FieldReplyToID] = struct{}{}
}

// ReplyToIDCleared returns if the "reply_to_id" field was cleared in this mutation.
func (m *CommentMutation) ReplyToIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyToID]
	return ok
}

// ResetReplyToID resets all changes to the "reply_to_id" field.
func (m *CommentMutation) ResetReplyToID() {
	m.reply_to_id = nil
	delete(m.clearedFields, comment.FieldReplyToID)
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, comment.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, comment.FieldGoodID)
	}
	if m.order_id != nil {
		fields = append(fields, comment.FieldOrderID)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.reply_to_id != nil {
		fields = append(fields, comment.FieldReplyToID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldDeletedAt:
		return m.DeletedAt()
	case comment.FieldAppID:
		return m.AppID()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldGoodID:
		return m.GoodID()
	case comment.FieldOrderID:
		return m.OrderID()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldReplyToID:
		return m.ReplyToID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case comment.FieldAppID:
		return m.OldAppID(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldGoodID:
		return m.OldGoodID(ctx)
	case comment.FieldOrderID:
		return m.OldOrderID(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldReplyToID:
		return m.OldReplyToID(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case comment.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case comment.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldReplyToID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyToID(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.AddedCreatedAt()
	case comment.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case comment.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldOrderID) {
		fields = append(fields, comment.FieldOrderID)
	}
	if m.FieldCleared(comment.FieldContent) {
		fields = append(fields, comment.FieldContent)
	}
	if m.FieldCleared(comment.FieldReplyToID) {
		fields = append(fields, comment.FieldReplyToID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldOrderID:
		m.ClearOrderID()
		return nil
	case comment.FieldContent:
		m.ClearContent()
		return nil
	case comment.FieldReplyToID:
		m.ClearReplyToID()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case comment.FieldAppID:
		m.ResetAppID()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldGoodID:
		m.ResetGoodID()
		return nil
	case comment.FieldOrderID:
		m.ResetOrderID()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldReplyToID:
		m.ResetReplyToID()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Comment edge %s", name)
}

// DeviceInfoMutation represents an operation that mutates the DeviceInfo nodes in the graph.
type DeviceInfoMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	_type                *string
	manufacturer         *string
	power_consumption    *uint32
	addpower_consumption *int32
	shipment_at          *uint32
	addshipment_at       *int32
	posters              *[]string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*DeviceInfo, error)
	predicates           []predicate.DeviceInfo
}

var _ ent.Mutation = (*DeviceInfoMutation)(nil)

// deviceinfoOption allows management of the mutation configuration using functional options.
type deviceinfoOption func(*DeviceInfoMutation)

// newDeviceInfoMutation creates new mutation for the DeviceInfo entity.
func newDeviceInfoMutation(c config, op Op, opts ...deviceinfoOption) *DeviceInfoMutation {
	m := &DeviceInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInfoID sets the ID field of the mutation.
func withDeviceInfoID(id uuid.UUID) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInfo
		)
		m.oldValue = func(ctx context.Context) (*DeviceInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInfo sets the old DeviceInfo of the mutation.
func withDeviceInfo(node *DeviceInfo) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		m.oldValue = func(context.Context) (*DeviceInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceInfo entities.
func (m *DeviceInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceInfoMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceInfoMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *DeviceInfoMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *DeviceInfoMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceInfoMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceInfoMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *DeviceInfoMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *DeviceInfoMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceInfoMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceInfoMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *DeviceInfoMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *DeviceInfoMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetType sets the "type" field.
func (m *DeviceInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *DeviceInfoMutation) ClearType() {
	m._type = nil
	m.clearedFields[deviceinfo.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *DeviceInfoMutation) TypeCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *DeviceInfoMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, deviceinfo.FieldType)
}

// SetManufacturer sets the "manufacturer" field.
func (m *DeviceInfoMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *DeviceInfoMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *DeviceInfoMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[deviceinfo.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *DeviceInfoMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *DeviceInfoMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, deviceinfo.FieldManufacturer)
}

// SetPowerConsumption sets the "power_consumption" field.
func (m *DeviceInfoMutation) SetPowerConsumption(u uint32) {
	m.power_consumption = &u
	m.addpower_consumption = nil
}

// PowerConsumption returns the value of the "power_consumption" field in the mutation.
func (m *DeviceInfoMutation) PowerConsumption() (r uint32, exists bool) {
	v := m.power_consumption
	if v == nil {
		return
	}
	return *v, true
}

// OldPowerConsumption returns the old "power_consumption" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldPowerConsumption(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPowerConsumption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPowerConsumption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPowerConsumption: %w", err)
	}
	return oldValue.PowerConsumption, nil
}

// AddPowerConsumption adds u to the "power_consumption" field.
func (m *DeviceInfoMutation) AddPowerConsumption(u int32) {
	if m.addpower_consumption != nil {
		*m.addpower_consumption += u
	} else {
		m.addpower_consumption = &u
	}
}

// AddedPowerConsumption returns the value that was added to the "power_consumption" field in this mutation.
func (m *DeviceInfoMutation) AddedPowerConsumption() (r int32, exists bool) {
	v := m.addpower_consumption
	if v == nil {
		return
	}
	return *v, true
}

// ClearPowerConsumption clears the value of the "power_consumption" field.
func (m *DeviceInfoMutation) ClearPowerConsumption() {
	m.power_consumption = nil
	m.addpower_consumption = nil
	m.clearedFields[deviceinfo.FieldPowerConsumption] = struct{}{}
}

// PowerConsumptionCleared returns if the "power_consumption" field was cleared in this mutation.
func (m *DeviceInfoMutation) PowerConsumptionCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldPowerConsumption]
	return ok
}

// ResetPowerConsumption resets all changes to the "power_consumption" field.
func (m *DeviceInfoMutation) ResetPowerConsumption() {
	m.power_consumption = nil
	m.addpower_consumption = nil
	delete(m.clearedFields, deviceinfo.FieldPowerConsumption)
}

// SetShipmentAt sets the "shipment_at" field.
func (m *DeviceInfoMutation) SetShipmentAt(u uint32) {
	m.shipment_at = &u
	m.addshipment_at = nil
}

// ShipmentAt returns the value of the "shipment_at" field in the mutation.
func (m *DeviceInfoMutation) ShipmentAt() (r uint32, exists bool) {
	v := m.shipment_at
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentAt returns the old "shipment_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldShipmentAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentAt: %w", err)
	}
	return oldValue.ShipmentAt, nil
}

// AddShipmentAt adds u to the "shipment_at" field.
func (m *DeviceInfoMutation) AddShipmentAt(u int32) {
	if m.addshipment_at != nil {
		*m.addshipment_at += u
	} else {
		m.addshipment_at = &u
	}
}

// AddedShipmentAt returns the value that was added to the "shipment_at" field in this mutation.
func (m *DeviceInfoMutation) AddedShipmentAt() (r int32, exists bool) {
	v := m.addshipment_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipmentAt clears the value of the "shipment_at" field.
func (m *DeviceInfoMutation) ClearShipmentAt() {
	m.shipment_at = nil
	m.addshipment_at = nil
	m.clearedFields[deviceinfo.FieldShipmentAt] = struct{}{}
}

// ShipmentAtCleared returns if the "shipment_at" field was cleared in this mutation.
func (m *DeviceInfoMutation) ShipmentAtCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldShipmentAt]
	return ok
}

// ResetShipmentAt resets all changes to the "shipment_at" field.
func (m *DeviceInfoMutation) ResetShipmentAt() {
	m.shipment_at = nil
	m.addshipment_at = nil
	delete(m.clearedFields, deviceinfo.FieldShipmentAt)
}

// SetPosters sets the "posters" field.
func (m *DeviceInfoMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *DeviceInfoMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *DeviceInfoMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[deviceinfo.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *DeviceInfoMutation) PostersCleared() bool {
	_, ok := m.clearedFields[deviceinfo.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *DeviceInfoMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, deviceinfo.FieldPosters)
}

// Where appends a list predicates to the DeviceInfoMutation builder.
func (m *DeviceInfoMutation) Where(ps ...predicate.DeviceInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeviceInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeviceInfo).
func (m *DeviceInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInfoMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, deviceinfo.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.manufacturer != nil {
		fields = append(fields, deviceinfo.FieldManufacturer)
	}
	if m.power_consumption != nil {
		fields = append(fields, deviceinfo.FieldPowerConsumption)
	}
	if m.shipment_at != nil {
		fields = append(fields, deviceinfo.FieldShipmentAt)
	}
	if m.posters != nil {
		fields = append(fields, deviceinfo.FieldPosters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldCreatedAt:
		return m.CreatedAt()
	case deviceinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceinfo.FieldDeletedAt:
		return m.DeletedAt()
	case deviceinfo.FieldType:
		return m.GetType()
	case deviceinfo.FieldManufacturer:
		return m.Manufacturer()
	case deviceinfo.FieldPowerConsumption:
		return m.PowerConsumption()
	case deviceinfo.FieldShipmentAt:
		return m.ShipmentAt()
	case deviceinfo.FieldPosters:
		return m.Posters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case deviceinfo.FieldType:
		return m.OldType(ctx)
	case deviceinfo.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case deviceinfo.FieldPowerConsumption:
		return m.OldPowerConsumption(ctx)
	case deviceinfo.FieldShipmentAt:
		return m.OldShipmentAt(ctx)
	case deviceinfo.FieldPosters:
		return m.OldPosters(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceinfo.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case deviceinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case deviceinfo.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case deviceinfo.FieldPowerConsumption:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPowerConsumption(v)
		return nil
	case deviceinfo.FieldShipmentAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentAt(v)
		return nil
	case deviceinfo.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, deviceinfo.FieldDeletedAt)
	}
	if m.addpower_consumption != nil {
		fields = append(fields, deviceinfo.FieldPowerConsumption)
	}
	if m.addshipment_at != nil {
		fields = append(fields, deviceinfo.FieldShipmentAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case deviceinfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case deviceinfo.FieldDeletedAt:
		return m.AddedDeletedAt()
	case deviceinfo.FieldPowerConsumption:
		return m.AddedPowerConsumption()
	case deviceinfo.FieldShipmentAt:
		return m.AddedShipmentAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case deviceinfo.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case deviceinfo.FieldPowerConsumption:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPowerConsumption(v)
		return nil
	case deviceinfo.FieldShipmentAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipmentAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceinfo.FieldType) {
		fields = append(fields, deviceinfo.FieldType)
	}
	if m.FieldCleared(deviceinfo.FieldManufacturer) {
		fields = append(fields, deviceinfo.FieldManufacturer)
	}
	if m.FieldCleared(deviceinfo.FieldPowerConsumption) {
		fields = append(fields, deviceinfo.FieldPowerConsumption)
	}
	if m.FieldCleared(deviceinfo.FieldShipmentAt) {
		fields = append(fields, deviceinfo.FieldShipmentAt)
	}
	if m.FieldCleared(deviceinfo.FieldPosters) {
		fields = append(fields, deviceinfo.FieldPosters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ClearField(name string) error {
	switch name {
	case deviceinfo.FieldType:
		m.ClearType()
		return nil
	case deviceinfo.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case deviceinfo.FieldPowerConsumption:
		m.ClearPowerConsumption()
		return nil
	case deviceinfo.FieldShipmentAt:
		m.ClearShipmentAt()
		return nil
	case deviceinfo.FieldPosters:
		m.ClearPosters()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ResetField(name string) error {
	switch name {
	case deviceinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case deviceinfo.FieldType:
		m.ResetType()
		return nil
	case deviceinfo.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case deviceinfo.FieldPowerConsumption:
		m.ResetPowerConsumption()
		return nil
	case deviceinfo.FieldShipmentAt:
		m.ResetShipmentAt()
		return nil
	case deviceinfo.FieldPosters:
		m.ResetPosters()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeviceInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeviceInfo edge %s", name)
}

// ExtraInfoMutation represents an operation that mutates the ExtraInfo nodes in the graph.
type ExtraInfoMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *uint32
	addcreated_at      *int32
	updated_at         *uint32
	addupdated_at      *int32
	deleted_at         *uint32
	adddeleted_at      *int32
	good_id            *uuid.UUID
	posters            *[]string
	labels             *[]string
	likes              *uint32
	addlikes           *int32
	dislikes           *uint32
	adddislikes        *int32
	recommend_count    *uint32
	addrecommend_count *int32
	comment_count      *uint32
	addcomment_count   *int32
	score_count        *uint32
	addscore_count     *int32
	score              *decimal.Decimal
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*ExtraInfo, error)
	predicates         []predicate.ExtraInfo
}

var _ ent.Mutation = (*ExtraInfoMutation)(nil)

// extrainfoOption allows management of the mutation configuration using functional options.
type extrainfoOption func(*ExtraInfoMutation)

// newExtraInfoMutation creates new mutation for the ExtraInfo entity.
func newExtraInfoMutation(c config, op Op, opts ...extrainfoOption) *ExtraInfoMutation {
	m := &ExtraInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeExtraInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtraInfoID sets the ID field of the mutation.
func withExtraInfoID(id uuid.UUID) extrainfoOption {
	return func(m *ExtraInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ExtraInfo
		)
		m.oldValue = func(ctx context.Context) (*ExtraInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExtraInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtraInfo sets the old ExtraInfo of the mutation.
func withExtraInfo(node *ExtraInfo) extrainfoOption {
	return func(m *ExtraInfoMutation) {
		m.oldValue = func(context.Context) (*ExtraInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtraInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtraInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExtraInfo entities.
func (m *ExtraInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExtraInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExtraInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExtraInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExtraInfoMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExtraInfoMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ExtraInfoMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ExtraInfoMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExtraInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExtraInfoMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExtraInfoMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ExtraInfoMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ExtraInfoMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExtraInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExtraInfoMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExtraInfoMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ExtraInfoMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ExtraInfoMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExtraInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *ExtraInfoMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *ExtraInfoMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *ExtraInfoMutation) ResetGoodID() {
	m.good_id = nil
}

// SetPosters sets the "posters" field.
func (m *ExtraInfoMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *ExtraInfoMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *ExtraInfoMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[extrainfo.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *ExtraInfoMutation) PostersCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *ExtraInfoMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, extrainfo.FieldPosters)
}

// SetLabels sets the "labels" field.
func (m *ExtraInfoMutation) SetLabels(s []string) {
	m.labels = &s
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ExtraInfoMutation) Labels() (r []string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldLabels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ExtraInfoMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[extrainfo.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ExtraInfoMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ExtraInfoMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, extrainfo.FieldLabels)
}

// SetLikes sets the "likes" field.
func (m *ExtraInfoMutation) SetLikes(u uint32) {
	m.likes = &u
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *ExtraInfoMutation) Likes() (r uint32, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldLikes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds u to the "likes" field.
func (m *ExtraInfoMutation) AddLikes(u int32) {
	if m.addlikes != nil {
		*m.addlikes += u
	} else {
		m.addlikes = &u
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *ExtraInfoMutation) AddedLikes() (r int32, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ClearLikes clears the value of the "likes" field.
func (m *ExtraInfoMutation) ClearLikes() {
	m.likes = nil
	m.addlikes = nil
	m.clearedFields[extrainfo.FieldLikes] = struct{}{}
}

// LikesCleared returns if the "likes" field was cleared in this mutation.
func (m *ExtraInfoMutation) LikesCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldLikes]
	return ok
}

// ResetLikes resets all changes to the "likes" field.
func (m *ExtraInfoMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
	delete(m.clearedFields, extrainfo.FieldLikes)
}

// SetDislikes sets the "dislikes" field.
func (m *ExtraInfoMutation) SetDislikes(u uint32) {
	m.dislikes = &u
	m.adddislikes = nil
}

// Dislikes returns the value of the "dislikes" field in the mutation.
func (m *ExtraInfoMutation) Dislikes() (r uint32, exists bool) {
	v := m.dislikes
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikes returns the old "dislikes" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldDislikes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikes: %w", err)
	}
	return oldValue.Dislikes, nil
}

// AddDislikes adds u to the "dislikes" field.
func (m *ExtraInfoMutation) AddDislikes(u int32) {
	if m.adddislikes != nil {
		*m.adddislikes += u
	} else {
		m.adddislikes = &u
	}
}

// AddedDislikes returns the value that was added to the "dislikes" field in this mutation.
func (m *ExtraInfoMutation) AddedDislikes() (r int32, exists bool) {
	v := m.adddislikes
	if v == nil {
		return
	}
	return *v, true
}

// ClearDislikes clears the value of the "dislikes" field.
func (m *ExtraInfoMutation) ClearDislikes() {
	m.dislikes = nil
	m.adddislikes = nil
	m.clearedFields[extrainfo.FieldDislikes] = struct{}{}
}

// DislikesCleared returns if the "dislikes" field was cleared in this mutation.
func (m *ExtraInfoMutation) DislikesCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldDislikes]
	return ok
}

// ResetDislikes resets all changes to the "dislikes" field.
func (m *ExtraInfoMutation) ResetDislikes() {
	m.dislikes = nil
	m.adddislikes = nil
	delete(m.clearedFields, extrainfo.FieldDislikes)
}

// SetRecommendCount sets the "recommend_count" field.
func (m *ExtraInfoMutation) SetRecommendCount(u uint32) {
	m.recommend_count = &u
	m.addrecommend_count = nil
}

// RecommendCount returns the value of the "recommend_count" field in the mutation.
func (m *ExtraInfoMutation) RecommendCount() (r uint32, exists bool) {
	v := m.recommend_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendCount returns the old "recommend_count" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldRecommendCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendCount: %w", err)
	}
	return oldValue.RecommendCount, nil
}

// AddRecommendCount adds u to the "recommend_count" field.
func (m *ExtraInfoMutation) AddRecommendCount(u int32) {
	if m.addrecommend_count != nil {
		*m.addrecommend_count += u
	} else {
		m.addrecommend_count = &u
	}
}

// AddedRecommendCount returns the value that was added to the "recommend_count" field in this mutation.
func (m *ExtraInfoMutation) AddedRecommendCount() (r int32, exists bool) {
	v := m.addrecommend_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecommendCount clears the value of the "recommend_count" field.
func (m *ExtraInfoMutation) ClearRecommendCount() {
	m.recommend_count = nil
	m.addrecommend_count = nil
	m.clearedFields[extrainfo.FieldRecommendCount] = struct{}{}
}

// RecommendCountCleared returns if the "recommend_count" field was cleared in this mutation.
func (m *ExtraInfoMutation) RecommendCountCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldRecommendCount]
	return ok
}

// ResetRecommendCount resets all changes to the "recommend_count" field.
func (m *ExtraInfoMutation) ResetRecommendCount() {
	m.recommend_count = nil
	m.addrecommend_count = nil
	delete(m.clearedFields, extrainfo.FieldRecommendCount)
}

// SetCommentCount sets the "comment_count" field.
func (m *ExtraInfoMutation) SetCommentCount(u uint32) {
	m.comment_count = &u
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *ExtraInfoMutation) CommentCount() (r uint32, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldCommentCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds u to the "comment_count" field.
func (m *ExtraInfoMutation) AddCommentCount(u int32) {
	if m.addcomment_count != nil {
		*m.addcomment_count += u
	} else {
		m.addcomment_count = &u
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *ExtraInfoMutation) AddedCommentCount() (r int32, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearCommentCount clears the value of the "comment_count" field.
func (m *ExtraInfoMutation) ClearCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
	m.clearedFields[extrainfo.FieldCommentCount] = struct{}{}
}

// CommentCountCleared returns if the "comment_count" field was cleared in this mutation.
func (m *ExtraInfoMutation) CommentCountCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldCommentCount]
	return ok
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *ExtraInfoMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
	delete(m.clearedFields, extrainfo.FieldCommentCount)
}

// SetScoreCount sets the "score_count" field.
func (m *ExtraInfoMutation) SetScoreCount(u uint32) {
	m.score_count = &u
	m.addscore_count = nil
}

// ScoreCount returns the value of the "score_count" field in the mutation.
func (m *ExtraInfoMutation) ScoreCount() (r uint32, exists bool) {
	v := m.score_count
	if v == nil {
		return
	}
	return *v, true
}

// OldScoreCount returns the old "score_count" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldScoreCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScoreCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScoreCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScoreCount: %w", err)
	}
	return oldValue.ScoreCount, nil
}

// AddScoreCount adds u to the "score_count" field.
func (m *ExtraInfoMutation) AddScoreCount(u int32) {
	if m.addscore_count != nil {
		*m.addscore_count += u
	} else {
		m.addscore_count = &u
	}
}

// AddedScoreCount returns the value that was added to the "score_count" field in this mutation.
func (m *ExtraInfoMutation) AddedScoreCount() (r int32, exists bool) {
	v := m.addscore_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearScoreCount clears the value of the "score_count" field.
func (m *ExtraInfoMutation) ClearScoreCount() {
	m.score_count = nil
	m.addscore_count = nil
	m.clearedFields[extrainfo.FieldScoreCount] = struct{}{}
}

// ScoreCountCleared returns if the "score_count" field was cleared in this mutation.
func (m *ExtraInfoMutation) ScoreCountCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldScoreCount]
	return ok
}

// ResetScoreCount resets all changes to the "score_count" field.
func (m *ExtraInfoMutation) ResetScoreCount() {
	m.score_count = nil
	m.addscore_count = nil
	delete(m.clearedFields, extrainfo.FieldScoreCount)
}

// SetScore sets the "score" field.
func (m *ExtraInfoMutation) SetScore(d decimal.Decimal) {
	m.score = &d
}

// Score returns the value of the "score" field in the mutation.
func (m *ExtraInfoMutation) Score() (r decimal.Decimal, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ExtraInfo entity.
// If the ExtraInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExtraInfoMutation) OldScore(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// ClearScore clears the value of the "score" field.
func (m *ExtraInfoMutation) ClearScore() {
	m.score = nil
	m.clearedFields[extrainfo.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ExtraInfoMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[extrainfo.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ExtraInfoMutation) ResetScore() {
	m.score = nil
	delete(m.clearedFields, extrainfo.FieldScore)
}

// Where appends a list predicates to the ExtraInfoMutation builder.
func (m *ExtraInfoMutation) Where(ps ...predicate.ExtraInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ExtraInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ExtraInfo).
func (m *ExtraInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExtraInfoMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, extrainfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, extrainfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, extrainfo.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, extrainfo.FieldGoodID)
	}
	if m.posters != nil {
		fields = append(fields, extrainfo.FieldPosters)
	}
	if m.labels != nil {
		fields = append(fields, extrainfo.FieldLabels)
	}
	if m.likes != nil {
		fields = append(fields, extrainfo.FieldLikes)
	}
	if m.dislikes != nil {
		fields = append(fields, extrainfo.FieldDislikes)
	}
	if m.recommend_count != nil {
		fields = append(fields, extrainfo.FieldRecommendCount)
	}
	if m.comment_count != nil {
		fields = append(fields, extrainfo.FieldCommentCount)
	}
	if m.score_count != nil {
		fields = append(fields, extrainfo.FieldScoreCount)
	}
	if m.score != nil {
		fields = append(fields, extrainfo.FieldScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExtraInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extrainfo.FieldCreatedAt:
		return m.CreatedAt()
	case extrainfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case extrainfo.FieldDeletedAt:
		return m.DeletedAt()
	case extrainfo.FieldGoodID:
		return m.GoodID()
	case extrainfo.FieldPosters:
		return m.Posters()
	case extrainfo.FieldLabels:
		return m.Labels()
	case extrainfo.FieldLikes:
		return m.Likes()
	case extrainfo.FieldDislikes:
		return m.Dislikes()
	case extrainfo.FieldRecommendCount:
		return m.RecommendCount()
	case extrainfo.FieldCommentCount:
		return m.CommentCount()
	case extrainfo.FieldScoreCount:
		return m.ScoreCount()
	case extrainfo.FieldScore:
		return m.Score()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExtraInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extrainfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case extrainfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case extrainfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case extrainfo.FieldGoodID:
		return m.OldGoodID(ctx)
	case extrainfo.FieldPosters:
		return m.OldPosters(ctx)
	case extrainfo.FieldLabels:
		return m.OldLabels(ctx)
	case extrainfo.FieldLikes:
		return m.OldLikes(ctx)
	case extrainfo.FieldDislikes:
		return m.OldDislikes(ctx)
	case extrainfo.FieldRecommendCount:
		return m.OldRecommendCount(ctx)
	case extrainfo.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case extrainfo.FieldScoreCount:
		return m.OldScoreCount(ctx)
	case extrainfo.FieldScore:
		return m.OldScore(ctx)
	}
	return nil, fmt.Errorf("unknown ExtraInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extrainfo.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case extrainfo.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case extrainfo.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case extrainfo.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case extrainfo.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	case extrainfo.FieldLabels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case extrainfo.FieldLikes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	case extrainfo.FieldDislikes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikes(v)
		return nil
	case extrainfo.FieldRecommendCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendCount(v)
		return nil
	case extrainfo.FieldCommentCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case extrainfo.FieldScoreCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScoreCount(v)
		return nil
	case extrainfo.FieldScore:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExtraInfoMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, extrainfo.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, extrainfo.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, extrainfo.FieldDeletedAt)
	}
	if m.addlikes != nil {
		fields = append(fields, extrainfo.FieldLikes)
	}
	if m.adddislikes != nil {
		fields = append(fields, extrainfo.FieldDislikes)
	}
	if m.addrecommend_count != nil {
		fields = append(fields, extrainfo.FieldRecommendCount)
	}
	if m.addcomment_count != nil {
		fields = append(fields, extrainfo.FieldCommentCount)
	}
	if m.addscore_count != nil {
		fields = append(fields, extrainfo.FieldScoreCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExtraInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case extrainfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case extrainfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case extrainfo.FieldDeletedAt:
		return m.AddedDeletedAt()
	case extrainfo.FieldLikes:
		return m.AddedLikes()
	case extrainfo.FieldDislikes:
		return m.AddedDislikes()
	case extrainfo.FieldRecommendCount:
		return m.AddedRecommendCount()
	case extrainfo.FieldCommentCount:
		return m.AddedCommentCount()
	case extrainfo.FieldScoreCount:
		return m.AddedScoreCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExtraInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case extrainfo.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case extrainfo.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case extrainfo.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case extrainfo.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	case extrainfo.FieldDislikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikes(v)
		return nil
	case extrainfo.FieldRecommendCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecommendCount(v)
		return nil
	case extrainfo.FieldCommentCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	case extrainfo.FieldScoreCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScoreCount(v)
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExtraInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(extrainfo.FieldPosters) {
		fields = append(fields, extrainfo.FieldPosters)
	}
	if m.FieldCleared(extrainfo.FieldLabels) {
		fields = append(fields, extrainfo.FieldLabels)
	}
	if m.FieldCleared(extrainfo.FieldLikes) {
		fields = append(fields, extrainfo.FieldLikes)
	}
	if m.FieldCleared(extrainfo.FieldDislikes) {
		fields = append(fields, extrainfo.FieldDislikes)
	}
	if m.FieldCleared(extrainfo.FieldRecommendCount) {
		fields = append(fields, extrainfo.FieldRecommendCount)
	}
	if m.FieldCleared(extrainfo.FieldCommentCount) {
		fields = append(fields, extrainfo.FieldCommentCount)
	}
	if m.FieldCleared(extrainfo.FieldScoreCount) {
		fields = append(fields, extrainfo.FieldScoreCount)
	}
	if m.FieldCleared(extrainfo.FieldScore) {
		fields = append(fields, extrainfo.FieldScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExtraInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtraInfoMutation) ClearField(name string) error {
	switch name {
	case extrainfo.FieldPosters:
		m.ClearPosters()
		return nil
	case extrainfo.FieldLabels:
		m.ClearLabels()
		return nil
	case extrainfo.FieldLikes:
		m.ClearLikes()
		return nil
	case extrainfo.FieldDislikes:
		m.ClearDislikes()
		return nil
	case extrainfo.FieldRecommendCount:
		m.ClearRecommendCount()
		return nil
	case extrainfo.FieldCommentCount:
		m.ClearCommentCount()
		return nil
	case extrainfo.FieldScoreCount:
		m.ClearScoreCount()
		return nil
	case extrainfo.FieldScore:
		m.ClearScore()
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExtraInfoMutation) ResetField(name string) error {
	switch name {
	case extrainfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case extrainfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case extrainfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case extrainfo.FieldGoodID:
		m.ResetGoodID()
		return nil
	case extrainfo.FieldPosters:
		m.ResetPosters()
		return nil
	case extrainfo.FieldLabels:
		m.ResetLabels()
		return nil
	case extrainfo.FieldLikes:
		m.ResetLikes()
		return nil
	case extrainfo.FieldDislikes:
		m.ResetDislikes()
		return nil
	case extrainfo.FieldRecommendCount:
		m.ResetRecommendCount()
		return nil
	case extrainfo.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case extrainfo.FieldScoreCount:
		m.ResetScoreCount()
		return nil
	case extrainfo.FieldScore:
		m.ResetScore()
		return nil
	}
	return fmt.Errorf("unknown ExtraInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExtraInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExtraInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExtraInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExtraInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExtraInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExtraInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExtraInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExtraInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExtraInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExtraInfo edge %s", name)
}

// GoodMutation represents an operation that mutates the Good nodes in the graph.
type GoodMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *uint32
	addcreated_at             *int32
	updated_at                *uint32
	addupdated_at             *int32
	deleted_at                *uint32
	adddeleted_at             *int32
	device_info_id            *uuid.UUID
	duration_days             *int32
	addduration_days          *int32
	coin_type_id              *uuid.UUID
	inherit_from_good_id      *uuid.UUID
	vendor_location_id        *uuid.UUID
	price                     *decimal.Decimal
	benefit_type              *string
	good_type                 *string
	title                     *string
	unit                      *string
	unit_amount               *int32
	addunit_amount            *int32
	support_coin_type_ids     *[]uuid.UUID
	delivery_at               *uint32
	adddelivery_at            *int32
	start_at                  *uint32
	addstart_at               *int32
	test_only                 *bool
	benefit_interval_hours    *uint32
	addbenefit_interval_hours *int32
	unit_lock_deposit         *decimal.Decimal
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Good, error)
	predicates                []predicate.Good
}

var _ ent.Mutation = (*GoodMutation)(nil)

// goodOption allows management of the mutation configuration using functional options.
type goodOption func(*GoodMutation)

// newGoodMutation creates new mutation for the Good entity.
func newGoodMutation(c config, op Op, opts ...goodOption) *GoodMutation {
	m := &GoodMutation{
		config:        c,
		op:            op,
		typ:           TypeGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodID sets the ID field of the mutation.
func withGoodID(id uuid.UUID) goodOption {
	return func(m *GoodMutation) {
		var (
			err   error
			once  sync.Once
			value *Good
		)
		m.oldValue = func(ctx context.Context) (*Good, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Good.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGood sets the old Good of the mutation.
func withGood(node *Good) goodOption {
	return func(m *GoodMutation) {
		m.oldValue = func(context.Context) (*Good, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Good entities.
func (m *GoodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Good.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetDeviceInfoID sets the "device_info_id" field.
func (m *GoodMutation) SetDeviceInfoID(u uuid.UUID) {
	m.device_info_id = &u
}

// DeviceInfoID returns the value of the "device_info_id" field in the mutation.
func (m *GoodMutation) DeviceInfoID() (r uuid.UUID, exists bool) {
	v := m.device_info_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfoID returns the old "device_info_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDeviceInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfoID: %w", err)
	}
	return oldValue.DeviceInfoID, nil
}

// ResetDeviceInfoID resets all changes to the "device_info_id" field.
func (m *GoodMutation) ResetDeviceInfoID() {
	m.device_info_id = nil
}

// SetDurationDays sets the "duration_days" field.
func (m *GoodMutation) SetDurationDays(i int32) {
	m.duration_days = &i
	m.addduration_days = nil
}

// DurationDays returns the value of the "duration_days" field in the mutation.
func (m *GoodMutation) DurationDays() (r int32, exists bool) {
	v := m.duration_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDays returns the old "duration_days" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDurationDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDays: %w", err)
	}
	return oldValue.DurationDays, nil
}

// AddDurationDays adds i to the "duration_days" field.
func (m *GoodMutation) AddDurationDays(i int32) {
	if m.addduration_days != nil {
		*m.addduration_days += i
	} else {
		m.addduration_days = &i
	}
}

// AddedDurationDays returns the value that was added to the "duration_days" field in this mutation.
func (m *GoodMutation) AddedDurationDays() (r int32, exists bool) {
	v := m.addduration_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationDays clears the value of the "duration_days" field.
func (m *GoodMutation) ClearDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	m.clearedFields[good.FieldDurationDays] = struct{}{}
}

// DurationDaysCleared returns if the "duration_days" field was cleared in this mutation.
func (m *GoodMutation) DurationDaysCleared() bool {
	_, ok := m.clearedFields[good.FieldDurationDays]
	return ok
}

// ResetDurationDays resets all changes to the "duration_days" field.
func (m *GoodMutation) ResetDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	delete(m.clearedFields, good.FieldDurationDays)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *GoodMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *GoodMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *GoodMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
}

// SetInheritFromGoodID sets the "inherit_from_good_id" field.
func (m *GoodMutation) SetInheritFromGoodID(u uuid.UUID) {
	m.inherit_from_good_id = &u
}

// InheritFromGoodID returns the value of the "inherit_from_good_id" field in the mutation.
func (m *GoodMutation) InheritFromGoodID() (r uuid.UUID, exists bool) {
	v := m.inherit_from_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInheritFromGoodID returns the old "inherit_from_good_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldInheritFromGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInheritFromGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInheritFromGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInheritFromGoodID: %w", err)
	}
	return oldValue.InheritFromGoodID, nil
}

// ClearInheritFromGoodID clears the value of the "inherit_from_good_id" field.
func (m *GoodMutation) ClearInheritFromGoodID() {
	m.inherit_from_good_id = nil
	m.clearedFields[good.FieldInheritFromGoodID] = struct{}{}
}

// InheritFromGoodIDCleared returns if the "inherit_from_good_id" field was cleared in this mutation.
func (m *GoodMutation) InheritFromGoodIDCleared() bool {
	_, ok := m.clearedFields[good.FieldInheritFromGoodID]
	return ok
}

// ResetInheritFromGoodID resets all changes to the "inherit_from_good_id" field.
func (m *GoodMutation) ResetInheritFromGoodID() {
	m.inherit_from_good_id = nil
	delete(m.clearedFields, good.FieldInheritFromGoodID)
}

// SetVendorLocationID sets the "vendor_location_id" field.
func (m *GoodMutation) SetVendorLocationID(u uuid.UUID) {
	m.vendor_location_id = &u
}

// VendorLocationID returns the value of the "vendor_location_id" field in the mutation.
func (m *GoodMutation) VendorLocationID() (r uuid.UUID, exists bool) {
	v := m.vendor_location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorLocationID returns the old "vendor_location_id" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldVendorLocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorLocationID: %w", err)
	}
	return oldValue.VendorLocationID, nil
}

// ResetVendorLocationID resets all changes to the "vendor_location_id" field.
func (m *GoodMutation) ResetVendorLocationID() {
	m.vendor_location_id = nil
}

// SetPrice sets the "price" field.
func (m *GoodMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *GoodMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *GoodMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[good.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *GoodMutation) PriceCleared() bool {
	_, ok := m.clearedFields[good.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *GoodMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, good.FieldPrice)
}

// SetBenefitType sets the "benefit_type" field.
func (m *GoodMutation) SetBenefitType(s string) {
	m.benefit_type = &s
}

// BenefitType returns the value of the "benefit_type" field in the mutation.
func (m *GoodMutation) BenefitType() (r string, exists bool) {
	v := m.benefit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitType returns the old "benefit_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldBenefitType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitType: %w", err)
	}
	return oldValue.BenefitType, nil
}

// ClearBenefitType clears the value of the "benefit_type" field.
func (m *GoodMutation) ClearBenefitType() {
	m.benefit_type = nil
	m.clearedFields[good.FieldBenefitType] = struct{}{}
}

// BenefitTypeCleared returns if the "benefit_type" field was cleared in this mutation.
func (m *GoodMutation) BenefitTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldBenefitType]
	return ok
}

// ResetBenefitType resets all changes to the "benefit_type" field.
func (m *GoodMutation) ResetBenefitType() {
	m.benefit_type = nil
	delete(m.clearedFields, good.FieldBenefitType)
}

// SetGoodType sets the "good_type" field.
func (m *GoodMutation) SetGoodType(s string) {
	m.good_type = &s
}

// GoodType returns the value of the "good_type" field in the mutation.
func (m *GoodMutation) GoodType() (r string, exists bool) {
	v := m.good_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodType returns the old "good_type" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldGoodType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodType: %w", err)
	}
	return oldValue.GoodType, nil
}

// ClearGoodType clears the value of the "good_type" field.
func (m *GoodMutation) ClearGoodType() {
	m.good_type = nil
	m.clearedFields[good.FieldGoodType] = struct{}{}
}

// GoodTypeCleared returns if the "good_type" field was cleared in this mutation.
func (m *GoodMutation) GoodTypeCleared() bool {
	_, ok := m.clearedFields[good.FieldGoodType]
	return ok
}

// ResetGoodType resets all changes to the "good_type" field.
func (m *GoodMutation) ResetGoodType() {
	m.good_type = nil
	delete(m.clearedFields, good.FieldGoodType)
}

// SetTitle sets the "title" field.
func (m *GoodMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GoodMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *GoodMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[good.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *GoodMutation) TitleCleared() bool {
	_, ok := m.clearedFields[good.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *GoodMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, good.FieldTitle)
}

// SetUnit sets the "unit" field.
func (m *GoodMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *GoodMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *GoodMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[good.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *GoodMutation) UnitCleared() bool {
	_, ok := m.clearedFields[good.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *GoodMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, good.FieldUnit)
}

// SetUnitAmount sets the "unit_amount" field.
func (m *GoodMutation) SetUnitAmount(i int32) {
	m.unit_amount = &i
	m.addunit_amount = nil
}

// UnitAmount returns the value of the "unit_amount" field in the mutation.
func (m *GoodMutation) UnitAmount() (r int32, exists bool) {
	v := m.unit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitAmount returns the old "unit_amount" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnitAmount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitAmount: %w", err)
	}
	return oldValue.UnitAmount, nil
}

// AddUnitAmount adds i to the "unit_amount" field.
func (m *GoodMutation) AddUnitAmount(i int32) {
	if m.addunit_amount != nil {
		*m.addunit_amount += i
	} else {
		m.addunit_amount = &i
	}
}

// AddedUnitAmount returns the value that was added to the "unit_amount" field in this mutation.
func (m *GoodMutation) AddedUnitAmount() (r int32, exists bool) {
	v := m.addunit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitAmount clears the value of the "unit_amount" field.
func (m *GoodMutation) ClearUnitAmount() {
	m.unit_amount = nil
	m.addunit_amount = nil
	m.clearedFields[good.FieldUnitAmount] = struct{}{}
}

// UnitAmountCleared returns if the "unit_amount" field was cleared in this mutation.
func (m *GoodMutation) UnitAmountCleared() bool {
	_, ok := m.clearedFields[good.FieldUnitAmount]
	return ok
}

// ResetUnitAmount resets all changes to the "unit_amount" field.
func (m *GoodMutation) ResetUnitAmount() {
	m.unit_amount = nil
	m.addunit_amount = nil
	delete(m.clearedFields, good.FieldUnitAmount)
}

// SetSupportCoinTypeIds sets the "support_coin_type_ids" field.
func (m *GoodMutation) SetSupportCoinTypeIds(u []uuid.UUID) {
	m.support_coin_type_ids = &u
}

// SupportCoinTypeIds returns the value of the "support_coin_type_ids" field in the mutation.
func (m *GoodMutation) SupportCoinTypeIds() (r []uuid.UUID, exists bool) {
	v := m.support_coin_type_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportCoinTypeIds returns the old "support_coin_type_ids" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldSupportCoinTypeIds(ctx context.Context) (v []uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportCoinTypeIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportCoinTypeIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportCoinTypeIds: %w", err)
	}
	return oldValue.SupportCoinTypeIds, nil
}

// ClearSupportCoinTypeIds clears the value of the "support_coin_type_ids" field.
func (m *GoodMutation) ClearSupportCoinTypeIds() {
	m.support_coin_type_ids = nil
	m.clearedFields[good.FieldSupportCoinTypeIds] = struct{}{}
}

// SupportCoinTypeIdsCleared returns if the "support_coin_type_ids" field was cleared in this mutation.
func (m *GoodMutation) SupportCoinTypeIdsCleared() bool {
	_, ok := m.clearedFields[good.FieldSupportCoinTypeIds]
	return ok
}

// ResetSupportCoinTypeIds resets all changes to the "support_coin_type_ids" field.
func (m *GoodMutation) ResetSupportCoinTypeIds() {
	m.support_coin_type_ids = nil
	delete(m.clearedFields, good.FieldSupportCoinTypeIds)
}

// SetDeliveryAt sets the "delivery_at" field.
func (m *GoodMutation) SetDeliveryAt(u uint32) {
	m.delivery_at = &u
	m.adddelivery_at = nil
}

// DeliveryAt returns the value of the "delivery_at" field in the mutation.
func (m *GoodMutation) DeliveryAt() (r uint32, exists bool) {
	v := m.delivery_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryAt returns the old "delivery_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldDeliveryAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryAt: %w", err)
	}
	return oldValue.DeliveryAt, nil
}

// AddDeliveryAt adds u to the "delivery_at" field.
func (m *GoodMutation) AddDeliveryAt(u int32) {
	if m.adddelivery_at != nil {
		*m.adddelivery_at += u
	} else {
		m.adddelivery_at = &u
	}
}

// AddedDeliveryAt returns the value that was added to the "delivery_at" field in this mutation.
func (m *GoodMutation) AddedDeliveryAt() (r int32, exists bool) {
	v := m.adddelivery_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryAt clears the value of the "delivery_at" field.
func (m *GoodMutation) ClearDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	m.clearedFields[good.FieldDeliveryAt] = struct{}{}
}

// DeliveryAtCleared returns if the "delivery_at" field was cleared in this mutation.
func (m *GoodMutation) DeliveryAtCleared() bool {
	_, ok := m.clearedFields[good.FieldDeliveryAt]
	return ok
}

// ResetDeliveryAt resets all changes to the "delivery_at" field.
func (m *GoodMutation) ResetDeliveryAt() {
	m.delivery_at = nil
	m.adddelivery_at = nil
	delete(m.clearedFields, good.FieldDeliveryAt)
}

// SetStartAt sets the "start_at" field.
func (m *GoodMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *GoodMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *GoodMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *GoodMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *GoodMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[good.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *GoodMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[good.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *GoodMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, good.FieldStartAt)
}

// SetTestOnly sets the "test_only" field.
func (m *GoodMutation) SetTestOnly(b bool) {
	m.test_only = &b
}

// TestOnly returns the value of the "test_only" field in the mutation.
func (m *GoodMutation) TestOnly() (r bool, exists bool) {
	v := m.test_only
	if v == nil {
		return
	}
	return *v, true
}

// OldTestOnly returns the old "test_only" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldTestOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestOnly: %w", err)
	}
	return oldValue.TestOnly, nil
}

// ClearTestOnly clears the value of the "test_only" field.
func (m *GoodMutation) ClearTestOnly() {
	m.test_only = nil
	m.clearedFields[good.FieldTestOnly] = struct{}{}
}

// TestOnlyCleared returns if the "test_only" field was cleared in this mutation.
func (m *GoodMutation) TestOnlyCleared() bool {
	_, ok := m.clearedFields[good.FieldTestOnly]
	return ok
}

// ResetTestOnly resets all changes to the "test_only" field.
func (m *GoodMutation) ResetTestOnly() {
	m.test_only = nil
	delete(m.clearedFields, good.FieldTestOnly)
}

// SetBenefitIntervalHours sets the "benefit_interval_hours" field.
func (m *GoodMutation) SetBenefitIntervalHours(u uint32) {
	m.benefit_interval_hours = &u
	m.addbenefit_interval_hours = nil
}

// BenefitIntervalHours returns the value of the "benefit_interval_hours" field in the mutation.
func (m *GoodMutation) BenefitIntervalHours() (r uint32, exists bool) {
	v := m.benefit_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefitIntervalHours returns the old "benefit_interval_hours" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldBenefitIntervalHours(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefitIntervalHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefitIntervalHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefitIntervalHours: %w", err)
	}
	return oldValue.BenefitIntervalHours, nil
}

// AddBenefitIntervalHours adds u to the "benefit_interval_hours" field.
func (m *GoodMutation) AddBenefitIntervalHours(u int32) {
	if m.addbenefit_interval_hours != nil {
		*m.addbenefit_interval_hours += u
	} else {
		m.addbenefit_interval_hours = &u
	}
}

// AddedBenefitIntervalHours returns the value that was added to the "benefit_interval_hours" field in this mutation.
func (m *GoodMutation) AddedBenefitIntervalHours() (r int32, exists bool) {
	v := m.addbenefit_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearBenefitIntervalHours clears the value of the "benefit_interval_hours" field.
func (m *GoodMutation) ClearBenefitIntervalHours() {
	m.benefit_interval_hours = nil
	m.addbenefit_interval_hours = nil
	m.clearedFields[good.FieldBenefitIntervalHours] = struct{}{}
}

// BenefitIntervalHoursCleared returns if the "benefit_interval_hours" field was cleared in this mutation.
func (m *GoodMutation) BenefitIntervalHoursCleared() bool {
	_, ok := m.clearedFields[good.FieldBenefitIntervalHours]
	return ok
}

// ResetBenefitIntervalHours resets all changes to the "benefit_interval_hours" field.
func (m *GoodMutation) ResetBenefitIntervalHours() {
	m.benefit_interval_hours = nil
	m.addbenefit_interval_hours = nil
	delete(m.clearedFields, good.FieldBenefitIntervalHours)
}

// SetUnitLockDeposit sets the "unit_lock_deposit" field.
func (m *GoodMutation) SetUnitLockDeposit(d decimal.Decimal) {
	m.unit_lock_deposit = &d
}

// UnitLockDeposit returns the value of the "unit_lock_deposit" field in the mutation.
func (m *GoodMutation) UnitLockDeposit() (r decimal.Decimal, exists bool) {
	v := m.unit_lock_deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitLockDeposit returns the old "unit_lock_deposit" field's value of the Good entity.
// If the Good object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodMutation) OldUnitLockDeposit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitLockDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitLockDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitLockDeposit: %w", err)
	}
	return oldValue.UnitLockDeposit, nil
}

// ClearUnitLockDeposit clears the value of the "unit_lock_deposit" field.
func (m *GoodMutation) ClearUnitLockDeposit() {
	m.unit_lock_deposit = nil
	m.clearedFields[good.FieldUnitLockDeposit] = struct{}{}
}

// UnitLockDepositCleared returns if the "unit_lock_deposit" field was cleared in this mutation.
func (m *GoodMutation) UnitLockDepositCleared() bool {
	_, ok := m.clearedFields[good.FieldUnitLockDeposit]
	return ok
}

// ResetUnitLockDeposit resets all changes to the "unit_lock_deposit" field.
func (m *GoodMutation) ResetUnitLockDeposit() {
	m.unit_lock_deposit = nil
	delete(m.clearedFields, good.FieldUnitLockDeposit)
}

// Where appends a list predicates to the GoodMutation builder.
func (m *GoodMutation) Where(ps ...predicate.Good) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Good).
func (m *GoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, good.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, good.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, good.FieldDeletedAt)
	}
	if m.device_info_id != nil {
		fields = append(fields, good.FieldDeviceInfoID)
	}
	if m.duration_days != nil {
		fields = append(fields, good.FieldDurationDays)
	}
	if m.coin_type_id != nil {
		fields = append(fields, good.FieldCoinTypeID)
	}
	if m.inherit_from_good_id != nil {
		fields = append(fields, good.FieldInheritFromGoodID)
	}
	if m.vendor_location_id != nil {
		fields = append(fields, good.FieldVendorLocationID)
	}
	if m.price != nil {
		fields = append(fields, good.FieldPrice)
	}
	if m.benefit_type != nil {
		fields = append(fields, good.FieldBenefitType)
	}
	if m.good_type != nil {
		fields = append(fields, good.FieldGoodType)
	}
	if m.title != nil {
		fields = append(fields, good.FieldTitle)
	}
	if m.unit != nil {
		fields = append(fields, good.FieldUnit)
	}
	if m.unit_amount != nil {
		fields = append(fields, good.FieldUnitAmount)
	}
	if m.support_coin_type_ids != nil {
		fields = append(fields, good.FieldSupportCoinTypeIds)
	}
	if m.delivery_at != nil {
		fields = append(fields, good.FieldDeliveryAt)
	}
	if m.start_at != nil {
		fields = append(fields, good.FieldStartAt)
	}
	if m.test_only != nil {
		fields = append(fields, good.FieldTestOnly)
	}
	if m.benefit_interval_hours != nil {
		fields = append(fields, good.FieldBenefitIntervalHours)
	}
	if m.unit_lock_deposit != nil {
		fields = append(fields, good.FieldUnitLockDeposit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case good.FieldCreatedAt:
		return m.CreatedAt()
	case good.FieldUpdatedAt:
		return m.UpdatedAt()
	case good.FieldDeletedAt:
		return m.DeletedAt()
	case good.FieldDeviceInfoID:
		return m.DeviceInfoID()
	case good.FieldDurationDays:
		return m.DurationDays()
	case good.FieldCoinTypeID:
		return m.CoinTypeID()
	case good.FieldInheritFromGoodID:
		return m.InheritFromGoodID()
	case good.FieldVendorLocationID:
		return m.VendorLocationID()
	case good.FieldPrice:
		return m.Price()
	case good.FieldBenefitType:
		return m.BenefitType()
	case good.FieldGoodType:
		return m.GoodType()
	case good.FieldTitle:
		return m.Title()
	case good.FieldUnit:
		return m.Unit()
	case good.FieldUnitAmount:
		return m.UnitAmount()
	case good.FieldSupportCoinTypeIds:
		return m.SupportCoinTypeIds()
	case good.FieldDeliveryAt:
		return m.DeliveryAt()
	case good.FieldStartAt:
		return m.StartAt()
	case good.FieldTestOnly:
		return m.TestOnly()
	case good.FieldBenefitIntervalHours:
		return m.BenefitIntervalHours()
	case good.FieldUnitLockDeposit:
		return m.UnitLockDeposit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case good.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case good.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case good.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case good.FieldDeviceInfoID:
		return m.OldDeviceInfoID(ctx)
	case good.FieldDurationDays:
		return m.OldDurationDays(ctx)
	case good.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case good.FieldInheritFromGoodID:
		return m.OldInheritFromGoodID(ctx)
	case good.FieldVendorLocationID:
		return m.OldVendorLocationID(ctx)
	case good.FieldPrice:
		return m.OldPrice(ctx)
	case good.FieldBenefitType:
		return m.OldBenefitType(ctx)
	case good.FieldGoodType:
		return m.OldGoodType(ctx)
	case good.FieldTitle:
		return m.OldTitle(ctx)
	case good.FieldUnit:
		return m.OldUnit(ctx)
	case good.FieldUnitAmount:
		return m.OldUnitAmount(ctx)
	case good.FieldSupportCoinTypeIds:
		return m.OldSupportCoinTypeIds(ctx)
	case good.FieldDeliveryAt:
		return m.OldDeliveryAt(ctx)
	case good.FieldStartAt:
		return m.OldStartAt(ctx)
	case good.FieldTestOnly:
		return m.OldTestOnly(ctx)
	case good.FieldBenefitIntervalHours:
		return m.OldBenefitIntervalHours(ctx)
	case good.FieldUnitLockDeposit:
		return m.OldUnitLockDeposit(ctx)
	}
	return nil, fmt.Errorf("unknown Good field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case good.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case good.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case good.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case good.FieldDeviceInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfoID(v)
		return nil
	case good.FieldDurationDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDays(v)
		return nil
	case good.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case good.FieldInheritFromGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInheritFromGoodID(v)
		return nil
	case good.FieldVendorLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorLocationID(v)
		return nil
	case good.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case good.FieldBenefitType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitType(v)
		return nil
	case good.FieldGoodType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodType(v)
		return nil
	case good.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case good.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case good.FieldUnitAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitAmount(v)
		return nil
	case good.FieldSupportCoinTypeIds:
		v, ok := value.([]uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportCoinTypeIds(v)
		return nil
	case good.FieldDeliveryAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryAt(v)
		return nil
	case good.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case good.FieldTestOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestOnly(v)
		return nil
	case good.FieldBenefitIntervalHours:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefitIntervalHours(v)
		return nil
	case good.FieldUnitLockDeposit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitLockDeposit(v)
		return nil
	}
	return fmt.Errorf("unknown Good field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, good.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, good.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, good.FieldDeletedAt)
	}
	if m.addduration_days != nil {
		fields = append(fields, good.FieldDurationDays)
	}
	if m.addunit_amount != nil {
		fields = append(fields, good.FieldUnitAmount)
	}
	if m.adddelivery_at != nil {
		fields = append(fields, good.FieldDeliveryAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, good.FieldStartAt)
	}
	if m.addbenefit_interval_hours != nil {
		fields = append(fields, good.FieldBenefitIntervalHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case good.FieldCreatedAt:
		return m.AddedCreatedAt()
	case good.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case good.FieldDeletedAt:
		return m.AddedDeletedAt()
	case good.FieldDurationDays:
		return m.AddedDurationDays()
	case good.FieldUnitAmount:
		return m.AddedUnitAmount()
	case good.FieldDeliveryAt:
		return m.AddedDeliveryAt()
	case good.FieldStartAt:
		return m.AddedStartAt()
	case good.FieldBenefitIntervalHours:
		return m.AddedBenefitIntervalHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case good.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case good.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case good.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case good.FieldDurationDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationDays(v)
		return nil
	case good.FieldUnitAmount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitAmount(v)
		return nil
	case good.FieldDeliveryAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryAt(v)
		return nil
	case good.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case good.FieldBenefitIntervalHours:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBenefitIntervalHours(v)
		return nil
	}
	return fmt.Errorf("unknown Good numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(good.FieldDurationDays) {
		fields = append(fields, good.FieldDurationDays)
	}
	if m.FieldCleared(good.FieldInheritFromGoodID) {
		fields = append(fields, good.FieldInheritFromGoodID)
	}
	if m.FieldCleared(good.FieldPrice) {
		fields = append(fields, good.FieldPrice)
	}
	if m.FieldCleared(good.FieldBenefitType) {
		fields = append(fields, good.FieldBenefitType)
	}
	if m.FieldCleared(good.FieldGoodType) {
		fields = append(fields, good.FieldGoodType)
	}
	if m.FieldCleared(good.FieldTitle) {
		fields = append(fields, good.FieldTitle)
	}
	if m.FieldCleared(good.FieldUnit) {
		fields = append(fields, good.FieldUnit)
	}
	if m.FieldCleared(good.FieldUnitAmount) {
		fields = append(fields, good.FieldUnitAmount)
	}
	if m.FieldCleared(good.FieldSupportCoinTypeIds) {
		fields = append(fields, good.FieldSupportCoinTypeIds)
	}
	if m.FieldCleared(good.FieldDeliveryAt) {
		fields = append(fields, good.FieldDeliveryAt)
	}
	if m.FieldCleared(good.FieldStartAt) {
		fields = append(fields, good.FieldStartAt)
	}
	if m.FieldCleared(good.FieldTestOnly) {
		fields = append(fields, good.FieldTestOnly)
	}
	if m.FieldCleared(good.FieldBenefitIntervalHours) {
		fields = append(fields, good.FieldBenefitIntervalHours)
	}
	if m.FieldCleared(good.FieldUnitLockDeposit) {
		fields = append(fields, good.FieldUnitLockDeposit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodMutation) ClearField(name string) error {
	switch name {
	case good.FieldDurationDays:
		m.ClearDurationDays()
		return nil
	case good.FieldInheritFromGoodID:
		m.ClearInheritFromGoodID()
		return nil
	case good.FieldPrice:
		m.ClearPrice()
		return nil
	case good.FieldBenefitType:
		m.ClearBenefitType()
		return nil
	case good.FieldGoodType:
		m.ClearGoodType()
		return nil
	case good.FieldTitle:
		m.ClearTitle()
		return nil
	case good.FieldUnit:
		m.ClearUnit()
		return nil
	case good.FieldUnitAmount:
		m.ClearUnitAmount()
		return nil
	case good.FieldSupportCoinTypeIds:
		m.ClearSupportCoinTypeIds()
		return nil
	case good.FieldDeliveryAt:
		m.ClearDeliveryAt()
		return nil
	case good.FieldStartAt:
		m.ClearStartAt()
		return nil
	case good.FieldTestOnly:
		m.ClearTestOnly()
		return nil
	case good.FieldBenefitIntervalHours:
		m.ClearBenefitIntervalHours()
		return nil
	case good.FieldUnitLockDeposit:
		m.ClearUnitLockDeposit()
		return nil
	}
	return fmt.Errorf("unknown Good nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodMutation) ResetField(name string) error {
	switch name {
	case good.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case good.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case good.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case good.FieldDeviceInfoID:
		m.ResetDeviceInfoID()
		return nil
	case good.FieldDurationDays:
		m.ResetDurationDays()
		return nil
	case good.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case good.FieldInheritFromGoodID:
		m.ResetInheritFromGoodID()
		return nil
	case good.FieldVendorLocationID:
		m.ResetVendorLocationID()
		return nil
	case good.FieldPrice:
		m.ResetPrice()
		return nil
	case good.FieldBenefitType:
		m.ResetBenefitType()
		return nil
	case good.FieldGoodType:
		m.ResetGoodType()
		return nil
	case good.FieldTitle:
		m.ResetTitle()
		return nil
	case good.FieldUnit:
		m.ResetUnit()
		return nil
	case good.FieldUnitAmount:
		m.ResetUnitAmount()
		return nil
	case good.FieldSupportCoinTypeIds:
		m.ResetSupportCoinTypeIds()
		return nil
	case good.FieldDeliveryAt:
		m.ResetDeliveryAt()
		return nil
	case good.FieldStartAt:
		m.ResetStartAt()
		return nil
	case good.FieldTestOnly:
		m.ResetTestOnly()
		return nil
	case good.FieldBenefitIntervalHours:
		m.ResetBenefitIntervalHours()
		return nil
	case good.FieldUnitLockDeposit:
		m.ResetUnitLockDeposit()
		return nil
	}
	return fmt.Errorf("unknown Good field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Good unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Good edge %s", name)
}

// GoodRewardMutation represents an operation that mutates the GoodReward nodes in the graph.
type GoodRewardMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *uint32
	addcreated_at            *int32
	updated_at               *uint32
	addupdated_at            *int32
	deleted_at               *uint32
	adddeleted_at            *int32
	good_id                  *uuid.UUID
	reward_state             *string
	last_reward_at           *uint32
	addlast_reward_at        *int32
	reward_tid               *uuid.UUID
	next_reward_start_amount *decimal.Decimal
	last_reward_amount       *decimal.Decimal
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*GoodReward, error)
	predicates               []predicate.GoodReward
}

var _ ent.Mutation = (*GoodRewardMutation)(nil)

// goodrewardOption allows management of the mutation configuration using functional options.
type goodrewardOption func(*GoodRewardMutation)

// newGoodRewardMutation creates new mutation for the GoodReward entity.
func newGoodRewardMutation(c config, op Op, opts ...goodrewardOption) *GoodRewardMutation {
	m := &GoodRewardMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodReward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodRewardID sets the ID field of the mutation.
func withGoodRewardID(id uuid.UUID) goodrewardOption {
	return func(m *GoodRewardMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodReward
		)
		m.oldValue = func(ctx context.Context) (*GoodReward, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodReward.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodReward sets the old GoodReward of the mutation.
func withGoodReward(node *GoodReward) goodrewardOption {
	return func(m *GoodRewardMutation) {
		m.oldValue = func(context.Context) (*GoodReward, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodRewardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodRewardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodReward entities.
func (m *GoodRewardMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodRewardMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodRewardMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodReward.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodRewardMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodRewardMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodRewardMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodRewardMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodRewardMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodRewardMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodRewardMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodRewardMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodRewardMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodRewardMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodRewardMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodRewardMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodRewardMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodRewardMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodRewardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodRewardMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodRewardMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodRewardMutation) ResetGoodID() {
	m.good_id = nil
}

// SetRewardState sets the "reward_state" field.
func (m *GoodRewardMutation) SetRewardState(s string) {
	m.reward_state = &s
}

// RewardState returns the value of the "reward_state" field in the mutation.
func (m *GoodRewardMutation) RewardState() (r string, exists bool) {
	v := m.reward_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardState returns the old "reward_state" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldRewardState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardState: %w", err)
	}
	return oldValue.RewardState, nil
}

// ClearRewardState clears the value of the "reward_state" field.
func (m *GoodRewardMutation) ClearRewardState() {
	m.reward_state = nil
	m.clearedFields[goodreward.FieldRewardState] = struct{}{}
}

// RewardStateCleared returns if the "reward_state" field was cleared in this mutation.
func (m *GoodRewardMutation) RewardStateCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldRewardState]
	return ok
}

// ResetRewardState resets all changes to the "reward_state" field.
func (m *GoodRewardMutation) ResetRewardState() {
	m.reward_state = nil
	delete(m.clearedFields, goodreward.FieldRewardState)
}

// SetLastRewardAt sets the "last_reward_at" field.
func (m *GoodRewardMutation) SetLastRewardAt(u uint32) {
	m.last_reward_at = &u
	m.addlast_reward_at = nil
}

// LastRewardAt returns the value of the "last_reward_at" field in the mutation.
func (m *GoodRewardMutation) LastRewardAt() (r uint32, exists bool) {
	v := m.last_reward_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRewardAt returns the old "last_reward_at" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldLastRewardAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRewardAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRewardAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRewardAt: %w", err)
	}
	return oldValue.LastRewardAt, nil
}

// AddLastRewardAt adds u to the "last_reward_at" field.
func (m *GoodRewardMutation) AddLastRewardAt(u int32) {
	if m.addlast_reward_at != nil {
		*m.addlast_reward_at += u
	} else {
		m.addlast_reward_at = &u
	}
}

// AddedLastRewardAt returns the value that was added to the "last_reward_at" field in this mutation.
func (m *GoodRewardMutation) AddedLastRewardAt() (r int32, exists bool) {
	v := m.addlast_reward_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastRewardAt clears the value of the "last_reward_at" field.
func (m *GoodRewardMutation) ClearLastRewardAt() {
	m.last_reward_at = nil
	m.addlast_reward_at = nil
	m.clearedFields[goodreward.FieldLastRewardAt] = struct{}{}
}

// LastRewardAtCleared returns if the "last_reward_at" field was cleared in this mutation.
func (m *GoodRewardMutation) LastRewardAtCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldLastRewardAt]
	return ok
}

// ResetLastRewardAt resets all changes to the "last_reward_at" field.
func (m *GoodRewardMutation) ResetLastRewardAt() {
	m.last_reward_at = nil
	m.addlast_reward_at = nil
	delete(m.clearedFields, goodreward.FieldLastRewardAt)
}

// SetRewardTid sets the "reward_tid" field.
func (m *GoodRewardMutation) SetRewardTid(u uuid.UUID) {
	m.reward_tid = &u
}

// RewardTid returns the value of the "reward_tid" field in the mutation.
func (m *GoodRewardMutation) RewardTid() (r uuid.UUID, exists bool) {
	v := m.reward_tid
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardTid returns the old "reward_tid" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldRewardTid(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardTid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardTid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardTid: %w", err)
	}
	return oldValue.RewardTid, nil
}

// ClearRewardTid clears the value of the "reward_tid" field.
func (m *GoodRewardMutation) ClearRewardTid() {
	m.reward_tid = nil
	m.clearedFields[goodreward.FieldRewardTid] = struct{}{}
}

// RewardTidCleared returns if the "reward_tid" field was cleared in this mutation.
func (m *GoodRewardMutation) RewardTidCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldRewardTid]
	return ok
}

// ResetRewardTid resets all changes to the "reward_tid" field.
func (m *GoodRewardMutation) ResetRewardTid() {
	m.reward_tid = nil
	delete(m.clearedFields, goodreward.FieldRewardTid)
}

// SetNextRewardStartAmount sets the "next_reward_start_amount" field.
func (m *GoodRewardMutation) SetNextRewardStartAmount(d decimal.Decimal) {
	m.next_reward_start_amount = &d
}

// NextRewardStartAmount returns the value of the "next_reward_start_amount" field in the mutation.
func (m *GoodRewardMutation) NextRewardStartAmount() (r decimal.Decimal, exists bool) {
	v := m.next_reward_start_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRewardStartAmount returns the old "next_reward_start_amount" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldNextRewardStartAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRewardStartAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRewardStartAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRewardStartAmount: %w", err)
	}
	return oldValue.NextRewardStartAmount, nil
}

// ClearNextRewardStartAmount clears the value of the "next_reward_start_amount" field.
func (m *GoodRewardMutation) ClearNextRewardStartAmount() {
	m.next_reward_start_amount = nil
	m.clearedFields[goodreward.FieldNextRewardStartAmount] = struct{}{}
}

// NextRewardStartAmountCleared returns if the "next_reward_start_amount" field was cleared in this mutation.
func (m *GoodRewardMutation) NextRewardStartAmountCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldNextRewardStartAmount]
	return ok
}

// ResetNextRewardStartAmount resets all changes to the "next_reward_start_amount" field.
func (m *GoodRewardMutation) ResetNextRewardStartAmount() {
	m.next_reward_start_amount = nil
	delete(m.clearedFields, goodreward.FieldNextRewardStartAmount)
}

// SetLastRewardAmount sets the "last_reward_amount" field.
func (m *GoodRewardMutation) SetLastRewardAmount(d decimal.Decimal) {
	m.last_reward_amount = &d
}

// LastRewardAmount returns the value of the "last_reward_amount" field in the mutation.
func (m *GoodRewardMutation) LastRewardAmount() (r decimal.Decimal, exists bool) {
	v := m.last_reward_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRewardAmount returns the old "last_reward_amount" field's value of the GoodReward entity.
// If the GoodReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardMutation) OldLastRewardAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRewardAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRewardAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRewardAmount: %w", err)
	}
	return oldValue.LastRewardAmount, nil
}

// ClearLastRewardAmount clears the value of the "last_reward_amount" field.
func (m *GoodRewardMutation) ClearLastRewardAmount() {
	m.last_reward_amount = nil
	m.clearedFields[goodreward.FieldLastRewardAmount] = struct{}{}
}

// LastRewardAmountCleared returns if the "last_reward_amount" field was cleared in this mutation.
func (m *GoodRewardMutation) LastRewardAmountCleared() bool {
	_, ok := m.clearedFields[goodreward.FieldLastRewardAmount]
	return ok
}

// ResetLastRewardAmount resets all changes to the "last_reward_amount" field.
func (m *GoodRewardMutation) ResetLastRewardAmount() {
	m.last_reward_amount = nil
	delete(m.clearedFields, goodreward.FieldLastRewardAmount)
}

// Where appends a list predicates to the GoodRewardMutation builder.
func (m *GoodRewardMutation) Where(ps ...predicate.GoodReward) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodRewardMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodReward).
func (m *GoodRewardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodRewardMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, goodreward.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodreward.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodreward.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, goodreward.FieldGoodID)
	}
	if m.reward_state != nil {
		fields = append(fields, goodreward.FieldRewardState)
	}
	if m.last_reward_at != nil {
		fields = append(fields, goodreward.FieldLastRewardAt)
	}
	if m.reward_tid != nil {
		fields = append(fields, goodreward.FieldRewardTid)
	}
	if m.next_reward_start_amount != nil {
		fields = append(fields, goodreward.FieldNextRewardStartAmount)
	}
	if m.last_reward_amount != nil {
		fields = append(fields, goodreward.FieldLastRewardAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodRewardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodreward.FieldCreatedAt:
		return m.CreatedAt()
	case goodreward.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodreward.FieldDeletedAt:
		return m.DeletedAt()
	case goodreward.FieldGoodID:
		return m.GoodID()
	case goodreward.FieldRewardState:
		return m.RewardState()
	case goodreward.FieldLastRewardAt:
		return m.LastRewardAt()
	case goodreward.FieldRewardTid:
		return m.RewardTid()
	case goodreward.FieldNextRewardStartAmount:
		return m.NextRewardStartAmount()
	case goodreward.FieldLastRewardAmount:
		return m.LastRewardAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodRewardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodreward.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodreward.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodreward.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodreward.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodreward.FieldRewardState:
		return m.OldRewardState(ctx)
	case goodreward.FieldLastRewardAt:
		return m.OldLastRewardAt(ctx)
	case goodreward.FieldRewardTid:
		return m.OldRewardTid(ctx)
	case goodreward.FieldNextRewardStartAmount:
		return m.OldNextRewardStartAmount(ctx)
	case goodreward.FieldLastRewardAmount:
		return m.OldLastRewardAmount(ctx)
	}
	return nil, fmt.Errorf("unknown GoodReward field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodreward.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodreward.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodreward.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodreward.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodreward.FieldRewardState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardState(v)
		return nil
	case goodreward.FieldLastRewardAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRewardAt(v)
		return nil
	case goodreward.FieldRewardTid:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardTid(v)
		return nil
	case goodreward.FieldNextRewardStartAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRewardStartAmount(v)
		return nil
	case goodreward.FieldLastRewardAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRewardAmount(v)
		return nil
	}
	return fmt.Errorf("unknown GoodReward field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodRewardMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodreward.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodreward.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodreward.FieldDeletedAt)
	}
	if m.addlast_reward_at != nil {
		fields = append(fields, goodreward.FieldLastRewardAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodRewardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodreward.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodreward.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodreward.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodreward.FieldLastRewardAt:
		return m.AddedLastRewardAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodreward.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodreward.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodreward.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodreward.FieldLastRewardAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastRewardAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodReward numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodRewardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodreward.FieldRewardState) {
		fields = append(fields, goodreward.FieldRewardState)
	}
	if m.FieldCleared(goodreward.FieldLastRewardAt) {
		fields = append(fields, goodreward.FieldLastRewardAt)
	}
	if m.FieldCleared(goodreward.FieldRewardTid) {
		fields = append(fields, goodreward.FieldRewardTid)
	}
	if m.FieldCleared(goodreward.FieldNextRewardStartAmount) {
		fields = append(fields, goodreward.FieldNextRewardStartAmount)
	}
	if m.FieldCleared(goodreward.FieldLastRewardAmount) {
		fields = append(fields, goodreward.FieldLastRewardAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodRewardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodRewardMutation) ClearField(name string) error {
	switch name {
	case goodreward.FieldRewardState:
		m.ClearRewardState()
		return nil
	case goodreward.FieldLastRewardAt:
		m.ClearLastRewardAt()
		return nil
	case goodreward.FieldRewardTid:
		m.ClearRewardTid()
		return nil
	case goodreward.FieldNextRewardStartAmount:
		m.ClearNextRewardStartAmount()
		return nil
	case goodreward.FieldLastRewardAmount:
		m.ClearLastRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodReward nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodRewardMutation) ResetField(name string) error {
	switch name {
	case goodreward.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodreward.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodreward.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodreward.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodreward.FieldRewardState:
		m.ResetRewardState()
		return nil
	case goodreward.FieldLastRewardAt:
		m.ResetLastRewardAt()
		return nil
	case goodreward.FieldRewardTid:
		m.ResetRewardTid()
		return nil
	case goodreward.FieldNextRewardStartAmount:
		m.ResetNextRewardStartAmount()
		return nil
	case goodreward.FieldLastRewardAmount:
		m.ResetLastRewardAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodReward field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodRewardMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodRewardMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodRewardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodRewardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodRewardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodRewardMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodRewardMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodReward unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodRewardMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodReward edge %s", name)
}

// GoodRewardHistoryMutation represents an operation that mutates the GoodRewardHistory nodes in the graph.
type GoodRewardHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	good_id         *uuid.UUID
	reward_date     *uint32
	addreward_date  *int32
	tid             *uuid.UUID
	amount          *decimal.Decimal
	unit_amount     *decimal.Decimal
	unit_net_amount *decimal.Decimal
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*GoodRewardHistory, error)
	predicates      []predicate.GoodRewardHistory
}

var _ ent.Mutation = (*GoodRewardHistoryMutation)(nil)

// goodrewardhistoryOption allows management of the mutation configuration using functional options.
type goodrewardhistoryOption func(*GoodRewardHistoryMutation)

// newGoodRewardHistoryMutation creates new mutation for the GoodRewardHistory entity.
func newGoodRewardHistoryMutation(c config, op Op, opts ...goodrewardhistoryOption) *GoodRewardHistoryMutation {
	m := &GoodRewardHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodRewardHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodRewardHistoryID sets the ID field of the mutation.
func withGoodRewardHistoryID(id uuid.UUID) goodrewardhistoryOption {
	return func(m *GoodRewardHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodRewardHistory
		)
		m.oldValue = func(ctx context.Context) (*GoodRewardHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodRewardHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodRewardHistory sets the old GoodRewardHistory of the mutation.
func withGoodRewardHistory(node *GoodRewardHistory) goodrewardhistoryOption {
	return func(m *GoodRewardHistoryMutation) {
		m.oldValue = func(context.Context) (*GoodRewardHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodRewardHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodRewardHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodRewardHistory entities.
func (m *GoodRewardHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodRewardHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodRewardHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodRewardHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodRewardHistoryMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodRewardHistoryMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodRewardHistoryMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodRewardHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodRewardHistoryMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodRewardHistoryMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodRewardHistoryMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodRewardHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodRewardHistoryMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodRewardHistoryMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodRewardHistoryMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodRewardHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *GoodRewardHistoryMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *GoodRewardHistoryMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *GoodRewardHistoryMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[goodrewardhistory.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *GoodRewardHistoryMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, goodrewardhistory.FieldGoodID)
}

// SetRewardDate sets the "reward_date" field.
func (m *GoodRewardHistoryMutation) SetRewardDate(u uint32) {
	m.reward_date = &u
	m.addreward_date = nil
}

// RewardDate returns the value of the "reward_date" field in the mutation.
func (m *GoodRewardHistoryMutation) RewardDate() (r uint32, exists bool) {
	v := m.reward_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardDate returns the old "reward_date" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldRewardDate(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardDate: %w", err)
	}
	return oldValue.RewardDate, nil
}

// AddRewardDate adds u to the "reward_date" field.
func (m *GoodRewardHistoryMutation) AddRewardDate(u int32) {
	if m.addreward_date != nil {
		*m.addreward_date += u
	} else {
		m.addreward_date = &u
	}
}

// AddedRewardDate returns the value that was added to the "reward_date" field in this mutation.
func (m *GoodRewardHistoryMutation) AddedRewardDate() (r int32, exists bool) {
	v := m.addreward_date
	if v == nil {
		return
	}
	return *v, true
}

// ClearRewardDate clears the value of the "reward_date" field.
func (m *GoodRewardHistoryMutation) ClearRewardDate() {
	m.reward_date = nil
	m.addreward_date = nil
	m.clearedFields[goodrewardhistory.FieldRewardDate] = struct{}{}
}

// RewardDateCleared returns if the "reward_date" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) RewardDateCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldRewardDate]
	return ok
}

// ResetRewardDate resets all changes to the "reward_date" field.
func (m *GoodRewardHistoryMutation) ResetRewardDate() {
	m.reward_date = nil
	m.addreward_date = nil
	delete(m.clearedFields, goodrewardhistory.FieldRewardDate)
}

// SetTid sets the "tid" field.
func (m *GoodRewardHistoryMutation) SetTid(u uuid.UUID) {
	m.tid = &u
}

// Tid returns the value of the "tid" field in the mutation.
func (m *GoodRewardHistoryMutation) Tid() (r uuid.UUID, exists bool) {
	v := m.tid
	if v == nil {
		return
	}
	return *v, true
}

// OldTid returns the old "tid" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldTid(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTid: %w", err)
	}
	return oldValue.Tid, nil
}

// ClearTid clears the value of the "tid" field.
func (m *GoodRewardHistoryMutation) ClearTid() {
	m.tid = nil
	m.clearedFields[goodrewardhistory.FieldTid] = struct{}{}
}

// TidCleared returns if the "tid" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) TidCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldTid]
	return ok
}

// ResetTid resets all changes to the "tid" field.
func (m *GoodRewardHistoryMutation) ResetTid() {
	m.tid = nil
	delete(m.clearedFields, goodrewardhistory.FieldTid)
}

// SetAmount sets the "amount" field.
func (m *GoodRewardHistoryMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *GoodRewardHistoryMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *GoodRewardHistoryMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[goodrewardhistory.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) AmountCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *GoodRewardHistoryMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, goodrewardhistory.FieldAmount)
}

// SetUnitAmount sets the "unit_amount" field.
func (m *GoodRewardHistoryMutation) SetUnitAmount(d decimal.Decimal) {
	m.unit_amount = &d
}

// UnitAmount returns the value of the "unit_amount" field in the mutation.
func (m *GoodRewardHistoryMutation) UnitAmount() (r decimal.Decimal, exists bool) {
	v := m.unit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitAmount returns the old "unit_amount" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldUnitAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitAmount: %w", err)
	}
	return oldValue.UnitAmount, nil
}

// ClearUnitAmount clears the value of the "unit_amount" field.
func (m *GoodRewardHistoryMutation) ClearUnitAmount() {
	m.unit_amount = nil
	m.clearedFields[goodrewardhistory.FieldUnitAmount] = struct{}{}
}

// UnitAmountCleared returns if the "unit_amount" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) UnitAmountCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldUnitAmount]
	return ok
}

// ResetUnitAmount resets all changes to the "unit_amount" field.
func (m *GoodRewardHistoryMutation) ResetUnitAmount() {
	m.unit_amount = nil
	delete(m.clearedFields, goodrewardhistory.FieldUnitAmount)
}

// SetUnitNetAmount sets the "unit_net_amount" field.
func (m *GoodRewardHistoryMutation) SetUnitNetAmount(d decimal.Decimal) {
	m.unit_net_amount = &d
}

// UnitNetAmount returns the value of the "unit_net_amount" field in the mutation.
func (m *GoodRewardHistoryMutation) UnitNetAmount() (r decimal.Decimal, exists bool) {
	v := m.unit_net_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitNetAmount returns the old "unit_net_amount" field's value of the GoodRewardHistory entity.
// If the GoodRewardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodRewardHistoryMutation) OldUnitNetAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitNetAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitNetAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitNetAmount: %w", err)
	}
	return oldValue.UnitNetAmount, nil
}

// ClearUnitNetAmount clears the value of the "unit_net_amount" field.
func (m *GoodRewardHistoryMutation) ClearUnitNetAmount() {
	m.unit_net_amount = nil
	m.clearedFields[goodrewardhistory.FieldUnitNetAmount] = struct{}{}
}

// UnitNetAmountCleared returns if the "unit_net_amount" field was cleared in this mutation.
func (m *GoodRewardHistoryMutation) UnitNetAmountCleared() bool {
	_, ok := m.clearedFields[goodrewardhistory.FieldUnitNetAmount]
	return ok
}

// ResetUnitNetAmount resets all changes to the "unit_net_amount" field.
func (m *GoodRewardHistoryMutation) ResetUnitNetAmount() {
	m.unit_net_amount = nil
	delete(m.clearedFields, goodrewardhistory.FieldUnitNetAmount)
}

// Where appends a list predicates to the GoodRewardHistoryMutation builder.
func (m *GoodRewardHistoryMutation) Where(ps ...predicate.GoodRewardHistory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodRewardHistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodRewardHistory).
func (m *GoodRewardHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodRewardHistoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, goodrewardhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goodrewardhistory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, goodrewardhistory.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, goodrewardhistory.FieldGoodID)
	}
	if m.reward_date != nil {
		fields = append(fields, goodrewardhistory.FieldRewardDate)
	}
	if m.tid != nil {
		fields = append(fields, goodrewardhistory.FieldTid)
	}
	if m.amount != nil {
		fields = append(fields, goodrewardhistory.FieldAmount)
	}
	if m.unit_amount != nil {
		fields = append(fields, goodrewardhistory.FieldUnitAmount)
	}
	if m.unit_net_amount != nil {
		fields = append(fields, goodrewardhistory.FieldUnitNetAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodRewardHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		return m.CreatedAt()
	case goodrewardhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case goodrewardhistory.FieldDeletedAt:
		return m.DeletedAt()
	case goodrewardhistory.FieldGoodID:
		return m.GoodID()
	case goodrewardhistory.FieldRewardDate:
		return m.RewardDate()
	case goodrewardhistory.FieldTid:
		return m.Tid()
	case goodrewardhistory.FieldAmount:
		return m.Amount()
	case goodrewardhistory.FieldUnitAmount:
		return m.UnitAmount()
	case goodrewardhistory.FieldUnitNetAmount:
		return m.UnitNetAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodRewardHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goodrewardhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goodrewardhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case goodrewardhistory.FieldGoodID:
		return m.OldGoodID(ctx)
	case goodrewardhistory.FieldRewardDate:
		return m.OldRewardDate(ctx)
	case goodrewardhistory.FieldTid:
		return m.OldTid(ctx)
	case goodrewardhistory.FieldAmount:
		return m.OldAmount(ctx)
	case goodrewardhistory.FieldUnitAmount:
		return m.OldUnitAmount(ctx)
	case goodrewardhistory.FieldUnitNetAmount:
		return m.OldUnitNetAmount(ctx)
	}
	return nil, fmt.Errorf("unknown GoodRewardHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goodrewardhistory.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goodrewardhistory.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case goodrewardhistory.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case goodrewardhistory.FieldRewardDate:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardDate(v)
		return nil
	case goodrewardhistory.FieldTid:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTid(v)
		return nil
	case goodrewardhistory.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case goodrewardhistory.FieldUnitAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitAmount(v)
		return nil
	case goodrewardhistory.FieldUnitNetAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitNetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodRewardHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, goodrewardhistory.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, goodrewardhistory.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, goodrewardhistory.FieldDeletedAt)
	}
	if m.addreward_date != nil {
		fields = append(fields, goodrewardhistory.FieldRewardDate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodRewardHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		return m.AddedCreatedAt()
	case goodrewardhistory.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case goodrewardhistory.FieldDeletedAt:
		return m.AddedDeletedAt()
	case goodrewardhistory.FieldRewardDate:
		return m.AddedRewardDate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodRewardHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case goodrewardhistory.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case goodrewardhistory.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case goodrewardhistory.FieldRewardDate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRewardDate(v)
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodRewardHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodrewardhistory.FieldGoodID) {
		fields = append(fields, goodrewardhistory.FieldGoodID)
	}
	if m.FieldCleared(goodrewardhistory.FieldRewardDate) {
		fields = append(fields, goodrewardhistory.FieldRewardDate)
	}
	if m.FieldCleared(goodrewardhistory.FieldTid) {
		fields = append(fields, goodrewardhistory.FieldTid)
	}
	if m.FieldCleared(goodrewardhistory.FieldAmount) {
		fields = append(fields, goodrewardhistory.FieldAmount)
	}
	if m.FieldCleared(goodrewardhistory.FieldUnitAmount) {
		fields = append(fields, goodrewardhistory.FieldUnitAmount)
	}
	if m.FieldCleared(goodrewardhistory.FieldUnitNetAmount) {
		fields = append(fields, goodrewardhistory.FieldUnitNetAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodRewardHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodRewardHistoryMutation) ClearField(name string) error {
	switch name {
	case goodrewardhistory.FieldGoodID:
		m.ClearGoodID()
		return nil
	case goodrewardhistory.FieldRewardDate:
		m.ClearRewardDate()
		return nil
	case goodrewardhistory.FieldTid:
		m.ClearTid()
		return nil
	case goodrewardhistory.FieldAmount:
		m.ClearAmount()
		return nil
	case goodrewardhistory.FieldUnitAmount:
		m.ClearUnitAmount()
		return nil
	case goodrewardhistory.FieldUnitNetAmount:
		m.ClearUnitNetAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodRewardHistoryMutation) ResetField(name string) error {
	switch name {
	case goodrewardhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goodrewardhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goodrewardhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case goodrewardhistory.FieldGoodID:
		m.ResetGoodID()
		return nil
	case goodrewardhistory.FieldRewardDate:
		m.ResetRewardDate()
		return nil
	case goodrewardhistory.FieldTid:
		m.ResetTid()
		return nil
	case goodrewardhistory.FieldAmount:
		m.ResetAmount()
		return nil
	case goodrewardhistory.FieldUnitAmount:
		m.ResetUnitAmount()
		return nil
	case goodrewardhistory.FieldUnitNetAmount:
		m.ResetUnitNetAmount()
		return nil
	}
	return fmt.Errorf("unknown GoodRewardHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodRewardHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodRewardHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodRewardHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodRewardHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodRewardHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodRewardHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodRewardHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodRewardHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodRewardHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodRewardHistory edge %s", name)
}

// LikeMutation represents an operation that mutates the Like nodes in the graph.
type LikeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	good_id       *uuid.UUID
	like          *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Like, error)
	predicates    []predicate.Like
}

var _ ent.Mutation = (*LikeMutation)(nil)

// likeOption allows management of the mutation configuration using functional options.
type likeOption func(*LikeMutation)

// newLikeMutation creates new mutation for the Like entity.
func newLikeMutation(c config, op Op, opts ...likeOption) *LikeMutation {
	m := &LikeMutation{
		config:        c,
		op:            op,
		typ:           TypeLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLikeID sets the ID field of the mutation.
func withLikeID(id uuid.UUID) likeOption {
	return func(m *LikeMutation) {
		var (
			err   error
			once  sync.Once
			value *Like
		)
		m.oldValue = func(ctx context.Context) (*Like, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Like.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLike sets the old Like of the mutation.
func withLike(node *Like) likeOption {
	return func(m *LikeMutation) {
		m.oldValue = func(context.Context) (*Like, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Like entities.
func (m *LikeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LikeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LikeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Like.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LikeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LikeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *LikeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *LikeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LikeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LikeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LikeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *LikeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *LikeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LikeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LikeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LikeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *LikeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *LikeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LikeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *LikeMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *LikeMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *LikeMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *LikeMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LikeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LikeMutation) ResetUserID() {
	m.user_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *LikeMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *LikeMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *LikeMutation) ResetGoodID() {
	m.good_id = nil
}

// SetLike sets the "like" field.
func (m *LikeMutation) SetLike(b bool) {
	m.like = &b
}

// Like returns the value of the "like" field in the mutation.
func (m *LikeMutation) Like() (r bool, exists bool) {
	v := m.like
	if v == nil {
		return
	}
	return *v, true
}

// OldLike returns the old "like" field's value of the Like entity.
// If the Like object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LikeMutation) OldLike(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLike is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLike requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLike: %w", err)
	}
	return oldValue.Like, nil
}

// ResetLike resets all changes to the "like" field.
func (m *LikeMutation) ResetLike() {
	m.like = nil
}

// Where appends a list predicates to the LikeMutation builder.
func (m *LikeMutation) Where(ps ...predicate.Like) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LikeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Like).
func (m *LikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LikeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, like.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, like.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, like.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, like.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, like.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, like.FieldGoodID)
	}
	if m.like != nil {
		fields = append(fields, like.FieldLike)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case like.FieldCreatedAt:
		return m.CreatedAt()
	case like.FieldUpdatedAt:
		return m.UpdatedAt()
	case like.FieldDeletedAt:
		return m.DeletedAt()
	case like.FieldAppID:
		return m.AppID()
	case like.FieldUserID:
		return m.UserID()
	case like.FieldGoodID:
		return m.GoodID()
	case like.FieldLike:
		return m.Like()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case like.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case like.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case like.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case like.FieldAppID:
		return m.OldAppID(ctx)
	case like.FieldUserID:
		return m.OldUserID(ctx)
	case like.FieldGoodID:
		return m.OldGoodID(ctx)
	case like.FieldLike:
		return m.OldLike(ctx)
	}
	return nil, fmt.Errorf("unknown Like field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case like.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case like.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case like.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case like.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case like.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case like.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case like.FieldLike:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLike(v)
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LikeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, like.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, like.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, like.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case like.FieldCreatedAt:
		return m.AddedCreatedAt()
	case like.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case like.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case like.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case like.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case like.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Like numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Like nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LikeMutation) ResetField(name string) error {
	switch name {
	case like.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case like.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case like.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case like.FieldAppID:
		m.ResetAppID()
		return nil
	case like.FieldUserID:
		m.ResetUserID()
		return nil
	case like.FieldGoodID:
		m.ResetGoodID()
		return nil
	case like.FieldLike:
		m.ResetLike()
		return nil
	}
	return fmt.Errorf("unknown Like field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LikeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LikeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LikeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Like unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LikeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Like edge %s", name)
}

// PromotionMutation represents an operation that mutates the Promotion nodes in the graph.
type PromotionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	good_id       *uuid.UUID
	message       *string
	start_at      *uint32
	addstart_at   *int32
	end_at        *uint32
	addend_at     *int32
	price         *decimal.Decimal
	posters       *[]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Promotion, error)
	predicates    []predicate.Promotion
}

var _ ent.Mutation = (*PromotionMutation)(nil)

// promotionOption allows management of the mutation configuration using functional options.
type promotionOption func(*PromotionMutation)

// newPromotionMutation creates new mutation for the Promotion entity.
func newPromotionMutation(c config, op Op, opts ...promotionOption) *PromotionMutation {
	m := &PromotionMutation{
		config:        c,
		op:            op,
		typ:           TypePromotion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionID sets the ID field of the mutation.
func withPromotionID(id uuid.UUID) promotionOption {
	return func(m *PromotionMutation) {
		var (
			err   error
			once  sync.Once
			value *Promotion
		)
		m.oldValue = func(ctx context.Context) (*Promotion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Promotion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotion sets the old Promotion of the mutation.
func withPromotion(node *Promotion) promotionOption {
	return func(m *PromotionMutation) {
		m.oldValue = func(context.Context) (*Promotion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Promotion entities.
func (m *PromotionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Promotion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *PromotionMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PromotionMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *PromotionMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PromotionMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *PromotionMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PromotionMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *PromotionMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PromotionMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PromotionMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *PromotionMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *PromotionMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *PromotionMutation) ResetGoodID() {
	m.good_id = nil
}

// SetMessage sets the "message" field.
func (m *PromotionMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *PromotionMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *PromotionMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[promotion.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *PromotionMutation) MessageCleared() bool {
	_, ok := m.clearedFields[promotion.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *PromotionMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, promotion.FieldMessage)
}

// SetStartAt sets the "start_at" field.
func (m *PromotionMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *PromotionMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *PromotionMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *PromotionMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *PromotionMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[promotion.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *PromotionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[promotion.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *PromotionMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, promotion.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *PromotionMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *PromotionMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *PromotionMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *PromotionMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *PromotionMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[promotion.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *PromotionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[promotion.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *PromotionMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, promotion.FieldEndAt)
}

// SetPrice sets the "price" field.
func (m *PromotionMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *PromotionMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *PromotionMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[promotion.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *PromotionMutation) PriceCleared() bool {
	_, ok := m.clearedFields[promotion.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *PromotionMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, promotion.FieldPrice)
}

// SetPosters sets the "posters" field.
func (m *PromotionMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *PromotionMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the Promotion entity.
// If the Promotion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *PromotionMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[promotion.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *PromotionMutation) PostersCleared() bool {
	_, ok := m.clearedFields[promotion.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *PromotionMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, promotion.FieldPosters)
}

// Where appends a list predicates to the PromotionMutation builder.
func (m *PromotionMutation) Where(ps ...predicate.Promotion) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PromotionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Promotion).
func (m *PromotionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, promotion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotion.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotion.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, promotion.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, promotion.FieldGoodID)
	}
	if m.message != nil {
		fields = append(fields, promotion.FieldMessage)
	}
	if m.start_at != nil {
		fields = append(fields, promotion.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, promotion.FieldEndAt)
	}
	if m.price != nil {
		fields = append(fields, promotion.FieldPrice)
	}
	if m.posters != nil {
		fields = append(fields, promotion.FieldPosters)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotion.FieldCreatedAt:
		return m.CreatedAt()
	case promotion.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotion.FieldDeletedAt:
		return m.DeletedAt()
	case promotion.FieldAppID:
		return m.AppID()
	case promotion.FieldGoodID:
		return m.GoodID()
	case promotion.FieldMessage:
		return m.Message()
	case promotion.FieldStartAt:
		return m.StartAt()
	case promotion.FieldEndAt:
		return m.EndAt()
	case promotion.FieldPrice:
		return m.Price()
	case promotion.FieldPosters:
		return m.Posters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotion.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotion.FieldAppID:
		return m.OldAppID(ctx)
	case promotion.FieldGoodID:
		return m.OldGoodID(ctx)
	case promotion.FieldMessage:
		return m.OldMessage(ctx)
	case promotion.FieldStartAt:
		return m.OldStartAt(ctx)
	case promotion.FieldEndAt:
		return m.OldEndAt(ctx)
	case promotion.FieldPrice:
		return m.OldPrice(ctx)
	case promotion.FieldPosters:
		return m.OldPosters(ctx)
	}
	return nil, fmt.Errorf("unknown Promotion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotion.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotion.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotion.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotion.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case promotion.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case promotion.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case promotion.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case promotion.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case promotion.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case promotion.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	}
	return fmt.Errorf("unknown Promotion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, promotion.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, promotion.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, promotion.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, promotion.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, promotion.FieldEndAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotion.FieldCreatedAt:
		return m.AddedCreatedAt()
	case promotion.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case promotion.FieldDeletedAt:
		return m.AddedDeletedAt()
	case promotion.FieldStartAt:
		return m.AddedStartAt()
	case promotion.FieldEndAt:
		return m.AddedEndAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotion.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case promotion.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case promotion.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case promotion.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case promotion.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown Promotion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotion.FieldMessage) {
		fields = append(fields, promotion.FieldMessage)
	}
	if m.FieldCleared(promotion.FieldStartAt) {
		fields = append(fields, promotion.FieldStartAt)
	}
	if m.FieldCleared(promotion.FieldEndAt) {
		fields = append(fields, promotion.FieldEndAt)
	}
	if m.FieldCleared(promotion.FieldPrice) {
		fields = append(fields, promotion.FieldPrice)
	}
	if m.FieldCleared(promotion.FieldPosters) {
		fields = append(fields, promotion.FieldPosters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionMutation) ClearField(name string) error {
	switch name {
	case promotion.FieldMessage:
		m.ClearMessage()
		return nil
	case promotion.FieldStartAt:
		m.ClearStartAt()
		return nil
	case promotion.FieldEndAt:
		m.ClearEndAt()
		return nil
	case promotion.FieldPrice:
		m.ClearPrice()
		return nil
	case promotion.FieldPosters:
		m.ClearPosters()
		return nil
	}
	return fmt.Errorf("unknown Promotion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionMutation) ResetField(name string) error {
	switch name {
	case promotion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotion.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotion.FieldAppID:
		m.ResetAppID()
		return nil
	case promotion.FieldGoodID:
		m.ResetGoodID()
		return nil
	case promotion.FieldMessage:
		m.ResetMessage()
		return nil
	case promotion.FieldStartAt:
		m.ResetStartAt()
		return nil
	case promotion.FieldEndAt:
		m.ResetEndAt()
		return nil
	case promotion.FieldPrice:
		m.ResetPrice()
		return nil
	case promotion.FieldPosters:
		m.ResetPosters()
		return nil
	}
	return fmt.Errorf("unknown Promotion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Promotion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Promotion edge %s", name)
}

// RecommendMutation represents an operation that mutates the Recommend nodes in the graph.
type RecommendMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	app_id          *uuid.UUID
	good_id         *uuid.UUID
	recommender_id  *uuid.UUID
	message         *string
	recommend_index *decimal.Decimal
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Recommend, error)
	predicates      []predicate.Recommend
}

var _ ent.Mutation = (*RecommendMutation)(nil)

// recommendOption allows management of the mutation configuration using functional options.
type recommendOption func(*RecommendMutation)

// newRecommendMutation creates new mutation for the Recommend entity.
func newRecommendMutation(c config, op Op, opts ...recommendOption) *RecommendMutation {
	m := &RecommendMutation{
		config:        c,
		op:            op,
		typ:           TypeRecommend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecommendID sets the ID field of the mutation.
func withRecommendID(id uuid.UUID) recommendOption {
	return func(m *RecommendMutation) {
		var (
			err   error
			once  sync.Once
			value *Recommend
		)
		m.oldValue = func(ctx context.Context) (*Recommend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recommend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecommend sets the old Recommend of the mutation.
func withRecommend(node *Recommend) recommendOption {
	return func(m *RecommendMutation) {
		m.oldValue = func(context.Context) (*Recommend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecommendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecommendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Recommend entities.
func (m *RecommendMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecommendMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecommendMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Recommend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RecommendMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecommendMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RecommendMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RecommendMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecommendMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecommendMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecommendMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RecommendMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RecommendMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecommendMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RecommendMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RecommendMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RecommendMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RecommendMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RecommendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *RecommendMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *RecommendMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *RecommendMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *RecommendMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *RecommendMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *RecommendMutation) ResetGoodID() {
	m.good_id = nil
}

// SetRecommenderID sets the "recommender_id" field.
func (m *RecommendMutation) SetRecommenderID(u uuid.UUID) {
	m.recommender_id = &u
}

// RecommenderID returns the value of the "recommender_id" field in the mutation.
func (m *RecommendMutation) RecommenderID() (r uuid.UUID, exists bool) {
	v := m.recommender_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommenderID returns the old "recommender_id" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldRecommenderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommenderID: %w", err)
	}
	return oldValue.RecommenderID, nil
}

// ClearRecommenderID clears the value of the "recommender_id" field.
func (m *RecommendMutation) ClearRecommenderID() {
	m.recommender_id = nil
	m.clearedFields[recommend.FieldRecommenderID] = struct{}{}
}

// RecommenderIDCleared returns if the "recommender_id" field was cleared in this mutation.
func (m *RecommendMutation) RecommenderIDCleared() bool {
	_, ok := m.clearedFields[recommend.FieldRecommenderID]
	return ok
}

// ResetRecommenderID resets all changes to the "recommender_id" field.
func (m *RecommendMutation) ResetRecommenderID() {
	m.recommender_id = nil
	delete(m.clearedFields, recommend.FieldRecommenderID)
}

// SetMessage sets the "message" field.
func (m *RecommendMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *RecommendMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *RecommendMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[recommend.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *RecommendMutation) MessageCleared() bool {
	_, ok := m.clearedFields[recommend.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *RecommendMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, recommend.FieldMessage)
}

// SetRecommendIndex sets the "recommend_index" field.
func (m *RecommendMutation) SetRecommendIndex(d decimal.Decimal) {
	m.recommend_index = &d
}

// RecommendIndex returns the value of the "recommend_index" field in the mutation.
func (m *RecommendMutation) RecommendIndex() (r decimal.Decimal, exists bool) {
	v := m.recommend_index
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendIndex returns the old "recommend_index" field's value of the Recommend entity.
// If the Recommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecommendMutation) OldRecommendIndex(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendIndex: %w", err)
	}
	return oldValue.RecommendIndex, nil
}

// ClearRecommendIndex clears the value of the "recommend_index" field.
func (m *RecommendMutation) ClearRecommendIndex() {
	m.recommend_index = nil
	m.clearedFields[recommend.FieldRecommendIndex] = struct{}{}
}

// RecommendIndexCleared returns if the "recommend_index" field was cleared in this mutation.
func (m *RecommendMutation) RecommendIndexCleared() bool {
	_, ok := m.clearedFields[recommend.FieldRecommendIndex]
	return ok
}

// ResetRecommendIndex resets all changes to the "recommend_index" field.
func (m *RecommendMutation) ResetRecommendIndex() {
	m.recommend_index = nil
	delete(m.clearedFields, recommend.FieldRecommendIndex)
}

// Where appends a list predicates to the RecommendMutation builder.
func (m *RecommendMutation) Where(ps ...predicate.Recommend) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RecommendMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Recommend).
func (m *RecommendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecommendMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, recommend.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recommend.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, recommend.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, recommend.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, recommend.FieldGoodID)
	}
	if m.recommender_id != nil {
		fields = append(fields, recommend.FieldRecommenderID)
	}
	if m.message != nil {
		fields = append(fields, recommend.FieldMessage)
	}
	if m.recommend_index != nil {
		fields = append(fields, recommend.FieldRecommendIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecommendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recommend.FieldCreatedAt:
		return m.CreatedAt()
	case recommend.FieldUpdatedAt:
		return m.UpdatedAt()
	case recommend.FieldDeletedAt:
		return m.DeletedAt()
	case recommend.FieldAppID:
		return m.AppID()
	case recommend.FieldGoodID:
		return m.GoodID()
	case recommend.FieldRecommenderID:
		return m.RecommenderID()
	case recommend.FieldMessage:
		return m.Message()
	case recommend.FieldRecommendIndex:
		return m.RecommendIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecommendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recommend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recommend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recommend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case recommend.FieldAppID:
		return m.OldAppID(ctx)
	case recommend.FieldGoodID:
		return m.OldGoodID(ctx)
	case recommend.FieldRecommenderID:
		return m.OldRecommenderID(ctx)
	case recommend.FieldMessage:
		return m.OldMessage(ctx)
	case recommend.FieldRecommendIndex:
		return m.OldRecommendIndex(ctx)
	}
	return nil, fmt.Errorf("unknown Recommend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecommendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recommend.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recommend.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recommend.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case recommend.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case recommend.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case recommend.FieldRecommenderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommenderID(v)
		return nil
	case recommend.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case recommend.FieldRecommendIndex:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Recommend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecommendMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, recommend.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, recommend.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, recommend.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecommendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recommend.FieldCreatedAt:
		return m.AddedCreatedAt()
	case recommend.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case recommend.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecommendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recommend.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case recommend.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case recommend.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Recommend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecommendMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recommend.FieldRecommenderID) {
		fields = append(fields, recommend.FieldRecommenderID)
	}
	if m.FieldCleared(recommend.FieldMessage) {
		fields = append(fields, recommend.FieldMessage)
	}
	if m.FieldCleared(recommend.FieldRecommendIndex) {
		fields = append(fields, recommend.FieldRecommendIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecommendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecommendMutation) ClearField(name string) error {
	switch name {
	case recommend.FieldRecommenderID:
		m.ClearRecommenderID()
		return nil
	case recommend.FieldMessage:
		m.ClearMessage()
		return nil
	case recommend.FieldRecommendIndex:
		m.ClearRecommendIndex()
		return nil
	}
	return fmt.Errorf("unknown Recommend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecommendMutation) ResetField(name string) error {
	switch name {
	case recommend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recommend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recommend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case recommend.FieldAppID:
		m.ResetAppID()
		return nil
	case recommend.FieldGoodID:
		m.ResetGoodID()
		return nil
	case recommend.FieldRecommenderID:
		m.ResetRecommenderID()
		return nil
	case recommend.FieldMessage:
		m.ResetMessage()
		return nil
	case recommend.FieldRecommendIndex:
		m.ResetRecommendIndex()
		return nil
	}
	return fmt.Errorf("unknown Recommend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecommendMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecommendMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecommendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecommendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecommendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecommendMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecommendMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Recommend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecommendMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Recommend edge %s", name)
}

// RequiredGoodMutation represents an operation that mutates the RequiredGood nodes in the graph.
type RequiredGoodMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	main_good_id     *uuid.UUID
	required_good_id *uuid.UUID
	must             *bool
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*RequiredGood, error)
	predicates       []predicate.RequiredGood
}

var _ ent.Mutation = (*RequiredGoodMutation)(nil)

// requiredgoodOption allows management of the mutation configuration using functional options.
type requiredgoodOption func(*RequiredGoodMutation)

// newRequiredGoodMutation creates new mutation for the RequiredGood entity.
func newRequiredGoodMutation(c config, op Op, opts ...requiredgoodOption) *RequiredGoodMutation {
	m := &RequiredGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeRequiredGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequiredGoodID sets the ID field of the mutation.
func withRequiredGoodID(id uuid.UUID) requiredgoodOption {
	return func(m *RequiredGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *RequiredGood
		)
		m.oldValue = func(ctx context.Context) (*RequiredGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RequiredGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequiredGood sets the old RequiredGood of the mutation.
func withRequiredGood(node *RequiredGood) requiredgoodOption {
	return func(m *RequiredGoodMutation) {
		m.oldValue = func(context.Context) (*RequiredGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequiredGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequiredGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RequiredGood entities.
func (m *RequiredGoodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequiredGoodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequiredGoodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RequiredGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequiredGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequiredGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RequiredGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RequiredGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequiredGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequiredGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequiredGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RequiredGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RequiredGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequiredGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RequiredGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RequiredGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RequiredGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RequiredGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RequiredGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMainGoodID sets the "main_good_id" field.
func (m *RequiredGoodMutation) SetMainGoodID(u uuid.UUID) {
	m.main_good_id = &u
}

// MainGoodID returns the value of the "main_good_id" field in the mutation.
func (m *RequiredGoodMutation) MainGoodID() (r uuid.UUID, exists bool) {
	v := m.main_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMainGoodID returns the old "main_good_id" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldMainGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainGoodID: %w", err)
	}
	return oldValue.MainGoodID, nil
}

// ResetMainGoodID resets all changes to the "main_good_id" field.
func (m *RequiredGoodMutation) ResetMainGoodID() {
	m.main_good_id = nil
}

// SetRequiredGoodID sets the "required_good_id" field.
func (m *RequiredGoodMutation) SetRequiredGoodID(u uuid.UUID) {
	m.required_good_id = &u
}

// RequiredGoodID returns the value of the "required_good_id" field in the mutation.
func (m *RequiredGoodMutation) RequiredGoodID() (r uuid.UUID, exists bool) {
	v := m.required_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredGoodID returns the old "required_good_id" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldRequiredGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredGoodID: %w", err)
	}
	return oldValue.RequiredGoodID, nil
}

// ResetRequiredGoodID resets all changes to the "required_good_id" field.
func (m *RequiredGoodMutation) ResetRequiredGoodID() {
	m.required_good_id = nil
}

// SetMust sets the "must" field.
func (m *RequiredGoodMutation) SetMust(b bool) {
	m.must = &b
}

// Must returns the value of the "must" field in the mutation.
func (m *RequiredGoodMutation) Must() (r bool, exists bool) {
	v := m.must
	if v == nil {
		return
	}
	return *v, true
}

// OldMust returns the old "must" field's value of the RequiredGood entity.
// If the RequiredGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequiredGoodMutation) OldMust(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMust: %w", err)
	}
	return oldValue.Must, nil
}

// ClearMust clears the value of the "must" field.
func (m *RequiredGoodMutation) ClearMust() {
	m.must = nil
	m.clearedFields[requiredgood.FieldMust] = struct{}{}
}

// MustCleared returns if the "must" field was cleared in this mutation.
func (m *RequiredGoodMutation) MustCleared() bool {
	_, ok := m.clearedFields[requiredgood.FieldMust]
	return ok
}

// ResetMust resets all changes to the "must" field.
func (m *RequiredGoodMutation) ResetMust() {
	m.must = nil
	delete(m.clearedFields, requiredgood.FieldMust)
}

// Where appends a list predicates to the RequiredGoodMutation builder.
func (m *RequiredGoodMutation) Where(ps ...predicate.RequiredGood) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RequiredGoodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RequiredGood).
func (m *RequiredGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequiredGoodMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, requiredgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, requiredgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, requiredgood.FieldDeletedAt)
	}
	if m.main_good_id != nil {
		fields = append(fields, requiredgood.FieldMainGoodID)
	}
	if m.required_good_id != nil {
		fields = append(fields, requiredgood.FieldRequiredGoodID)
	}
	if m.must != nil {
		fields = append(fields, requiredgood.FieldMust)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequiredGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case requiredgood.FieldCreatedAt:
		return m.CreatedAt()
	case requiredgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case requiredgood.FieldDeletedAt:
		return m.DeletedAt()
	case requiredgood.FieldMainGoodID:
		return m.MainGoodID()
	case requiredgood.FieldRequiredGoodID:
		return m.RequiredGoodID()
	case requiredgood.FieldMust:
		return m.Must()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequiredGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case requiredgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case requiredgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case requiredgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case requiredgood.FieldMainGoodID:
		return m.OldMainGoodID(ctx)
	case requiredgood.FieldRequiredGoodID:
		return m.OldRequiredGoodID(ctx)
	case requiredgood.FieldMust:
		return m.OldMust(ctx)
	}
	return nil, fmt.Errorf("unknown RequiredGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequiredGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case requiredgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case requiredgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case requiredgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case requiredgood.FieldMainGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainGoodID(v)
		return nil
	case requiredgood.FieldRequiredGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredGoodID(v)
		return nil
	case requiredgood.FieldMust:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMust(v)
		return nil
	}
	return fmt.Errorf("unknown RequiredGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequiredGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, requiredgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, requiredgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, requiredgood.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequiredGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case requiredgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case requiredgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case requiredgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequiredGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case requiredgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case requiredgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case requiredgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RequiredGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequiredGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(requiredgood.FieldMust) {
		fields = append(fields, requiredgood.FieldMust)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequiredGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequiredGoodMutation) ClearField(name string) error {
	switch name {
	case requiredgood.FieldMust:
		m.ClearMust()
		return nil
	}
	return fmt.Errorf("unknown RequiredGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequiredGoodMutation) ResetField(name string) error {
	switch name {
	case requiredgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case requiredgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case requiredgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case requiredgood.FieldMainGoodID:
		m.ResetMainGoodID()
		return nil
	case requiredgood.FieldRequiredGoodID:
		m.ResetRequiredGoodID()
		return nil
	case requiredgood.FieldMust:
		m.ResetMust()
		return nil
	}
	return fmt.Errorf("unknown RequiredGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequiredGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequiredGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequiredGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequiredGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequiredGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequiredGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequiredGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RequiredGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequiredGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RequiredGood edge %s", name)
}

// ScoreMutation represents an operation that mutates the Score nodes in the graph.
type ScoreMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	good_id       *uuid.UUID
	score         *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Score, error)
	predicates    []predicate.Score
}

var _ ent.Mutation = (*ScoreMutation)(nil)

// scoreOption allows management of the mutation configuration using functional options.
type scoreOption func(*ScoreMutation)

// newScoreMutation creates new mutation for the Score entity.
func newScoreMutation(c config, op Op, opts ...scoreOption) *ScoreMutation {
	m := &ScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScoreID sets the ID field of the mutation.
func withScoreID(id uuid.UUID) scoreOption {
	return func(m *ScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Score
		)
		m.oldValue = func(ctx context.Context) (*Score, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Score.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScore sets the old Score of the mutation.
func withScore(node *Score) scoreOption {
	return func(m *ScoreMutation) {
		m.oldValue = func(context.Context) (*Score, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Score entities.
func (m *ScoreMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScoreMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScoreMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Score.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScoreMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScoreMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *ScoreMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ScoreMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScoreMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScoreMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScoreMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *ScoreMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ScoreMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScoreMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScoreMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *ScoreMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ScoreMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScoreMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *ScoreMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *ScoreMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *ScoreMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *ScoreMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ScoreMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ScoreMutation) ResetUserID() {
	m.user_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *ScoreMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *ScoreMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *ScoreMutation) ResetGoodID() {
	m.good_id = nil
}

// SetScore sets the "score" field.
func (m *ScoreMutation) SetScore(d decimal.Decimal) {
	m.score = &d
}

// Score returns the value of the "score" field in the mutation.
func (m *ScoreMutation) Score() (r decimal.Decimal, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Score entity.
// If the Score object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreMutation) OldScore(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// ClearScore clears the value of the "score" field.
func (m *ScoreMutation) ClearScore() {
	m.score = nil
	m.clearedFields[score.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ScoreMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[score.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ScoreMutation) ResetScore() {
	m.score = nil
	delete(m.clearedFields, score.FieldScore)
}

// Where appends a list predicates to the ScoreMutation builder.
func (m *ScoreMutation) Where(ps ...predicate.Score) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Score).
func (m *ScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScoreMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, score.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, score.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, score.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, score.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, score.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, score.FieldGoodID)
	}
	if m.score != nil {
		fields = append(fields, score.FieldScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case score.FieldCreatedAt:
		return m.CreatedAt()
	case score.FieldUpdatedAt:
		return m.UpdatedAt()
	case score.FieldDeletedAt:
		return m.DeletedAt()
	case score.FieldAppID:
		return m.AppID()
	case score.FieldUserID:
		return m.UserID()
	case score.FieldGoodID:
		return m.GoodID()
	case score.FieldScore:
		return m.Score()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case score.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case score.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case score.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case score.FieldAppID:
		return m.OldAppID(ctx)
	case score.FieldUserID:
		return m.OldUserID(ctx)
	case score.FieldGoodID:
		return m.OldGoodID(ctx)
	case score.FieldScore:
		return m.OldScore(ctx)
	}
	return nil, fmt.Errorf("unknown Score field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case score.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case score.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case score.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case score.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case score.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case score.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case score.FieldScore:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	}
	return fmt.Errorf("unknown Score field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScoreMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, score.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, score.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, score.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case score.FieldCreatedAt:
		return m.AddedCreatedAt()
	case score.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case score.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case score.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case score.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case score.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Score numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(score.FieldScore) {
		fields = append(fields, score.FieldScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScoreMutation) ClearField(name string) error {
	switch name {
	case score.FieldScore:
		m.ClearScore()
		return nil
	}
	return fmt.Errorf("unknown Score nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScoreMutation) ResetField(name string) error {
	switch name {
	case score.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case score.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case score.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case score.FieldAppID:
		m.ResetAppID()
		return nil
	case score.FieldUserID:
		m.ResetUserID()
		return nil
	case score.FieldGoodID:
		m.ResetGoodID()
		return nil
	case score.FieldScore:
		m.ResetScore()
		return nil
	}
	return fmt.Errorf("unknown Score field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScoreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScoreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScoreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScoreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Score unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScoreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Score edge %s", name)
}

// StockMutation represents an operation that mutates the Stock nodes in the graph.
type StockMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	good_id       *uuid.UUID
	total         *decimal.Decimal
	locked        *decimal.Decimal
	in_service    *decimal.Decimal
	wait_start    *decimal.Decimal
	sold          *decimal.Decimal
	app_reserved  *decimal.Decimal
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Stock, error)
	predicates    []predicate.Stock
}

var _ ent.Mutation = (*StockMutation)(nil)

// stockOption allows management of the mutation configuration using functional options.
type stockOption func(*StockMutation)

// newStockMutation creates new mutation for the Stock entity.
func newStockMutation(c config, op Op, opts ...stockOption) *StockMutation {
	m := &StockMutation{
		config:        c,
		op:            op,
		typ:           TypeStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockID sets the ID field of the mutation.
func withStockID(id uuid.UUID) stockOption {
	return func(m *StockMutation) {
		var (
			err   error
			once  sync.Once
			value *Stock
		)
		m.oldValue = func(ctx context.Context) (*Stock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStock sets the old Stock of the mutation.
func withStock(node *Stock) stockOption {
	return func(m *StockMutation) {
		m.oldValue = func(context.Context) (*Stock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stock entities.
func (m *StockMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StockMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *StockMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StockMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StockMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StockMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *StockMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StockMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StockMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StockMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StockMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *StockMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StockMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetGoodID sets the "good_id" field.
func (m *StockMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *StockMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *StockMutation) ResetGoodID() {
	m.good_id = nil
}

// SetTotal sets the "total" field.
func (m *StockMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
}

// Total returns the value of the "total" field in the mutation.
func (m *StockMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldTotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// ClearTotal clears the value of the "total" field.
func (m *StockMutation) ClearTotal() {
	m.total = nil
	m.clearedFields[stock.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *StockMutation) TotalCleared() bool {
	_, ok := m.clearedFields[stock.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *StockMutation) ResetTotal() {
	m.total = nil
	delete(m.clearedFields, stock.FieldTotal)
}

// SetLocked sets the "locked" field.
func (m *StockMutation) SetLocked(d decimal.Decimal) {
	m.locked = &d
}

// Locked returns the value of the "locked" field in the mutation.
func (m *StockMutation) Locked() (r decimal.Decimal, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldLocked(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ClearLocked clears the value of the "locked" field.
func (m *StockMutation) ClearLocked() {
	m.locked = nil
	m.clearedFields[stock.FieldLocked] = struct{}{}
}

// LockedCleared returns if the "locked" field was cleared in this mutation.
func (m *StockMutation) LockedCleared() bool {
	_, ok := m.clearedFields[stock.FieldLocked]
	return ok
}

// ResetLocked resets all changes to the "locked" field.
func (m *StockMutation) ResetLocked() {
	m.locked = nil
	delete(m.clearedFields, stock.FieldLocked)
}

// SetInService sets the "in_service" field.
func (m *StockMutation) SetInService(d decimal.Decimal) {
	m.in_service = &d
}

// InService returns the value of the "in_service" field in the mutation.
func (m *StockMutation) InService() (r decimal.Decimal, exists bool) {
	v := m.in_service
	if v == nil {
		return
	}
	return *v, true
}

// OldInService returns the old "in_service" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldInService(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInService: %w", err)
	}
	return oldValue.InService, nil
}

// ClearInService clears the value of the "in_service" field.
func (m *StockMutation) ClearInService() {
	m.in_service = nil
	m.clearedFields[stock.FieldInService] = struct{}{}
}

// InServiceCleared returns if the "in_service" field was cleared in this mutation.
func (m *StockMutation) InServiceCleared() bool {
	_, ok := m.clearedFields[stock.FieldInService]
	return ok
}

// ResetInService resets all changes to the "in_service" field.
func (m *StockMutation) ResetInService() {
	m.in_service = nil
	delete(m.clearedFields, stock.FieldInService)
}

// SetWaitStart sets the "wait_start" field.
func (m *StockMutation) SetWaitStart(d decimal.Decimal) {
	m.wait_start = &d
}

// WaitStart returns the value of the "wait_start" field in the mutation.
func (m *StockMutation) WaitStart() (r decimal.Decimal, exists bool) {
	v := m.wait_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWaitStart returns the old "wait_start" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldWaitStart(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaitStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaitStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaitStart: %w", err)
	}
	return oldValue.WaitStart, nil
}

// ClearWaitStart clears the value of the "wait_start" field.
func (m *StockMutation) ClearWaitStart() {
	m.wait_start = nil
	m.clearedFields[stock.FieldWaitStart] = struct{}{}
}

// WaitStartCleared returns if the "wait_start" field was cleared in this mutation.
func (m *StockMutation) WaitStartCleared() bool {
	_, ok := m.clearedFields[stock.FieldWaitStart]
	return ok
}

// ResetWaitStart resets all changes to the "wait_start" field.
func (m *StockMutation) ResetWaitStart() {
	m.wait_start = nil
	delete(m.clearedFields, stock.FieldWaitStart)
}

// SetSold sets the "sold" field.
func (m *StockMutation) SetSold(d decimal.Decimal) {
	m.sold = &d
}

// Sold returns the value of the "sold" field in the mutation.
func (m *StockMutation) Sold() (r decimal.Decimal, exists bool) {
	v := m.sold
	if v == nil {
		return
	}
	return *v, true
}

// OldSold returns the old "sold" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldSold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSold: %w", err)
	}
	return oldValue.Sold, nil
}

// ClearSold clears the value of the "sold" field.
func (m *StockMutation) ClearSold() {
	m.sold = nil
	m.clearedFields[stock.FieldSold] = struct{}{}
}

// SoldCleared returns if the "sold" field was cleared in this mutation.
func (m *StockMutation) SoldCleared() bool {
	_, ok := m.clearedFields[stock.FieldSold]
	return ok
}

// ResetSold resets all changes to the "sold" field.
func (m *StockMutation) ResetSold() {
	m.sold = nil
	delete(m.clearedFields, stock.FieldSold)
}

// SetAppReserved sets the "app_reserved" field.
func (m *StockMutation) SetAppReserved(d decimal.Decimal) {
	m.app_reserved = &d
}

// AppReserved returns the value of the "app_reserved" field in the mutation.
func (m *StockMutation) AppReserved() (r decimal.Decimal, exists bool) {
	v := m.app_reserved
	if v == nil {
		return
	}
	return *v, true
}

// OldAppReserved returns the old "app_reserved" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldAppReserved(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppReserved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppReserved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppReserved: %w", err)
	}
	return oldValue.AppReserved, nil
}

// ClearAppReserved clears the value of the "app_reserved" field.
func (m *StockMutation) ClearAppReserved() {
	m.app_reserved = nil
	m.clearedFields[stock.FieldAppReserved] = struct{}{}
}

// AppReservedCleared returns if the "app_reserved" field was cleared in this mutation.
func (m *StockMutation) AppReservedCleared() bool {
	_, ok := m.clearedFields[stock.FieldAppReserved]
	return ok
}

// ResetAppReserved resets all changes to the "app_reserved" field.
func (m *StockMutation) ResetAppReserved() {
	m.app_reserved = nil
	delete(m.clearedFields, stock.FieldAppReserved)
}

// Where appends a list predicates to the StockMutation builder.
func (m *StockMutation) Where(ps ...predicate.Stock) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stock).
func (m *StockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, stock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, stock.FieldDeletedAt)
	}
	if m.good_id != nil {
		fields = append(fields, stock.FieldGoodID)
	}
	if m.total != nil {
		fields = append(fields, stock.FieldTotal)
	}
	if m.locked != nil {
		fields = append(fields, stock.FieldLocked)
	}
	if m.in_service != nil {
		fields = append(fields, stock.FieldInService)
	}
	if m.wait_start != nil {
		fields = append(fields, stock.FieldWaitStart)
	}
	if m.sold != nil {
		fields = append(fields, stock.FieldSold)
	}
	if m.app_reserved != nil {
		fields = append(fields, stock.FieldAppReserved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldCreatedAt:
		return m.CreatedAt()
	case stock.FieldUpdatedAt:
		return m.UpdatedAt()
	case stock.FieldDeletedAt:
		return m.DeletedAt()
	case stock.FieldGoodID:
		return m.GoodID()
	case stock.FieldTotal:
		return m.Total()
	case stock.FieldLocked:
		return m.Locked()
	case stock.FieldInService:
		return m.InService()
	case stock.FieldWaitStart:
		return m.WaitStart()
	case stock.FieldSold:
		return m.Sold()
	case stock.FieldAppReserved:
		return m.AppReserved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case stock.FieldGoodID:
		return m.OldGoodID(ctx)
	case stock.FieldTotal:
		return m.OldTotal(ctx)
	case stock.FieldLocked:
		return m.OldLocked(ctx)
	case stock.FieldInService:
		return m.OldInService(ctx)
	case stock.FieldWaitStart:
		return m.OldWaitStart(ctx)
	case stock.FieldSold:
		return m.OldSold(ctx)
	case stock.FieldAppReserved:
		return m.OldAppReserved(ctx)
	}
	return nil, fmt.Errorf("unknown Stock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stock.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stock.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stock.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case stock.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case stock.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case stock.FieldLocked:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case stock.FieldInService:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInService(v)
		return nil
	case stock.FieldWaitStart:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaitStart(v)
		return nil
	case stock.FieldSold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSold(v)
		return nil
	case stock.FieldAppReserved:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppReserved(v)
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, stock.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, stock.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, stock.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldCreatedAt:
		return m.AddedCreatedAt()
	case stock.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case stock.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stock.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case stock.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case stock.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Stock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stock.FieldTotal) {
		fields = append(fields, stock.FieldTotal)
	}
	if m.FieldCleared(stock.FieldLocked) {
		fields = append(fields, stock.FieldLocked)
	}
	if m.FieldCleared(stock.FieldInService) {
		fields = append(fields, stock.FieldInService)
	}
	if m.FieldCleared(stock.FieldWaitStart) {
		fields = append(fields, stock.FieldWaitStart)
	}
	if m.FieldCleared(stock.FieldSold) {
		fields = append(fields, stock.FieldSold)
	}
	if m.FieldCleared(stock.FieldAppReserved) {
		fields = append(fields, stock.FieldAppReserved)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockMutation) ClearField(name string) error {
	switch name {
	case stock.FieldTotal:
		m.ClearTotal()
		return nil
	case stock.FieldLocked:
		m.ClearLocked()
		return nil
	case stock.FieldInService:
		m.ClearInService()
		return nil
	case stock.FieldWaitStart:
		m.ClearWaitStart()
		return nil
	case stock.FieldSold:
		m.ClearSold()
		return nil
	case stock.FieldAppReserved:
		m.ClearAppReserved()
		return nil
	}
	return fmt.Errorf("unknown Stock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockMutation) ResetField(name string) error {
	switch name {
	case stock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case stock.FieldGoodID:
		m.ResetGoodID()
		return nil
	case stock.FieldTotal:
		m.ResetTotal()
		return nil
	case stock.FieldLocked:
		m.ResetLocked()
		return nil
	case stock.FieldInService:
		m.ResetInService()
		return nil
	case stock.FieldWaitStart:
		m.ResetWaitStart()
		return nil
	case stock.FieldSold:
		m.ResetSold()
		return nil
	case stock.FieldAppReserved:
		m.ResetAppReserved()
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Stock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Stock edge %s", name)
}

// TopMostMutation represents an operation that mutates the TopMost nodes in the graph.
type TopMostMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	created_at                  *uint32
	addcreated_at               *int32
	updated_at                  *uint32
	addupdated_at               *int32
	deleted_at                  *uint32
	adddeleted_at               *int32
	app_id                      *uuid.UUID
	top_most_type               *string
	title                       *string
	message                     *string
	posters                     *[]string
	start_at                    *uint32
	addstart_at                 *int32
	end_at                      *uint32
	addend_at                   *int32
	threshold_credits           *string
	register_elapsed_seconds    *uint32
	addregister_elapsed_seconds *int32
	threshold_purchases         *uint32
	addthreshold_purchases      *int32
	threshold_payment_amount    *string
	kyc_must                    *bool
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*TopMost, error)
	predicates                  []predicate.TopMost
}

var _ ent.Mutation = (*TopMostMutation)(nil)

// topmostOption allows management of the mutation configuration using functional options.
type topmostOption func(*TopMostMutation)

// newTopMostMutation creates new mutation for the TopMost entity.
func newTopMostMutation(c config, op Op, opts ...topmostOption) *TopMostMutation {
	m := &TopMostMutation{
		config:        c,
		op:            op,
		typ:           TypeTopMost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopMostID sets the ID field of the mutation.
func withTopMostID(id uuid.UUID) topmostOption {
	return func(m *TopMostMutation) {
		var (
			err   error
			once  sync.Once
			value *TopMost
		)
		m.oldValue = func(ctx context.Context) (*TopMost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopMost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopMost sets the old TopMost of the mutation.
func withTopMost(node *TopMost) topmostOption {
	return func(m *TopMostMutation) {
		m.oldValue = func(context.Context) (*TopMost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopMostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopMostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopMost entities.
func (m *TopMostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopMostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopMostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopMost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TopMostMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopMostMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TopMostMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TopMostMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopMostMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopMostMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopMostMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TopMostMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TopMostMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopMostMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TopMostMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TopMostMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TopMostMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TopMostMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TopMostMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *TopMostMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *TopMostMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *TopMostMutation) ResetAppID() {
	m.app_id = nil
}

// SetTopMostType sets the "top_most_type" field.
func (m *TopMostMutation) SetTopMostType(s string) {
	m.top_most_type = &s
}

// TopMostType returns the value of the "top_most_type" field in the mutation.
func (m *TopMostMutation) TopMostType() (r string, exists bool) {
	v := m.top_most_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTopMostType returns the old "top_most_type" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldTopMostType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopMostType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopMostType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopMostType: %w", err)
	}
	return oldValue.TopMostType, nil
}

// ClearTopMostType clears the value of the "top_most_type" field.
func (m *TopMostMutation) ClearTopMostType() {
	m.top_most_type = nil
	m.clearedFields[topmost.FieldTopMostType] = struct{}{}
}

// TopMostTypeCleared returns if the "top_most_type" field was cleared in this mutation.
func (m *TopMostMutation) TopMostTypeCleared() bool {
	_, ok := m.clearedFields[topmost.FieldTopMostType]
	return ok
}

// ResetTopMostType resets all changes to the "top_most_type" field.
func (m *TopMostMutation) ResetTopMostType() {
	m.top_most_type = nil
	delete(m.clearedFields, topmost.FieldTopMostType)
}

// SetTitle sets the "title" field.
func (m *TopMostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TopMostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *TopMostMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[topmost.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *TopMostMutation) TitleCleared() bool {
	_, ok := m.clearedFields[topmost.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *TopMostMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, topmost.FieldTitle)
}

// SetMessage sets the "message" field.
func (m *TopMostMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *TopMostMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *TopMostMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[topmost.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *TopMostMutation) MessageCleared() bool {
	_, ok := m.clearedFields[topmost.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *TopMostMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, topmost.FieldMessage)
}

// SetPosters sets the "posters" field.
func (m *TopMostMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *TopMostMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *TopMostMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[topmost.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *TopMostMutation) PostersCleared() bool {
	_, ok := m.clearedFields[topmost.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *TopMostMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, topmost.FieldPosters)
}

// SetStartAt sets the "start_at" field.
func (m *TopMostMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *TopMostMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *TopMostMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *TopMostMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *TopMostMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[topmost.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *TopMostMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[topmost.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *TopMostMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, topmost.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *TopMostMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *TopMostMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *TopMostMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *TopMostMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *TopMostMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[topmost.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *TopMostMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[topmost.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *TopMostMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, topmost.FieldEndAt)
}

// SetThresholdCredits sets the "threshold_credits" field.
func (m *TopMostMutation) SetThresholdCredits(s string) {
	m.threshold_credits = &s
}

// ThresholdCredits returns the value of the "threshold_credits" field in the mutation.
func (m *TopMostMutation) ThresholdCredits() (r string, exists bool) {
	v := m.threshold_credits
	if v == nil {
		return
	}
	return *v, true
}

// OldThresholdCredits returns the old "threshold_credits" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldThresholdCredits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThresholdCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThresholdCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThresholdCredits: %w", err)
	}
	return oldValue.ThresholdCredits, nil
}

// ClearThresholdCredits clears the value of the "threshold_credits" field.
func (m *TopMostMutation) ClearThresholdCredits() {
	m.threshold_credits = nil
	m.clearedFields[topmost.FieldThresholdCredits] = struct{}{}
}

// ThresholdCreditsCleared returns if the "threshold_credits" field was cleared in this mutation.
func (m *TopMostMutation) ThresholdCreditsCleared() bool {
	_, ok := m.clearedFields[topmost.FieldThresholdCredits]
	return ok
}

// ResetThresholdCredits resets all changes to the "threshold_credits" field.
func (m *TopMostMutation) ResetThresholdCredits() {
	m.threshold_credits = nil
	delete(m.clearedFields, topmost.FieldThresholdCredits)
}

// SetRegisterElapsedSeconds sets the "register_elapsed_seconds" field.
func (m *TopMostMutation) SetRegisterElapsedSeconds(u uint32) {
	m.register_elapsed_seconds = &u
	m.addregister_elapsed_seconds = nil
}

// RegisterElapsedSeconds returns the value of the "register_elapsed_seconds" field in the mutation.
func (m *TopMostMutation) RegisterElapsedSeconds() (r uint32, exists bool) {
	v := m.register_elapsed_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterElapsedSeconds returns the old "register_elapsed_seconds" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldRegisterElapsedSeconds(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterElapsedSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterElapsedSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterElapsedSeconds: %w", err)
	}
	return oldValue.RegisterElapsedSeconds, nil
}

// AddRegisterElapsedSeconds adds u to the "register_elapsed_seconds" field.
func (m *TopMostMutation) AddRegisterElapsedSeconds(u int32) {
	if m.addregister_elapsed_seconds != nil {
		*m.addregister_elapsed_seconds += u
	} else {
		m.addregister_elapsed_seconds = &u
	}
}

// AddedRegisterElapsedSeconds returns the value that was added to the "register_elapsed_seconds" field in this mutation.
func (m *TopMostMutation) AddedRegisterElapsedSeconds() (r int32, exists bool) {
	v := m.addregister_elapsed_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegisterElapsedSeconds clears the value of the "register_elapsed_seconds" field.
func (m *TopMostMutation) ClearRegisterElapsedSeconds() {
	m.register_elapsed_seconds = nil
	m.addregister_elapsed_seconds = nil
	m.clearedFields[topmost.FieldRegisterElapsedSeconds] = struct{}{}
}

// RegisterElapsedSecondsCleared returns if the "register_elapsed_seconds" field was cleared in this mutation.
func (m *TopMostMutation) RegisterElapsedSecondsCleared() bool {
	_, ok := m.clearedFields[topmost.FieldRegisterElapsedSeconds]
	return ok
}

// ResetRegisterElapsedSeconds resets all changes to the "register_elapsed_seconds" field.
func (m *TopMostMutation) ResetRegisterElapsedSeconds() {
	m.register_elapsed_seconds = nil
	m.addregister_elapsed_seconds = nil
	delete(m.clearedFields, topmost.FieldRegisterElapsedSeconds)
}

// SetThresholdPurchases sets the "threshold_purchases" field.
func (m *TopMostMutation) SetThresholdPurchases(u uint32) {
	m.threshold_purchases = &u
	m.addthreshold_purchases = nil
}

// ThresholdPurchases returns the value of the "threshold_purchases" field in the mutation.
func (m *TopMostMutation) ThresholdPurchases() (r uint32, exists bool) {
	v := m.threshold_purchases
	if v == nil {
		return
	}
	return *v, true
}

// OldThresholdPurchases returns the old "threshold_purchases" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldThresholdPurchases(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThresholdPurchases is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThresholdPurchases requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThresholdPurchases: %w", err)
	}
	return oldValue.ThresholdPurchases, nil
}

// AddThresholdPurchases adds u to the "threshold_purchases" field.
func (m *TopMostMutation) AddThresholdPurchases(u int32) {
	if m.addthreshold_purchases != nil {
		*m.addthreshold_purchases += u
	} else {
		m.addthreshold_purchases = &u
	}
}

// AddedThresholdPurchases returns the value that was added to the "threshold_purchases" field in this mutation.
func (m *TopMostMutation) AddedThresholdPurchases() (r int32, exists bool) {
	v := m.addthreshold_purchases
	if v == nil {
		return
	}
	return *v, true
}

// ClearThresholdPurchases clears the value of the "threshold_purchases" field.
func (m *TopMostMutation) ClearThresholdPurchases() {
	m.threshold_purchases = nil
	m.addthreshold_purchases = nil
	m.clearedFields[topmost.FieldThresholdPurchases] = struct{}{}
}

// ThresholdPurchasesCleared returns if the "threshold_purchases" field was cleared in this mutation.
func (m *TopMostMutation) ThresholdPurchasesCleared() bool {
	_, ok := m.clearedFields[topmost.FieldThresholdPurchases]
	return ok
}

// ResetThresholdPurchases resets all changes to the "threshold_purchases" field.
func (m *TopMostMutation) ResetThresholdPurchases() {
	m.threshold_purchases = nil
	m.addthreshold_purchases = nil
	delete(m.clearedFields, topmost.FieldThresholdPurchases)
}

// SetThresholdPaymentAmount sets the "threshold_payment_amount" field.
func (m *TopMostMutation) SetThresholdPaymentAmount(s string) {
	m.threshold_payment_amount = &s
}

// ThresholdPaymentAmount returns the value of the "threshold_payment_amount" field in the mutation.
func (m *TopMostMutation) ThresholdPaymentAmount() (r string, exists bool) {
	v := m.threshold_payment_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldThresholdPaymentAmount returns the old "threshold_payment_amount" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldThresholdPaymentAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThresholdPaymentAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThresholdPaymentAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThresholdPaymentAmount: %w", err)
	}
	return oldValue.ThresholdPaymentAmount, nil
}

// ClearThresholdPaymentAmount clears the value of the "threshold_payment_amount" field.
func (m *TopMostMutation) ClearThresholdPaymentAmount() {
	m.threshold_payment_amount = nil
	m.clearedFields[topmost.FieldThresholdPaymentAmount] = struct{}{}
}

// ThresholdPaymentAmountCleared returns if the "threshold_payment_amount" field was cleared in this mutation.
func (m *TopMostMutation) ThresholdPaymentAmountCleared() bool {
	_, ok := m.clearedFields[topmost.FieldThresholdPaymentAmount]
	return ok
}

// ResetThresholdPaymentAmount resets all changes to the "threshold_payment_amount" field.
func (m *TopMostMutation) ResetThresholdPaymentAmount() {
	m.threshold_payment_amount = nil
	delete(m.clearedFields, topmost.FieldThresholdPaymentAmount)
}

// SetKycMust sets the "kyc_must" field.
func (m *TopMostMutation) SetKycMust(b bool) {
	m.kyc_must = &b
}

// KycMust returns the value of the "kyc_must" field in the mutation.
func (m *TopMostMutation) KycMust() (r bool, exists bool) {
	v := m.kyc_must
	if v == nil {
		return
	}
	return *v, true
}

// OldKycMust returns the old "kyc_must" field's value of the TopMost entity.
// If the TopMost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostMutation) OldKycMust(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKycMust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKycMust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKycMust: %w", err)
	}
	return oldValue.KycMust, nil
}

// ClearKycMust clears the value of the "kyc_must" field.
func (m *TopMostMutation) ClearKycMust() {
	m.kyc_must = nil
	m.clearedFields[topmost.FieldKycMust] = struct{}{}
}

// KycMustCleared returns if the "kyc_must" field was cleared in this mutation.
func (m *TopMostMutation) KycMustCleared() bool {
	_, ok := m.clearedFields[topmost.FieldKycMust]
	return ok
}

// ResetKycMust resets all changes to the "kyc_must" field.
func (m *TopMostMutation) ResetKycMust() {
	m.kyc_must = nil
	delete(m.clearedFields, topmost.FieldKycMust)
}

// Where appends a list predicates to the TopMostMutation builder.
func (m *TopMostMutation) Where(ps ...predicate.TopMost) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TopMostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TopMost).
func (m *TopMostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopMostMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, topmost.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topmost.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, topmost.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, topmost.FieldAppID)
	}
	if m.top_most_type != nil {
		fields = append(fields, topmost.FieldTopMostType)
	}
	if m.title != nil {
		fields = append(fields, topmost.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, topmost.FieldMessage)
	}
	if m.posters != nil {
		fields = append(fields, topmost.FieldPosters)
	}
	if m.start_at != nil {
		fields = append(fields, topmost.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, topmost.FieldEndAt)
	}
	if m.threshold_credits != nil {
		fields = append(fields, topmost.FieldThresholdCredits)
	}
	if m.register_elapsed_seconds != nil {
		fields = append(fields, topmost.FieldRegisterElapsedSeconds)
	}
	if m.threshold_purchases != nil {
		fields = append(fields, topmost.FieldThresholdPurchases)
	}
	if m.threshold_payment_amount != nil {
		fields = append(fields, topmost.FieldThresholdPaymentAmount)
	}
	if m.kyc_must != nil {
		fields = append(fields, topmost.FieldKycMust)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopMostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topmost.FieldCreatedAt:
		return m.CreatedAt()
	case topmost.FieldUpdatedAt:
		return m.UpdatedAt()
	case topmost.FieldDeletedAt:
		return m.DeletedAt()
	case topmost.FieldAppID:
		return m.AppID()
	case topmost.FieldTopMostType:
		return m.TopMostType()
	case topmost.FieldTitle:
		return m.Title()
	case topmost.FieldMessage:
		return m.Message()
	case topmost.FieldPosters:
		return m.Posters()
	case topmost.FieldStartAt:
		return m.StartAt()
	case topmost.FieldEndAt:
		return m.EndAt()
	case topmost.FieldThresholdCredits:
		return m.ThresholdCredits()
	case topmost.FieldRegisterElapsedSeconds:
		return m.RegisterElapsedSeconds()
	case topmost.FieldThresholdPurchases:
		return m.ThresholdPurchases()
	case topmost.FieldThresholdPaymentAmount:
		return m.ThresholdPaymentAmount()
	case topmost.FieldKycMust:
		return m.KycMust()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopMostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topmost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topmost.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case topmost.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case topmost.FieldAppID:
		return m.OldAppID(ctx)
	case topmost.FieldTopMostType:
		return m.OldTopMostType(ctx)
	case topmost.FieldTitle:
		return m.OldTitle(ctx)
	case topmost.FieldMessage:
		return m.OldMessage(ctx)
	case topmost.FieldPosters:
		return m.OldPosters(ctx)
	case topmost.FieldStartAt:
		return m.OldStartAt(ctx)
	case topmost.FieldEndAt:
		return m.OldEndAt(ctx)
	case topmost.FieldThresholdCredits:
		return m.OldThresholdCredits(ctx)
	case topmost.FieldRegisterElapsedSeconds:
		return m.OldRegisterElapsedSeconds(ctx)
	case topmost.FieldThresholdPurchases:
		return m.OldThresholdPurchases(ctx)
	case topmost.FieldThresholdPaymentAmount:
		return m.OldThresholdPaymentAmount(ctx)
	case topmost.FieldKycMust:
		return m.OldKycMust(ctx)
	}
	return nil, fmt.Errorf("unknown TopMost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topmost.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topmost.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case topmost.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case topmost.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case topmost.FieldTopMostType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopMostType(v)
		return nil
	case topmost.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case topmost.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case topmost.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	case topmost.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case topmost.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case topmost.FieldThresholdCredits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThresholdCredits(v)
		return nil
	case topmost.FieldRegisterElapsedSeconds:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterElapsedSeconds(v)
		return nil
	case topmost.FieldThresholdPurchases:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThresholdPurchases(v)
		return nil
	case topmost.FieldThresholdPaymentAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThresholdPaymentAmount(v)
		return nil
	case topmost.FieldKycMust:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKycMust(v)
		return nil
	}
	return fmt.Errorf("unknown TopMost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopMostMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, topmost.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, topmost.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, topmost.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, topmost.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, topmost.FieldEndAt)
	}
	if m.addregister_elapsed_seconds != nil {
		fields = append(fields, topmost.FieldRegisterElapsedSeconds)
	}
	if m.addthreshold_purchases != nil {
		fields = append(fields, topmost.FieldThresholdPurchases)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopMostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case topmost.FieldCreatedAt:
		return m.AddedCreatedAt()
	case topmost.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case topmost.FieldDeletedAt:
		return m.AddedDeletedAt()
	case topmost.FieldStartAt:
		return m.AddedStartAt()
	case topmost.FieldEndAt:
		return m.AddedEndAt()
	case topmost.FieldRegisterElapsedSeconds:
		return m.AddedRegisterElapsedSeconds()
	case topmost.FieldThresholdPurchases:
		return m.AddedThresholdPurchases()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case topmost.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case topmost.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case topmost.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case topmost.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case topmost.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	case topmost.FieldRegisterElapsedSeconds:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegisterElapsedSeconds(v)
		return nil
	case topmost.FieldThresholdPurchases:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThresholdPurchases(v)
		return nil
	}
	return fmt.Errorf("unknown TopMost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopMostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topmost.FieldTopMostType) {
		fields = append(fields, topmost.FieldTopMostType)
	}
	if m.FieldCleared(topmost.FieldTitle) {
		fields = append(fields, topmost.FieldTitle)
	}
	if m.FieldCleared(topmost.FieldMessage) {
		fields = append(fields, topmost.FieldMessage)
	}
	if m.FieldCleared(topmost.FieldPosters) {
		fields = append(fields, topmost.FieldPosters)
	}
	if m.FieldCleared(topmost.FieldStartAt) {
		fields = append(fields, topmost.FieldStartAt)
	}
	if m.FieldCleared(topmost.FieldEndAt) {
		fields = append(fields, topmost.FieldEndAt)
	}
	if m.FieldCleared(topmost.FieldThresholdCredits) {
		fields = append(fields, topmost.FieldThresholdCredits)
	}
	if m.FieldCleared(topmost.FieldRegisterElapsedSeconds) {
		fields = append(fields, topmost.FieldRegisterElapsedSeconds)
	}
	if m.FieldCleared(topmost.FieldThresholdPurchases) {
		fields = append(fields, topmost.FieldThresholdPurchases)
	}
	if m.FieldCleared(topmost.FieldThresholdPaymentAmount) {
		fields = append(fields, topmost.FieldThresholdPaymentAmount)
	}
	if m.FieldCleared(topmost.FieldKycMust) {
		fields = append(fields, topmost.FieldKycMust)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopMostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopMostMutation) ClearField(name string) error {
	switch name {
	case topmost.FieldTopMostType:
		m.ClearTopMostType()
		return nil
	case topmost.FieldTitle:
		m.ClearTitle()
		return nil
	case topmost.FieldMessage:
		m.ClearMessage()
		return nil
	case topmost.FieldPosters:
		m.ClearPosters()
		return nil
	case topmost.FieldStartAt:
		m.ClearStartAt()
		return nil
	case topmost.FieldEndAt:
		m.ClearEndAt()
		return nil
	case topmost.FieldThresholdCredits:
		m.ClearThresholdCredits()
		return nil
	case topmost.FieldRegisterElapsedSeconds:
		m.ClearRegisterElapsedSeconds()
		return nil
	case topmost.FieldThresholdPurchases:
		m.ClearThresholdPurchases()
		return nil
	case topmost.FieldThresholdPaymentAmount:
		m.ClearThresholdPaymentAmount()
		return nil
	case topmost.FieldKycMust:
		m.ClearKycMust()
		return nil
	}
	return fmt.Errorf("unknown TopMost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopMostMutation) ResetField(name string) error {
	switch name {
	case topmost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topmost.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case topmost.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case topmost.FieldAppID:
		m.ResetAppID()
		return nil
	case topmost.FieldTopMostType:
		m.ResetTopMostType()
		return nil
	case topmost.FieldTitle:
		m.ResetTitle()
		return nil
	case topmost.FieldMessage:
		m.ResetMessage()
		return nil
	case topmost.FieldPosters:
		m.ResetPosters()
		return nil
	case topmost.FieldStartAt:
		m.ResetStartAt()
		return nil
	case topmost.FieldEndAt:
		m.ResetEndAt()
		return nil
	case topmost.FieldThresholdCredits:
		m.ResetThresholdCredits()
		return nil
	case topmost.FieldRegisterElapsedSeconds:
		m.ResetRegisterElapsedSeconds()
		return nil
	case topmost.FieldThresholdPurchases:
		m.ResetThresholdPurchases()
		return nil
	case topmost.FieldThresholdPaymentAmount:
		m.ResetThresholdPaymentAmount()
		return nil
	case topmost.FieldKycMust:
		m.ResetKycMust()
		return nil
	}
	return fmt.Errorf("unknown TopMost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopMostMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopMostMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopMostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopMostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopMostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopMostMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopMostMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TopMost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopMostMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TopMost edge %s", name)
}

// TopMostGoodMutation represents an operation that mutates the TopMostGood nodes in the graph.
type TopMostGoodMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	app_id           *uuid.UUID
	good_id          *uuid.UUID
	app_good_id      *uuid.UUID
	top_most_id      *uuid.UUID
	display_index    *uint32
	adddisplay_index *int32
	posters          *[]string
	price            *decimal.Decimal
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TopMostGood, error)
	predicates       []predicate.TopMostGood
}

var _ ent.Mutation = (*TopMostGoodMutation)(nil)

// topmostgoodOption allows management of the mutation configuration using functional options.
type topmostgoodOption func(*TopMostGoodMutation)

// newTopMostGoodMutation creates new mutation for the TopMostGood entity.
func newTopMostGoodMutation(c config, op Op, opts ...topmostgoodOption) *TopMostGoodMutation {
	m := &TopMostGoodMutation{
		config:        c,
		op:            op,
		typ:           TypeTopMostGood,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopMostGoodID sets the ID field of the mutation.
func withTopMostGoodID(id uuid.UUID) topmostgoodOption {
	return func(m *TopMostGoodMutation) {
		var (
			err   error
			once  sync.Once
			value *TopMostGood
		)
		m.oldValue = func(ctx context.Context) (*TopMostGood, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopMostGood.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopMostGood sets the old TopMostGood of the mutation.
func withTopMostGood(node *TopMostGood) topmostgoodOption {
	return func(m *TopMostGoodMutation) {
		m.oldValue = func(context.Context) (*TopMostGood, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopMostGoodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopMostGoodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopMostGood entities.
func (m *TopMostGoodMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopMostGoodMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopMostGoodMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopMostGood.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TopMostGoodMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopMostGoodMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TopMostGoodMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TopMostGoodMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopMostGoodMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopMostGoodMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopMostGoodMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TopMostGoodMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TopMostGoodMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopMostGoodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TopMostGoodMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TopMostGoodMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TopMostGoodMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TopMostGoodMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TopMostGoodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *TopMostGoodMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *TopMostGoodMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *TopMostGoodMutation) ResetAppID() {
	m.app_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *TopMostGoodMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *TopMostGoodMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *TopMostGoodMutation) ResetGoodID() {
	m.good_id = nil
}

// SetAppGoodID sets the "app_good_id" field.
func (m *TopMostGoodMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *TopMostGoodMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *TopMostGoodMutation) ResetAppGoodID() {
	m.app_good_id = nil
}

// SetTopMostID sets the "top_most_id" field.
func (m *TopMostGoodMutation) SetTopMostID(u uuid.UUID) {
	m.top_most_id = &u
}

// TopMostID returns the value of the "top_most_id" field in the mutation.
func (m *TopMostGoodMutation) TopMostID() (r uuid.UUID, exists bool) {
	v := m.top_most_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopMostID returns the old "top_most_id" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldTopMostID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopMostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopMostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopMostID: %w", err)
	}
	return oldValue.TopMostID, nil
}

// ResetTopMostID resets all changes to the "top_most_id" field.
func (m *TopMostGoodMutation) ResetTopMostID() {
	m.top_most_id = nil
}

// SetDisplayIndex sets the "display_index" field.
func (m *TopMostGoodMutation) SetDisplayIndex(u uint32) {
	m.display_index = &u
	m.adddisplay_index = nil
}

// DisplayIndex returns the value of the "display_index" field in the mutation.
func (m *TopMostGoodMutation) DisplayIndex() (r uint32, exists bool) {
	v := m.display_index
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayIndex returns the old "display_index" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldDisplayIndex(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayIndex: %w", err)
	}
	return oldValue.DisplayIndex, nil
}

// AddDisplayIndex adds u to the "display_index" field.
func (m *TopMostGoodMutation) AddDisplayIndex(u int32) {
	if m.adddisplay_index != nil {
		*m.adddisplay_index += u
	} else {
		m.adddisplay_index = &u
	}
}

// AddedDisplayIndex returns the value that was added to the "display_index" field in this mutation.
func (m *TopMostGoodMutation) AddedDisplayIndex() (r int32, exists bool) {
	v := m.adddisplay_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplayIndex clears the value of the "display_index" field.
func (m *TopMostGoodMutation) ClearDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	m.clearedFields[topmostgood.FieldDisplayIndex] = struct{}{}
}

// DisplayIndexCleared returns if the "display_index" field was cleared in this mutation.
func (m *TopMostGoodMutation) DisplayIndexCleared() bool {
	_, ok := m.clearedFields[topmostgood.FieldDisplayIndex]
	return ok
}

// ResetDisplayIndex resets all changes to the "display_index" field.
func (m *TopMostGoodMutation) ResetDisplayIndex() {
	m.display_index = nil
	m.adddisplay_index = nil
	delete(m.clearedFields, topmostgood.FieldDisplayIndex)
}

// SetPosters sets the "posters" field.
func (m *TopMostGoodMutation) SetPosters(s []string) {
	m.posters = &s
}

// Posters returns the value of the "posters" field in the mutation.
func (m *TopMostGoodMutation) Posters() (r []string, exists bool) {
	v := m.posters
	if v == nil {
		return
	}
	return *v, true
}

// OldPosters returns the old "posters" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldPosters(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosters: %w", err)
	}
	return oldValue.Posters, nil
}

// ClearPosters clears the value of the "posters" field.
func (m *TopMostGoodMutation) ClearPosters() {
	m.posters = nil
	m.clearedFields[topmostgood.FieldPosters] = struct{}{}
}

// PostersCleared returns if the "posters" field was cleared in this mutation.
func (m *TopMostGoodMutation) PostersCleared() bool {
	_, ok := m.clearedFields[topmostgood.FieldPosters]
	return ok
}

// ResetPosters resets all changes to the "posters" field.
func (m *TopMostGoodMutation) ResetPosters() {
	m.posters = nil
	delete(m.clearedFields, topmostgood.FieldPosters)
}

// SetPrice sets the "price" field.
func (m *TopMostGoodMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *TopMostGoodMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the TopMostGood entity.
// If the TopMostGood object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopMostGoodMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ClearPrice clears the value of the "price" field.
func (m *TopMostGoodMutation) ClearPrice() {
	m.price = nil
	m.clearedFields[topmostgood.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *TopMostGoodMutation) PriceCleared() bool {
	_, ok := m.clearedFields[topmostgood.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *TopMostGoodMutation) ResetPrice() {
	m.price = nil
	delete(m.clearedFields, topmostgood.FieldPrice)
}

// Where appends a list predicates to the TopMostGoodMutation builder.
func (m *TopMostGoodMutation) Where(ps ...predicate.TopMostGood) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TopMostGoodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TopMostGood).
func (m *TopMostGoodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopMostGoodMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, topmostgood.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topmostgood.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, topmostgood.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, topmostgood.FieldAppID)
	}
	if m.good_id != nil {
		fields = append(fields, topmostgood.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, topmostgood.FieldAppGoodID)
	}
	if m.top_most_id != nil {
		fields = append(fields, topmostgood.FieldTopMostID)
	}
	if m.display_index != nil {
		fields = append(fields, topmostgood.FieldDisplayIndex)
	}
	if m.posters != nil {
		fields = append(fields, topmostgood.FieldPosters)
	}
	if m.price != nil {
		fields = append(fields, topmostgood.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopMostGoodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topmostgood.FieldCreatedAt:
		return m.CreatedAt()
	case topmostgood.FieldUpdatedAt:
		return m.UpdatedAt()
	case topmostgood.FieldDeletedAt:
		return m.DeletedAt()
	case topmostgood.FieldAppID:
		return m.AppID()
	case topmostgood.FieldGoodID:
		return m.GoodID()
	case topmostgood.FieldAppGoodID:
		return m.AppGoodID()
	case topmostgood.FieldTopMostID:
		return m.TopMostID()
	case topmostgood.FieldDisplayIndex:
		return m.DisplayIndex()
	case topmostgood.FieldPosters:
		return m.Posters()
	case topmostgood.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopMostGoodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topmostgood.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topmostgood.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case topmostgood.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case topmostgood.FieldAppID:
		return m.OldAppID(ctx)
	case topmostgood.FieldGoodID:
		return m.OldGoodID(ctx)
	case topmostgood.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case topmostgood.FieldTopMostID:
		return m.OldTopMostID(ctx)
	case topmostgood.FieldDisplayIndex:
		return m.OldDisplayIndex(ctx)
	case topmostgood.FieldPosters:
		return m.OldPosters(ctx)
	case topmostgood.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown TopMostGood field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostGoodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topmostgood.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topmostgood.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case topmostgood.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case topmostgood.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case topmostgood.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case topmostgood.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case topmostgood.FieldTopMostID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopMostID(v)
		return nil
	case topmostgood.FieldDisplayIndex:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayIndex(v)
		return nil
	case topmostgood.FieldPosters:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosters(v)
		return nil
	case topmostgood.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostGood field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopMostGoodMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, topmostgood.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, topmostgood.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, topmostgood.FieldDeletedAt)
	}
	if m.adddisplay_index != nil {
		fields = append(fields, topmostgood.FieldDisplayIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopMostGoodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case topmostgood.FieldCreatedAt:
		return m.AddedCreatedAt()
	case topmostgood.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case topmostgood.FieldDeletedAt:
		return m.AddedDeletedAt()
	case topmostgood.FieldDisplayIndex:
		return m.AddedDisplayIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopMostGoodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case topmostgood.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case topmostgood.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case topmostgood.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case topmostgood.FieldDisplayIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayIndex(v)
		return nil
	}
	return fmt.Errorf("unknown TopMostGood numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopMostGoodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topmostgood.FieldDisplayIndex) {
		fields = append(fields, topmostgood.FieldDisplayIndex)
	}
	if m.FieldCleared(topmostgood.FieldPosters) {
		fields = append(fields, topmostgood.FieldPosters)
	}
	if m.FieldCleared(topmostgood.FieldPrice) {
		fields = append(fields, topmostgood.FieldPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopMostGoodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopMostGoodMutation) ClearField(name string) error {
	switch name {
	case topmostgood.FieldDisplayIndex:
		m.ClearDisplayIndex()
		return nil
	case topmostgood.FieldPosters:
		m.ClearPosters()
		return nil
	case topmostgood.FieldPrice:
		m.ClearPrice()
		return nil
	}
	return fmt.Errorf("unknown TopMostGood nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopMostGoodMutation) ResetField(name string) error {
	switch name {
	case topmostgood.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topmostgood.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case topmostgood.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case topmostgood.FieldAppID:
		m.ResetAppID()
		return nil
	case topmostgood.FieldGoodID:
		m.ResetGoodID()
		return nil
	case topmostgood.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case topmostgood.FieldTopMostID:
		m.ResetTopMostID()
		return nil
	case topmostgood.FieldDisplayIndex:
		m.ResetDisplayIndex()
		return nil
	case topmostgood.FieldPosters:
		m.ResetPosters()
		return nil
	case topmostgood.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown TopMostGood field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopMostGoodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopMostGoodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopMostGoodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopMostGoodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopMostGoodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopMostGoodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopMostGoodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TopMostGood unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopMostGoodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TopMostGood edge %s", name)
}

// VendorBrandMutation represents an operation that mutates the VendorBrand nodes in the graph.
type VendorBrandMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	name          *string
	logo          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VendorBrand, error)
	predicates    []predicate.VendorBrand
}

var _ ent.Mutation = (*VendorBrandMutation)(nil)

// vendorbrandOption allows management of the mutation configuration using functional options.
type vendorbrandOption func(*VendorBrandMutation)

// newVendorBrandMutation creates new mutation for the VendorBrand entity.
func newVendorBrandMutation(c config, op Op, opts ...vendorbrandOption) *VendorBrandMutation {
	m := &VendorBrandMutation{
		config:        c,
		op:            op,
		typ:           TypeVendorBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVendorBrandID sets the ID field of the mutation.
func withVendorBrandID(id uuid.UUID) vendorbrandOption {
	return func(m *VendorBrandMutation) {
		var (
			err   error
			once  sync.Once
			value *VendorBrand
		)
		m.oldValue = func(ctx context.Context) (*VendorBrand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VendorBrand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVendorBrand sets the old VendorBrand of the mutation.
func withVendorBrand(node *VendorBrand) vendorbrandOption {
	return func(m *VendorBrandMutation) {
		m.oldValue = func(context.Context) (*VendorBrand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VendorBrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VendorBrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VendorBrand entities.
func (m *VendorBrandMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VendorBrandMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VendorBrandMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VendorBrand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VendorBrandMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VendorBrandMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *VendorBrandMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *VendorBrandMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VendorBrandMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VendorBrandMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VendorBrandMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *VendorBrandMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *VendorBrandMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VendorBrandMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VendorBrandMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VendorBrandMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *VendorBrandMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *VendorBrandMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VendorBrandMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetName sets the "name" field.
func (m *VendorBrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VendorBrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VendorBrandMutation) ClearName() {
	m.name = nil
	m.clearedFields[vendorbrand.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VendorBrandMutation) NameCleared() bool {
	_, ok := m.clearedFields[vendorbrand.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VendorBrandMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, vendorbrand.FieldName)
}

// SetLogo sets the "logo" field.
func (m *VendorBrandMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *VendorBrandMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the VendorBrand entity.
// If the VendorBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorBrandMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *VendorBrandMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[vendorbrand.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *VendorBrandMutation) LogoCleared() bool {
	_, ok := m.clearedFields[vendorbrand.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *VendorBrandMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, vendorbrand.FieldLogo)
}

// Where appends a list predicates to the VendorBrandMutation builder.
func (m *VendorBrandMutation) Where(ps ...predicate.VendorBrand) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VendorBrandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VendorBrand).
func (m *VendorBrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VendorBrandMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, vendorbrand.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vendorbrand.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vendorbrand.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, vendorbrand.FieldName)
	}
	if m.logo != nil {
		fields = append(fields, vendorbrand.FieldLogo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VendorBrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vendorbrand.FieldCreatedAt:
		return m.CreatedAt()
	case vendorbrand.FieldUpdatedAt:
		return m.UpdatedAt()
	case vendorbrand.FieldDeletedAt:
		return m.DeletedAt()
	case vendorbrand.FieldName:
		return m.Name()
	case vendorbrand.FieldLogo:
		return m.Logo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VendorBrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vendorbrand.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vendorbrand.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vendorbrand.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vendorbrand.FieldName:
		return m.OldName(ctx)
	case vendorbrand.FieldLogo:
		return m.OldLogo(ctx)
	}
	return nil, fmt.Errorf("unknown VendorBrand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorBrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vendorbrand.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vendorbrand.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vendorbrand.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vendorbrand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vendorbrand.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	}
	return fmt.Errorf("unknown VendorBrand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VendorBrandMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, vendorbrand.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, vendorbrand.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, vendorbrand.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VendorBrandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vendorbrand.FieldCreatedAt:
		return m.AddedCreatedAt()
	case vendorbrand.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case vendorbrand.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorBrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vendorbrand.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case vendorbrand.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case vendorbrand.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VendorBrand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VendorBrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vendorbrand.FieldName) {
		fields = append(fields, vendorbrand.FieldName)
	}
	if m.FieldCleared(vendorbrand.FieldLogo) {
		fields = append(fields, vendorbrand.FieldLogo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VendorBrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VendorBrandMutation) ClearField(name string) error {
	switch name {
	case vendorbrand.FieldName:
		m.ClearName()
		return nil
	case vendorbrand.FieldLogo:
		m.ClearLogo()
		return nil
	}
	return fmt.Errorf("unknown VendorBrand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VendorBrandMutation) ResetField(name string) error {
	switch name {
	case vendorbrand.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vendorbrand.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vendorbrand.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vendorbrand.FieldName:
		m.ResetName()
		return nil
	case vendorbrand.FieldLogo:
		m.ResetLogo()
		return nil
	}
	return fmt.Errorf("unknown VendorBrand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VendorBrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VendorBrandMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VendorBrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VendorBrandMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VendorBrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VendorBrandMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VendorBrandMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VendorBrand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VendorBrandMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VendorBrand edge %s", name)
}

// VendorLocationMutation represents an operation that mutates the VendorLocation nodes in the graph.
type VendorLocationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	country       *string
	province      *string
	city          *string
	address       *string
	brand_id      *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VendorLocation, error)
	predicates    []predicate.VendorLocation
}

var _ ent.Mutation = (*VendorLocationMutation)(nil)

// vendorlocationOption allows management of the mutation configuration using functional options.
type vendorlocationOption func(*VendorLocationMutation)

// newVendorLocationMutation creates new mutation for the VendorLocation entity.
func newVendorLocationMutation(c config, op Op, opts ...vendorlocationOption) *VendorLocationMutation {
	m := &VendorLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeVendorLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVendorLocationID sets the ID field of the mutation.
func withVendorLocationID(id uuid.UUID) vendorlocationOption {
	return func(m *VendorLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *VendorLocation
		)
		m.oldValue = func(ctx context.Context) (*VendorLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VendorLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVendorLocation sets the old VendorLocation of the mutation.
func withVendorLocation(node *VendorLocation) vendorlocationOption {
	return func(m *VendorLocationMutation) {
		m.oldValue = func(context.Context) (*VendorLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VendorLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VendorLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VendorLocation entities.
func (m *VendorLocationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VendorLocationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VendorLocationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VendorLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VendorLocationMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VendorLocationMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *VendorLocationMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *VendorLocationMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VendorLocationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VendorLocationMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VendorLocationMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *VendorLocationMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *VendorLocationMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VendorLocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VendorLocationMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VendorLocationMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *VendorLocationMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *VendorLocationMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VendorLocationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCountry sets the "country" field.
func (m *VendorLocationMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *VendorLocationMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *VendorLocationMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[vendorlocation.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *VendorLocationMutation) CountryCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *VendorLocationMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, vendorlocation.FieldCountry)
}

// SetProvince sets the "province" field.
func (m *VendorLocationMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *VendorLocationMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *VendorLocationMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[vendorlocation.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *VendorLocationMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *VendorLocationMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, vendorlocation.FieldProvince)
}

// SetCity sets the "city" field.
func (m *VendorLocationMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *VendorLocationMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *VendorLocationMutation) ClearCity() {
	m.city = nil
	m.clearedFields[vendorlocation.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *VendorLocationMutation) CityCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *VendorLocationMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, vendorlocation.FieldCity)
}

// SetAddress sets the "address" field.
func (m *VendorLocationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *VendorLocationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *VendorLocationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[vendorlocation.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *VendorLocationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *VendorLocationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, vendorlocation.FieldAddress)
}

// SetBrandID sets the "brand_id" field.
func (m *VendorLocationMutation) SetBrandID(u uuid.UUID) {
	m.brand_id = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *VendorLocationMutation) BrandID() (r uuid.UUID, exists bool) {
	v := m.brand_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the VendorLocation entity.
// If the VendorLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VendorLocationMutation) OldBrandID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *VendorLocationMutation) ClearBrandID() {
	m.brand_id = nil
	m.clearedFields[vendorlocation.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *VendorLocationMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[vendorlocation.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *VendorLocationMutation) ResetBrandID() {
	m.brand_id = nil
	delete(m.clearedFields, vendorlocation.FieldBrandID)
}

// Where appends a list predicates to the VendorLocationMutation builder.
func (m *VendorLocationMutation) Where(ps ...predicate.VendorLocation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VendorLocationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VendorLocation).
func (m *VendorLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VendorLocationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, vendorlocation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vendorlocation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vendorlocation.FieldDeletedAt)
	}
	if m.country != nil {
		fields = append(fields, vendorlocation.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, vendorlocation.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, vendorlocation.FieldCity)
	}
	if m.address != nil {
		fields = append(fields, vendorlocation.FieldAddress)
	}
	if m.brand_id != nil {
		fields = append(fields, vendorlocation.FieldBrandID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VendorLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vendorlocation.FieldCreatedAt:
		return m.CreatedAt()
	case vendorlocation.FieldUpdatedAt:
		return m.UpdatedAt()
	case vendorlocation.FieldDeletedAt:
		return m.DeletedAt()
	case vendorlocation.FieldCountry:
		return m.Country()
	case vendorlocation.FieldProvince:
		return m.Province()
	case vendorlocation.FieldCity:
		return m.City()
	case vendorlocation.FieldAddress:
		return m.Address()
	case vendorlocation.FieldBrandID:
		return m.BrandID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VendorLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vendorlocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vendorlocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vendorlocation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vendorlocation.FieldCountry:
		return m.OldCountry(ctx)
	case vendorlocation.FieldProvince:
		return m.OldProvince(ctx)
	case vendorlocation.FieldCity:
		return m.OldCity(ctx)
	case vendorlocation.FieldAddress:
		return m.OldAddress(ctx)
	case vendorlocation.FieldBrandID:
		return m.OldBrandID(ctx)
	}
	return nil, fmt.Errorf("unknown VendorLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vendorlocation.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vendorlocation.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vendorlocation.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vendorlocation.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case vendorlocation.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case vendorlocation.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case vendorlocation.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case vendorlocation.FieldBrandID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	}
	return fmt.Errorf("unknown VendorLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VendorLocationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, vendorlocation.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, vendorlocation.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, vendorlocation.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VendorLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vendorlocation.FieldCreatedAt:
		return m.AddedCreatedAt()
	case vendorlocation.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case vendorlocation.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VendorLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vendorlocation.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case vendorlocation.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case vendorlocation.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VendorLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VendorLocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vendorlocation.FieldCountry) {
		fields = append(fields, vendorlocation.FieldCountry)
	}
	if m.FieldCleared(vendorlocation.FieldProvince) {
		fields = append(fields, vendorlocation.FieldProvince)
	}
	if m.FieldCleared(vendorlocation.FieldCity) {
		fields = append(fields, vendorlocation.FieldCity)
	}
	if m.FieldCleared(vendorlocation.FieldAddress) {
		fields = append(fields, vendorlocation.FieldAddress)
	}
	if m.FieldCleared(vendorlocation.FieldBrandID) {
		fields = append(fields, vendorlocation.FieldBrandID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VendorLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VendorLocationMutation) ClearField(name string) error {
	switch name {
	case vendorlocation.FieldCountry:
		m.ClearCountry()
		return nil
	case vendorlocation.FieldProvince:
		m.ClearProvince()
		return nil
	case vendorlocation.FieldCity:
		m.ClearCity()
		return nil
	case vendorlocation.FieldAddress:
		m.ClearAddress()
		return nil
	case vendorlocation.FieldBrandID:
		m.ClearBrandID()
		return nil
	}
	return fmt.Errorf("unknown VendorLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VendorLocationMutation) ResetField(name string) error {
	switch name {
	case vendorlocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vendorlocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vendorlocation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vendorlocation.FieldCountry:
		m.ResetCountry()
		return nil
	case vendorlocation.FieldProvince:
		m.ResetProvince()
		return nil
	case vendorlocation.FieldCity:
		m.ResetCity()
		return nil
	case vendorlocation.FieldAddress:
		m.ResetAddress()
		return nil
	case vendorlocation.FieldBrandID:
		m.ResetBrandID()
		return nil
	}
	return fmt.Errorf("unknown VendorLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VendorLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VendorLocationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VendorLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VendorLocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VendorLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VendorLocationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VendorLocationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VendorLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VendorLocationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VendorLocation edge %s", name)
}
